{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,E,Q,C,Q,S,C,C,C,E,E,E,O,C,qB,I,G,E,E,O,C,sB,I,G,E,E,O,C,mB,I,G,E,E,O,C,gB,I,G,E,E,O,C,a,I,G,E,E,O,C,yB,I,G,E,E,O,C,O,I,G,E,E,O,C,sB,I,G,E,E,O,C,U,I,G,E,E,O,C,O,I,G,E,E,O,C,Y,I,G,E,E,O,C,gB,I,G,E,E,O,C,oB,I,G,E,E,O,C,8B,I,G,E,E,O,C,kB,I,G,E,E,O,C,a,I,G,E,E,O,C,c,I,G,E,E,O,C,kB,I,G,E,E,O,C,qB,I,G,E,E,O,C,uB,I,A,E,S,oB,E,E,E,O,C,Q,I,A,E,S,K,E,E,E,O,C,e,I,A,E,S,Y,E,E,E,O,C,W,I,A,E,S,Q,E,E,E,O,C,iB,I,A,E,S,M,E,E,E,O,C,S,I,A,E,S,M,E,E,E,O,C,Q,I,A,E,S,K,E,E,E,O,C,S,I,A,E,S,M,E,E,E,O,C,iB,I,A,E,S,c,E,E,E,O,C,S,I,A,E,S,M,E,E,E,O,C,2B,I,A,E,S,wB,E,E,E,O,C,gC,I,A,E,S,6B,E,E,E,O,C,yB,I,A,E,S,sB,E,E,E,O,C,2B,I,A,E,S,wB,E,E,E,O,C,sB,I,A,E,S,mB,E,E,E,O,C,oB,I,A,E,S,iB,E,E,E,O,C,qB,I,A,E,S,kB,E,E,E,O,C,a,I,A,E,S,U,E,E,E,O,C,2B,I,A,E,S,wB,E,E,E,O,C,2B,I,A,E,S,wB,E,E,E,O,C,Q,I,A,E,S,K,E,E,E,O,C,e,I,A,E,S,Y,E,E,E,O,C,uB,I,A,E,S,oB,E,E,E,O,C,O,I,A,E,S,I,E,E,E,O,C,Y,I,A,E,S,S,E,E,E,O,C,c,I,A,E,S,W,E,E,E,O,C,Y,I,A,E,S,S,E,E,E,O,C,W,I,A,E,S,Q,E,E,E,O,C,gB,I,A,E,S,a,E,E,E,O,C,c,I,A,E,S,W,E,E,E,O,C,sB,I,A,E,S,mB,E,E,E,O,C,gB,I,A,E,S,a,E,E,E,O,C,gB,I,A,E,S,a,E,E,E,O,C,gB,I,A,E,S,a,E,E,E,O,C,U,I,A,E,S,O,E,E,E,O,C,qB,I,A,E,S,kB,E,E,E,O,C,gB,I,A,E,S,a,E,E,E,O,C,c,I,A,E,S,W,E,E,E,O,C,W,I,A,E,S,Q,E,E,E,O,C,a,I,A,E,S,U,E,E,E,O,C,c,I,A,E,S,W,E,E,E,O,C,gB,I,A,E,S,a,E,E,E,O,C,oB,I,A,E,S,iB,E,E,E,O,C,Y,I,A,E,S,S,E,E,E,O,C,mB,I,A,E,S,gB,E,E,E,O,C,Y,I,A,E,S,S,E,E,E,O,C,kB,I,A,E,S,e,E,E,E,O,C,iB,I,A,E,S,c,E,E,E,O,C,gB,I,A,E,S,a,E,E,E,O,C,qB,I,A,E,S,kB,E,E,E,O,C,Y,I,A,E,S,S,E,IG03BKkG,EAOAC,EAPAD,EAOAC,E,E,E,S,E,E,S,G,E,S,E,S,E,U,S,I,M,A,C,E,O,M,C,O,M,C,I,G,S,C,E,I,I,E,E,E,U,M,C,I,C,I,E,S,C,E,C,I,I,K,E,O,S,C,c,C,I,C,E,I,C,C,C,E,C,C,C,E,A,C,C,O,C,C,E,K,C,I,C,U,C,S,E,C,C,C,E,G,A,M,E,M,C,E,I,E,E,E,C,E,E,O,I,C,G,I,E,E,E,E,M,C,I,E,C,C,E,C,E,O,C,I,G,C,C,C,E,C,C,C,E,A,E,O,C,CDz3BL,IAAMg3B,EAA8B,oCAE9B,SAAUC,EAAcx1B,CAAW,EACvC,OAAOA,AAAU,MAAVA,GAAkB,AAA0B,UAA1B,OAAOA,EAAOC,OAAAA,AACzC,CA+DgB,SAAA61B,EACdr8B,CAAA,EAEA,OAFA,KAAA,IAAAA,GAAAA,CAAAA,EAA4B,EAAE,EAEvB,IAAIyG,gBACT,AAAgB,UAAhB,OAAOzG,GACP0G,MAAMC,OAAAA,CAAQ3G,IACdA,aAAgByG,gBACZzG,EACAhB,OAAOmH,IAAAA,CAAKnG,GAAM4G,MAAAA,CAAO,CAACC,EAAMjB,KAC9B,IAAIkB,EAAQ9G,CAAI,CAAC4F,EAAI,CACrB,OAAOiB,EAAKE,MAAAA,CACVL,MAAMC,OAAAA,CAAQG,GAASA,EAAME,GAAAA,CAAKlI,AAAAA,GAAM,CAAC8G,EAAK9G,EAAE,EAAI,CAAC,CAAC8G,EAAKkB,EAAM,CAAC,CAErE,EAAE,EAAyB,EAEpC,CAuCA,IAAIy1B,EAA6C,KA+D3CE,EAA0C,IAAIt1B,IAAI,CACtD,oCACA,sBACA,aACD,EAED,SAASu1B,EAAer1B,CAAsB,SAC5C,AAAIA,AAAW,MAAXA,GAAoBo1B,EAAsBn1B,GAAAA,CAAID,GAS3CA,EAFE,IAGX,CAEgB,SAAA01B,EACdx3B,CAAoB,CACpBiC,CAAgB,EAQhB,IAAIC,EACAC,EACAL,EACAM,EACAC,EAEJ,GAhNOm0B,EAgNWx2B,IAhNcgB,AAAiC,SAAjCA,AAgNdhB,EAhNqBiB,OAAAA,CAAQqB,WAAAA,GAgNpB,CAIzB,IAAIC,EAAOvC,EAAOwC,YAAAA,CAAa,UAC/BL,EAASI,EAAOE,AAAAA,CAAAA,EAAAA,EAAAA,aAAAA,AAAAA,EAAcF,EAAMN,GAAY,KAChDC,EAASlC,EAAOwC,YAAAA,CAAa,WAlOY,MAmOzCV,EAAUq1B,EAAen3B,EAAOwC,YAAAA,CAAa,aAAe+zB,EAE5Dn0B,EAAW,IAAIM,SAAS1C,EACzB,MAAM,GACLy2B,AA/NKD,EA+NWx2B,IA/NcgB,AAAiC,WAAjCA,AA+NdhB,EA/NqBiB,OAAAA,CAAQqB,WAAAA,IAgO5Cq0B,AAxNIH,EAwNWx2B,IAxNcgB,AAAiC,UAAjCA,AAwNdhB,EAxNqBiB,OAAAA,CAAQqB,WAAAA,IAyN1CtC,CAAAA,AAAgB,WAAhBA,EAAO6C,IAAAA,EAAqB7C,AAAgB,UAAhBA,EAAO6C,IAAAA,AAAS,EAC/C,CACA,IAAIC,EAAO9C,EAAO8C,IAAlB,CAEA,GAAIA,AAAQ,MAARA,EACF,MAAM,AAAIjI,MAAK,sEAUjB,IAAI0H,EAAOvC,EAAOwC,YAAAA,CAAa,eAAiBM,EAAKN,YAAAA,CAAa,UAmBlE,GAlBAL,EAASI,EAAOE,AAAAA,CAAAA,EAAAA,EAAAA,aAAAA,AAAAA,EAAcF,EAAMN,GAAY,KAEhDC,EACElC,EAAOwC,YAAAA,CAAa,eACpBM,EAAKN,YAAAA,CAAa,WA7PqB,MA+PzCV,EACEq1B,EAAen3B,EAAOwC,YAAAA,CAAa,iBACnC20B,EAAer0B,EAAKN,YAAAA,CAAa,aACjC+zB,EAGFn0B,EAAW,IAAIM,SAASI,EAAM9C,GAM1B,CAACi3B,AA/IT,WACE,GAAID,AAA+B,OAA/BA,EACF,GAAI,CACF,IAAIt0B,SACFM,SAASC,aAAAA,CAAc,QAEvB,GAEF+zB,EAA6B,CAAA,CAC9B,CAAC,MAAO39B,EAAG,CACV29B,EAA6B,CAAA,CAC9B,CAEH,OAAOA,CACT,IAiIyC,CACnC,GAAI,CAAA,KAAE9zB,CAAI,CAAA,KAAEL,CAAI,CAAA,MAAEtB,CAAAA,CAAO,CAAGvB,EAC5B,GAAI6C,AAAS,UAATA,EAAkB,CACpB,IAAIM,EAASD,EAAUA,EAAI,IAAM,GACjCd,EAASgB,MAAAA,CAAUD,EAAM,IAAK,KAC9Bf,EAASgB,MAAAA,CAAUD,EAAM,IAAK,IAC/B,MAAUD,GACTd,EAASgB,MAAAA,CAAOF,EAAM3B,EAEzB,CACF,MAAM,GAAIi1B,EAAcx2B,GACvB,MAAM,AAAInF,MACR,2FAIFqH,EA3RyC,MA4RzCC,EAAS,KACTL,EAAUy0B,EACVl0B,EAAOrC,EAST,OALIoC,GAAYN,AAAY,eAAZA,IACdO,EAAOD,EACPA,EAAWiB,KAAAA,GAGN,CAAElB,OAAAA,EAAQD,OAAQA,EAAOI,WAAfJ,GAA8BJ,QAAAA,EAASM,SAAAA,EAAUC,KAAAA,CAAM,CAC1E,C,I,E,C,U,W,iB,U,Q,S,K,qB,C,E,C,e,gB,Y,M,Q,K,W,C,E,C,iB,U,Q,S,S,W,S,W,qB,CCrFgB,SAAAo1B,EACdh0B,CAAqB,CACrBC,CAAoB,EAEpB,MAAOC,AAAAA,CAAAA,EAAAA,EAAAA,YAAAA,AAAAA,EAAa,CAClB1B,SAAUyB,AAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAMzB,QAAhBA,CACA2B,OAAM8zB,EAAA,CAAA,EACDh0B,AAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAME,MAAAA,CAAM,CACfC,mBAAoB,CAAA,CACrB,GACDC,QAASC,AAAAA,CAAAA,EAAAA,EAAAA,oBAAAA,AAAAA,EAAqB,CAAE7J,OAAQwJ,AAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAMxJ,MAAdA,AAAoB,GACpD8J,cAAeN,AAAAA,CAAAA,AAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAMM,aAAAA,AAAAA,GAAiB2zB,IACtCl0B,OAAAA,EACAS,mBAAAA,EAAAA,yBAAAA,AACD,GAAEE,UAAF,EACH,CAEgB,SAAAwzB,EACdn0B,CAAqB,CACrBC,CAAoB,EAEpB,MAAOC,AAAAA,CAAAA,EAAAA,EAAAA,YAAAA,AAAAA,EAAa,CAClB1B,SAAUyB,AAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAMzB,QAAhBA,CACA2B,OAAM8zB,EAAA,CAAA,EACDh0B,AAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAME,MAAAA,CAAM,CACfC,mBAAoB,CAAA,CACrB,GACDC,QAASO,AAAAA,CAAAA,EAAAA,EAAAA,iBAAAA,AAAAA,EAAkB,CAAEnK,OAAQwJ,AAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAMxJ,MAAdA,AAAoB,GACjD8J,cAAeN,AAAAA,CAAAA,AAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAMM,aAAAA,AAAAA,GAAiB2zB,IACtCl0B,OAAAA,EACAS,mBAAAA,EAAAA,yBAAAA,AACD,GAAEE,UAAF,EACH,CAEA,SAASuzB,IAAkB,IAAArzB,EACzB,IAAIC,EAAKD,AAAGA,MAAHA,CAAAA,EAAGpK,MAAAA,EAAAoK,KAAAA,EAAAA,EAAQE,2BAApB,CAOA,OANID,GAASA,EAAME,MAAAA,EACjBF,CAAAA,EAAKmzB,EAAA,CAAA,EACAnzB,EAAK,CACRE,OAAQozB,AAMd,SACEpzB,CAAsC,EAEtC,GAAI,CAACA,EAAQ,OAAO,KACpB,IAAIE,EAAUlL,OAAOkL,OAAAA,CAAQF,GACzBG,EAA6C,CAAA,EACjD,IAAK,GAAI,CAACvE,EAAKwE,EAAI,GAAIF,EAGrB,GAAIE,GAAOA,AAAe,uBAAfA,EAAIC,MAAAA,CACbF,CAAU,CAACvE,EAAI,CAAG,IAAI0E,EAAAA,aAAAA,CACpBF,EAAIG,MAAAA,CACJH,EAAII,UAAAA,CACJJ,EAAIK,IAAAA,CACJL,AAAiB,CAAA,IAAjBA,EAAIM,QAAAA,OAED,GAAIN,GAAOA,AAAe,UAAfA,EAAIC,MAAAA,CAAoB,CAExC,GAAID,EAAIO,SAAAA,CAAW,CACjB,IAAIC,EAAmBnL,MAAM,CAAC2K,EAAIO,SAAAA,CAAU,CAC5C,GAAI,AAA4B,YAA5B,OAAOC,EACT,GAAI,CAEF,IAAIC,EAAQ,IAAID,EAAiBR,EAAIU,OAArC,CAGAD,CAAAA,EAAME,KAAAA,CAAQ,GACdZ,CAAU,CAACvE,EAAI,CAAGiF,CACnB,CAAC,MAAOjM,EAAG,CACV,CAGL,CAED,GAAIuL,AAAmB,MAAnBA,CAAU,CAACvE,EAAI,CAAU,CAC3B,IAAIiF,EAAQ,AAAIzK,MAAMgK,EAAIU,OAA1B,CAGAD,CAAAA,EAAME,KAAAA,CAAQ,GACdZ,CAAU,CAACvE,EAAI,CAAGiF,CACnB,CACF,MACCV,CAAU,CAACvE,EAAI,CAAGwE,EAGtB,OAAOD,CACT,EApDgCL,EAAME,MAAhCA,CACD,EAAA,EAEIF,CACT,CA8EA,IAAMwzB,EAAsBC,EADH,eAC0B,CAY7C,SAAUC,EAAavyB,CAAA,EAKR,GALS,CAAA,SAC5BzD,CAAQ,CAAA,SACR0D,CAAQ,CAAA,OACR/B,CAAM,CACN1J,OAAAA,CAAAA,CACmB,CAAAwL,EACfG,EAAamyB,EAAMlyB,MAAvB,EAC0B,OAAtBD,EAAWE,OAAAA,EACbF,CAAAA,EAAWE,OAAAA,CAAUhC,AAAAA,CAAAA,EAAAA,EAAAA,oBAAAA,AAAAA,EAAqB,CAAE7J,OAAAA,EAAQ8L,SAAU,CAAA,CAAI,EAAA,EAGpE,IAAIlC,EAAU+B,EAAWE,OAAzB,CACI,CAACxB,EAAO0B,EAAa,CAAG+xB,EAAM9xB,QAAAA,CAAS,CACzC/D,OAAQ2B,EAAQ3B,MAAhBA,CACAgE,SAAUrC,EAAQqC,QAAlBA,AACD,GACG,CAAA,mBAAEC,CAAAA,CAAoB,CAAGxC,GAAU,CAAA,EACnCyC,EAAW2xB,EAAM1xB,WAAAA,CAClBC,AAAAA,IACCH,GAAsB2xB,EAClBA,EAAoB,IAAM9xB,EAAaM,IACvCN,EAAaM,EACnB,EACA,CAACN,EAAcG,EAAmB,EAKpC,OAFA4xB,EAAMxxB,eAAAA,CAAgB,IAAM1C,EAAQ2C,MAAAA,CAAOJ,GAAW,CAACvC,EAASuC,EAAS,EAGvE2xB,EAAA/0B,aAAAA,CAACvG,EAAAA,MAAAA,CAAM,CACLuF,SAAUA,EACV0D,SAAUA,EACVQ,SAAU5B,EAAM4B,QAAhBA,CACAO,eAAgBnC,EAAMpC,MAAtBuE,CACAC,UAAW7C,CAAO,EAGxB,CAaM,SAAUo0B,EAAUtxB,CAAA,EAKR,GALS,CAAA,SACzB3E,CAAQ,CAAA,SACR0D,CAAQ,CAAA,OACR/B,CAAM,CACN1J,OAAAA,CAAAA,CACgB,CAAA0M,EACZf,EAAamyB,EAAMlyB,MAAvB,EAC0B,OAAtBD,EAAWE,OAAAA,EACbF,CAAAA,EAAWE,OAAAA,CAAU1B,AAAAA,CAAAA,EAAAA,EAAAA,iBAAAA,AAAAA,EAAkB,CAAEnK,OAAAA,EAAQ8L,SAAU,CAAA,CAAI,EAAA,EAGjE,IAAIlC,EAAU+B,EAAWE,OAAzB,CACI,CAACxB,EAAO0B,EAAa,CAAG+xB,EAAM9xB,QAAAA,CAAS,CACzC/D,OAAQ2B,EAAQ3B,MAAhBA,CACAgE,SAAUrC,EAAQqC,QAAlBA,AACD,GACG,CAAA,mBAAEC,CAAAA,CAAoB,CAAGxC,GAAU,CAAA,EACnCyC,EAAW2xB,EAAM1xB,WAAAA,CAClBC,AAAAA,IACCH,GAAsB2xB,EAClBA,EAAoB,IAAM9xB,EAAaM,IACvCN,EAAaM,EACnB,EACA,CAACN,EAAcG,EAAmB,EAKpC,OAFA4xB,EAAMxxB,eAAAA,CAAgB,IAAM1C,EAAQ2C,MAAAA,CAAOJ,GAAW,CAACvC,EAASuC,EAAS,EAGvE2xB,EAAA/0B,aAAAA,CAACvG,EAAAA,MAAAA,CAAM,CACLuF,SAAUA,EACV0D,SAAUA,EACVQ,SAAU5B,EAAM4B,QAAhBA,CACAO,eAAgBnC,EAAMpC,MAAtBuE,CACAC,UAAW7C,CAAO,EAGxB,CAeA,SAASq0B,EAAatxB,CAAA,EAKD,GALE,CAAA,SACrB5E,CAAQ,CAAA,SACR0D,CAAQ,CAAA,OACR/B,CAAM,CAAA,QACNE,CAAAA,CACmB,CAAA+C,EACf,CAACtC,EAAO0B,EAAa,CAAG+xB,EAAM9xB,QAAAA,CAAS,CACzC/D,OAAQ2B,EAAQ3B,MAAhBA,CACAgE,SAAUrC,EAAQqC,QAAlBA,AACD,GACG,CAAA,mBAAEC,CAAAA,CAAoB,CAAGxC,GAAU,CAAA,EACnCyC,EAAW2xB,EAAM1xB,WAAAA,CAClBC,AAAAA,IACCH,GAAsB2xB,EAClBA,EAAoB,IAAM9xB,EAAaM,IACvCN,EAAaM,EACnB,EACA,CAACN,EAAcG,EAAmB,EAKpC,OAFA4xB,EAAMxxB,eAAAA,CAAgB,IAAM1C,EAAQ2C,MAAAA,CAAOJ,GAAW,CAACvC,EAASuC,EAAS,EAGvE2xB,EAAA/0B,aAAAA,CAACvG,EAAAA,MAAAA,CAAM,CACLuF,SAAUA,EACV0D,SAAUA,EACVQ,SAAU5B,EAAM4B,QAAhBA,CACAO,eAAgBnC,EAAMpC,MAAtBuE,CACAC,UAAW7C,CAAO,EAGxB,CAkBA,IAAMolB,EACJ,AAAkB,aAAlB,OAAOhvB,QACP,AAA2B,KAAA,IAApBA,OAAO8I,QAAAA,EACd,AAAyC,KAAA,IAAlC9I,OAAO8I,QAAAA,CAASC,aAAAA,CAEnBo1B,EAAqB,gCAKdC,EAAON,EAAMhxB,UAAAA,CACxB,SAAoBC,CAAA,CAYlBC,CAAG,EAAA,IAKCC,EAhBJ,CAAA,QACEC,CAAO,CAAA,SACPC,CAAQ,CAAA,eACRC,CAAc,CAAA,QACdC,CAAO,CAAA,MACPhD,CAAK,CAAA,OACLvE,CAAM,CAAA,GACNwH,CAAE,CAAA,mBACFC,CAAAA,CAED,CAAAR,EADIS,EAAI8wB,EAAAvxB,EAAAwxB,GAIL,CAAA,SAAEx2B,CAAAA,CAAU,CAAG+1B,EAAMrwB,UAAAA,CAAW+wB,EAAAA,wBAAAA,EAIhC9wB,EAAa,CAAA,EAEjB,GAAI,AAAc,UAAd,OAAOJ,GAAmB6wB,EAAmBxwB,IAAAA,CAAKL,KAEpDL,EAAeK,EAGX0hB,GACF,GAAI,CACF,IAAIphB,EAAa,IAAIC,IAAI7N,OAAOiM,QAAAA,CAAS6B,IAAzC,EACIC,MACIF,IADQP,EAAGU,UAAAA,CAAW,MAClBJ,EAAWK,QAAAA,CAAWX,EACtBA,GACRY,EAAO3F,AAAAA,CAAAA,EAAAA,EAAAA,aAAAA,AAAAA,EAAcwF,EAAUI,QAAAA,CAAUpG,EAEzCgG,CAAAA,EAAUK,MAAAA,GAAWR,EAAWQ,MAAAA,EAAUF,AAAQ,MAARA,EAE5CZ,EAAKY,EAAOH,EAAUM,MAAAA,CAASN,EAAUO,IAAzChB,CAEAI,EAAa,CAAA,CAEhB,CAAC,MAAOvO,EAAG,CAOX,CAKL,IAAI2O,EAAO3J,AAAAA,CAAAA,EAAAA,EAAAA,OAAAA,AAAAA,EAAQmJ,EAAI,CAAEH,SAAAA,CAAU,GAE/BoB,EAAkBkwB,EAAoBnxB,EAAI,CAC5CD,QAAAA,EACAhD,MAAAA,EACAvE,OAAAA,EACAyH,mBAAAA,EACAJ,SAAAA,CACD,GAUD,OAEE2wB,EAAA/0B,aAAAA,CAAA,IAAAy0B,EAAA,CAAA,EACMhwB,EAAI,CACRM,KAAMb,GAAgBa,EACtBZ,QAASQ,GAAcN,EAAiBF,EAd5C,SACEsB,CAAsD,EAElDtB,GAASA,EAAQsB,GAChBA,EAAMC,gBAAAA,EACTF,EAAgBC,EAEpB,EAQIxB,IAAKA,EACLlH,OAAQA,CAAM,GAGpB,GA+BW64B,EAAUb,EAAMhxB,UAAAA,CAC3B,SAAuB4B,CAAA,CAWrB1B,CAAG,EAAA,IAuCC2B,EAjDJ,CACE,eAAgBC,EAAkB,MAAM,CAAA,cACxCC,EAAgB,CAAA,CAAA,CAChBF,UAAWG,EAAgB,EAAE,CAAA,IAC7BC,EAAM,CAAA,CAAA,CACNC,MAAOC,CAAS,CAAA,GAChB3B,CAAE,CAAA,SACF7B,CAAAA,CAED,CAAAiD,EADIlB,EAAI8wB,EAAA5vB,EAAAmwB,GAIL3wB,EAAOnJ,AAAAA,CAAAA,EAAAA,EAAAA,eAAAA,AAAAA,EAAgBuI,EAAI,CAAEH,SAAUK,EAAKL,QAAfA,AAAuB,GACpDlB,EAAW3H,AAAAA,CAAAA,EAAAA,EAAAA,WAAAA,AAAAA,IACX4K,EAAc4uB,EAAMrwB,UAAAA,CAAWqxB,EAAAA,6BAAAA,EAC/B,CAAA,UAAEryB,CAAAA,CAAW,CAAGqxB,EAAMrwB,UAAAA,CAAW+wB,EAAAA,wBAAAA,EAEjCrvB,EAAa1C,EAAU2C,cAAAA,CACvB3C,EAAU2C,cAAAA,CAAelB,GAAMC,QAAAA,CAC/BD,EAAKC,QAFT,CAGIkB,EAAmBpD,EAASkC,QAAhC,CACImB,EACFJ,GAAeA,EAAYK,UAAAA,EAAcL,EAAYK,UAAAA,CAAWtD,QAAAA,CAC5DiD,EAAYK,UAAAA,CAAWtD,QAAAA,CAASkC,QAAAA,CAChC,KAEDU,IACHQ,EAAmBA,EAAiBjH,WAApCiH,GACAC,EAAuBA,EACnBA,EAAqBlH,WAAAA,GACrB,KACJ+G,EAAaA,EAAW/G,WAAxB+G,IAGF,IAAIK,EACFH,IAAqBF,GACpB,CAACJ,GACAM,EAAiBrB,UAAAA,CAAWmB,IAC5BE,AAA+C,MAA/CA,EAAiBI,MAAAA,CAAON,EAAWlJ,MAAAA,EAEnCyJ,EACFJ,AAAwB,MAAxBA,GACCA,CAAAA,IAAyBH,GACvB,CAACJ,GACAO,EAAqBtB,UAAAA,CAAWmB,IAChCG,AAAmD,MAAnDA,EAAqBG,MAAAA,CAAON,EAAWlJ,MAAAA,CAAY,EAMvD0I,EADE,AAAyB,YAAzB,OAAOG,EACGA,EAAc,CAAEU,SAAAA,EAAUE,UAAAA,CAAW,GAOrC,CACVZ,EACAU,EAAW,SAAW,KACtBE,EAAY,UAAY,KACzB,CACEC,MAAAA,CAAOC,SACPC,IAAAA,CAAK,KAGV,IAAIb,EACF,AAAqB,YAArB,OAAOC,EACHA,EAAU,CAAEO,SAAAA,EAAUE,UAAAA,CAAW,GACjCT,EAEN,OACE6uB,EAAC/0B,aAAAA,CAAAq1B,EAAIZ,EAAA,CAAA,EACChwB,EAAI,CACM,eA5BAgC,EAAWZ,EAAkBzF,KAAAA,EA6B3CwF,UAAWA,EACX3B,IAAKA,EACLgC,MAAOA,EACP1B,GAAIA,CAAE,GAEL,AAAoB,YAApB,OAAO7B,EACJA,EAAS,CAAE+D,SAAAA,EAAUE,UAAAA,CAAW,GAChCjE,EAGV,GA0EW4I,EAAOypB,EAAMhxB,UAAAA,CACxB,CAACgD,EAAO9C,KACN,IAAI+C,EAASivB,IACb,OAAOlB,EAAC/0B,aAAAA,CAAAk2B,EAAQzB,EAAA,CAAA,EAAK1tB,EAAK,CAAEC,OAAQA,EAAQ/C,IAAKA,CAAG,GACtD,GAmBIiyB,EAAWnB,EAAMhxB,UAAAA,CACrB,CAAAmD,EAaEC,KACE,GAbF,CAAA,eACE9C,CAAc,CAAA,QACdC,CAAO,CAAA,MACPhD,CAAK,CAAA,OACLrC,EDvyBuC,KCuyB9Bo0B,CAAAA,OACTn0B,CAAM,CAAA,SACNkI,CAAQ,CAAA,OACRJ,CAAM,CAAA,SACN5C,CAAQ,CAAA,mBACRI,CAAAA,CAED,CAAA0C,EADIH,EAAKwuB,EAAAruB,EAAAivB,GAIN9uB,EACFpI,AAAyB,QAAzBA,EAAOI,WAAAA,GAA0B,MAAQ,OACvCiI,EAAa8uB,EAAcl3B,EAAQ,CAAEkF,SAAAA,CAAU,GAsBnD,OACE2wB,EAAA/0B,aAAAA,CAAA,OAAAy0B,EAAA,CACExwB,IAAKkD,EACLlI,OAAQoI,EACRnI,OAAQoI,EACRF,SAAU/C,EAAiB+C,EA1B+B3B,AAAAA,IAE5D,GADA2B,GAAYA,EAAS3B,GACjBA,EAAMC,gBAAAA,CAAkB,OAC5BD,EAAM8B,cAAN9B,GAEA,IAAI+B,EAAa/B,EAAqCgC,WAAAA,CACnDD,SADH,CAGIE,EACDF,AAAAA,CAAAA,AAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAWjI,YAAAA,CAAa,aAAA,GACzBN,EAEF+H,EAAOQ,GAAa/B,EAAMkC,aAAAA,CAAe,CACvC1I,OAAQyI,EACRpD,QAAAA,EACAhD,MAAAA,EACA8C,SAAAA,EACAI,mBAAAA,CACD,EACF,CAQOuC,EAAAA,GAGV,GAgBcuvB,SAAAA,EAAiB1uB,CAAA,EAGR,GAHS,CAAA,OAChCC,CAAM,CAAA,WACNC,CAAAA,CACuB,CAAAF,EAEvB,OADA2uB,EAAqB,CAAE1uB,OAAAA,EAAQC,WAAAA,CAAU,GAClC,IACT,CA6BA,SAAS2uB,EAAqBzuB,CAAwB,EACpD,IAAIC,EAAM8sB,EAAMrwB,UAAAA,CAAWgyB,EAAAA,wBAAAA,EAE3B,OADA,AAAUzuB,GAAV0uB,AAAAA,CAAAA,EAAAA,EAAAA,gBAAAA,AAAAA,EAAS,CAAA,GACF1uB,CACT,CAEA,SAAS2uB,EAAmB5uB,CAA6B,EACvD,IAAI1G,EAAQyzB,EAAMrwB,UAAAA,CAAWqxB,EAAAA,6BAAAA,EAE7B,OADA,AAAUz0B,GAAVq1B,AAAAA,CAAAA,EAAAA,EAAAA,gBAAAA,AAAAA,EAAS,CAAA,GACFr1B,CACT,CAOgBo0B,SAAAA,EACdnxB,CAAM,CAAA6D,CAAA,EAaA,GAZN,CAAA,OACErL,CAAM,CACNuH,QAAS+D,CAAW,CAAA,MACpB/G,CAAK,CAAA,mBACLkD,CAAkB,CAAA,SAClBJ,CAAAA,CAOE,CAAA,AAAA,KAAA,IAAA,EAAA,CAAA,EAAEgE,EAEFE,EAAW5M,AAAAA,CAAAA,EAAAA,EAAAA,WAAAA,AAAAA,IACXwH,EAAW3H,AAAAA,CAAAA,EAAAA,EAAAA,WAAAA,AAAAA,IACX4J,EAAOnJ,AAAAA,CAAAA,EAAAA,EAAAA,eAAAA,AAAAA,EAAgBuI,EAAI,CAAEH,SAAAA,CAAU,GAE3C,OAAO2wB,EAAM1xB,WAAAA,CACVoC,AAAAA,IACC,GD34BFA,AAAiB,IAAjBA,AC24B6BA,ED34BvB8C,MAAAA,EACL,CAAA,CC04BmCxL,GD14BxBA,AAAW,UC04BaA,CD14Bb,GATjB,CAAE0I,CAAAA,ACm5BqBA,EDn5Bf+C,OAAAA,EAAW/C,ACm5BIA,EDn5BEgD,MAAAA,EAAUhD,ACm5BZA,EDn5BkBiD,OAAAA,EAAWjD,ACm5B7BA,EDn5BmCkD,QAAAA,AAAAA,ECm5BnB,CACzClD,EAAM8B,cAAN9B,GAIA,IAAInB,EACF+D,AAAgBjI,KAAAA,IAAhBiI,EACIA,EACAlO,AAAAA,CAAAA,EAAAA,EAAAA,UAAAA,AAAAA,EAAW+I,KAAc/I,AAAAA,CAAAA,EAAAA,EAAAA,UAAAA,AAAAA,EAAWgL,GAE1CmD,EAAS/D,EAAI,CAAED,QAAAA,EAAShD,MAAAA,EAAOkD,mBAAAA,EAAoBJ,SAAAA,CAAQ,EAC5D,CACF,EACD,CACElB,EACAoF,EACAnD,EACAkD,EACA/G,EACAvE,EACAwH,EACAC,EACAJ,EACD,CAEL,CAMM,SAAUyyB,EACdjuB,CAAiC,EAcjC,IAAIC,EAAyBksB,EAAMlyB,MAAAA,CAAOgxB,EAAmBjrB,IACzDE,EAAwBisB,EAAMlyB,MAAAA,CAAO,CAAA,GAErCK,EAAW3H,AAAAA,CAAAA,EAAAA,EAAAA,WAAAA,AAAAA,IACXwN,EAAegsB,EAAM/rB,OAAAA,CACvB,IAIE8qB,AD94BU,CAAA,SACd5qB,CAAsB,CACtBC,CAA2C,EAE3C,IAAIJ,EAAe8qB,EAAmB3qB,GAEtC,GAAIC,EACF,IAAK,IAAI/L,KAAO+L,EAAoBxL,IAAAA,GAC7BoL,EAAajK,GAAAA,CAAI1B,IACpB+L,EAAoBC,MAAAA,CAAOhM,GAAKiM,OAAAA,CAAS/K,AAAAA,IACvCyK,EAAa5I,MAAAA,CAAO/C,EAAKkB,EAC3B,GAKN,OAAOyK,CACT,CAAA,EC83BQ7F,EAASoC,MAAAA,CACTwD,EAAsBhG,OAAAA,CAAU,KAAO+F,EAAuB/F,OAAAA,EAElE,CAACI,EAASoC,MAATpC,CAAgB,EAGfoF,EAAW5M,AAAAA,CAAAA,EAAAA,EAAAA,WAAAA,AAAAA,IACX4N,EAAkByrB,EAAM1xB,WAAAA,CAC1B,CAACkG,EAAUC,KACT,IAAMC,EAAkBoqB,EACtB,AAAoB,YAApB,OAAOtqB,EAA0BA,EAASR,GAAgBQ,EAE5DT,CAAAA,EAAsBhG,OAAAA,CAAU,CAAA,EAChCwF,EAAS,IAAMmB,EAAiBD,EAClC,EACA,CAAClB,EAAUS,EAAa,EAG1B,MAAO,CAACA,EAAcO,EAAgB,AACxC,CA2CA,SAASwtB,IACP,GAAI,AAAoB,aAApB,OAAO/2B,SACT,MAAM,AAAInI,MACR,gHAIN,CAMgBq+B,SAAAA,IACd,GAAI,CAAA,OAAEtsB,CAAAA,CAAQ,CAAG8sB,EAAqBp6B,EAAeuN,SAArD,EACI,CAAA,SAAE5K,CAAAA,CAAU,CAAG+1B,EAAMrwB,UAAAA,CAAW+wB,EAAAA,wBAAAA,EAChC5rB,EAAiBktB,AAAAA,CAAAA,EAAAA,EAAAA,iBAAAA,AAAAA,IAErB,OAAOhC,EAAM1xB,WAAAA,CACX,SAACtG,CAAM,CAAE+M,CAAO,EAAA,KAAA,IAAPA,GAAAA,CAAAA,EAAU,CAAA,CAAA,EACjBgtB,IAEA,GAAI,CAAA,OAAE53B,CAAM,CAAA,OAAED,CAAM,CAAA,QAAEJ,CAAO,CAAA,SAAEM,CAAQ,CAAA,KAAEC,CAAAA,CAAM,CAAGm1B,EAChDx3B,EACAiC,GAGF2K,EAAOrB,QAAAA,CAASwB,EAAQ5K,MAAAA,EAAUA,EAAQ,CACxCsF,mBAAoBsF,EAAQtF,kBAA5BA,CACArF,SAAAA,EACAC,KAAAA,EACAiI,WAAYyC,EAAQ7K,MAAAA,EAAWA,EAC/B8K,YAAaD,EAAQjL,OAAAA,EAAYA,EACjCyF,QAASwF,EAAQxF,OAAjBA,CACAhD,MAAOwI,EAAQxI,KAAfA,CACA0I,YAAaH,CACd,EACF,EACD,CAACF,EAAQ3K,EAAU6K,EAAe,CAEtC,CAKA,SAASmtB,EACP9sB,CAAkB,CAClBC,CAAsB,EAEtB,GAAI,CAAA,OAAER,CAAAA,CAAQ,CAAG8sB,EAAqBp6B,EAAe+N,gBAArD,EACI,CAAA,SAAEpL,CAAAA,CAAU,CAAG+1B,EAAMrwB,UAAAA,CAAW+wB,EAAAA,wBAAAA,EAEpC,OAAOV,EAAM1xB,WAAAA,CACX,SAACtG,CAAM,CAAE+M,CAAO,EAAA,KAAA,IAAPA,GAAAA,CAAAA,EAAU,CAAA,CAAA,EACjBgtB,IAEA,GAAI,CAAA,OAAE53B,CAAM,CAAA,OAAED,CAAM,CAAA,QAAEJ,CAAO,CAAA,SAAEM,CAAQ,CAAA,KAAEC,CAAAA,CAAM,CAAGm1B,EAChDx3B,EACAiC,EAGF,AACoB,OAAlBmL,GADFwsB,AAAAA,CAAAA,EAAAA,EAAAA,gBAAAA,AAAAA,EAAS,CAAA,GAIThtB,EAAOU,KAAAA,CAAMH,EAAYC,EAAgBL,EAAQ5K,MAAAA,EAAUA,EAAQ,CACjEsF,mBAAoBsF,EAAQtF,kBAA5BA,CACArF,SAAAA,EACAC,KAAAA,EACAiI,WAAYyC,EAAQ7K,MAAAA,EAAWA,EAC/B8K,YAAaD,EAAQjL,OAAAA,EAAYA,CAClC,EACF,EACD,CAAC8K,EAAQ3K,EAAUkL,EAAYC,EAAe,CAElD,CAIM,SAAUisB,EACdl3B,CAAe,CAAAoL,CAAA,EACsC,GAArD,CAAA,SAAElG,CAAAA,CAAiD,CAAA,AAAA,KAAA,IAAA,EAAA,CAAA,EAAEkG,EAEjD,CAAA,SAAEtL,CAAAA,CAAU,CAAG+1B,EAAMrwB,UAAAA,CAAW+wB,EAAAA,wBAAAA,EAChClrB,EAAewqB,EAAMrwB,UAAAA,CAAWuyB,EAAAA,mBAAAA,CACpC,CAAU1sB,GAAVosB,AAAAA,CAAAA,EAAAA,EAAAA,gBAAAA,AAAAA,EAAS,CAAA,GAET,GAAI,CAACnsB,EAAM,CAAGD,EAAaE,OAAAA,CAAQC,KAAAA,CAAM,IAGrCvF,EAAIsvB,EAAQz4B,CAAAA,EAAAA,AAAAA,CAAAA,EAAAA,EAAAA,eAAAA,AAAAA,EAAgBkD,GAAkB,IAAK,CAAEkF,SAAAA,CAAQ,IAO7DlB,EAAW3H,AAAAA,CAAAA,EAAAA,EAAAA,WAAAA,AAAAA,IACf,GAAI2D,AAAU,MAAVA,IAIFiG,EAAKG,MAAAA,CAASpC,EAASoC,MAAvBH,CACAA,EAAKI,IAAAA,CAAOrC,EAASqC,IAArBJ,CAKIqF,EAAMG,KAAAA,CAAMC,KAAAA,EAAO,CACrB,IAAIC,EAAS,IAAI5M,gBAAgBkH,EAAKG,MAAtC,EACAuF,EAAOC,MAAAA,CAAO,SACd3F,EAAKG,MAAAA,CAASuF,EAAOE,QAAAA,GAAU,IAAOF,EAAOE,QAAAA,GAAe,EAC7D,CAkBH,MAfK,CAAA,CAAC7L,GAAUA,AAAW,MAAXA,CAAW,GAAQsL,EAAMG,KAAAA,CAAMC,KAAAA,EAC7CzF,CAAAA,EAAKG,MAAAA,CAASH,EAAKG,MAAAA,CACfH,EAAKG,MAAAA,CAAOhB,OAAAA,CAAQ,MAAO,WAC3B,QAHN,EAUiB,MAAbtF,GACFmG,CAAAA,EAAKC,QAAAA,CACHD,AAAkB,MAAlBA,EAAKC,QAAAA,CAAmBpG,EAAWgM,AAAAA,CAAAA,EAAAA,EAAAA,SAAAA,AAAAA,EAAU,CAAChM,EAAUmG,EAAKC,QAALD,CAAc,CAAA,EAGnEhL,AAAAA,CAAAA,EAAAA,EAAAA,UAAAA,AAAAA,EAAWgL,EACpB,CAjTE9I,CADGA,EAAAA,GAAAA,CAAAA,EAKJ,CAAA,CAAA,GAJC,oBAAA,CAAA,uBACAA,EAAA,SAAA,CAAA,YACAA,EAAA,gBAAA,CAAA,mBACAA,EAAA,UAAA,CAAA,aAIAC,CADGA,EAAAA,GAAAA,CAAAA,EAGJ,CAAA,CAAA,GAFC,WAAA,CAAA,cACAA,EAAA,oBAAA,CAAA,uBAwTF,IAAI86B,EAAY,EAYAC,SAAAA,IAAU,IAAAnsB,EACxB,GAAI,CAAA,OAAEvB,CAAAA,CAAQ,CAAG8sB,EAAqBp6B,EAAe8O,UAArD,EAEIR,EAAQoqB,EAAMrwB,UAAAA,CAAWuyB,EAAAA,mBAAAA,CAC7B,CAAUtsB,GAAVgsB,AAAAA,CAAAA,EAAAA,EAAAA,gBAAAA,AAAAA,EAAS,CAAA,GAET,IAAIvrB,EAAO,AAA0C,MAA1CF,CAAAA,EAAGP,EAAMF,OAAO,CAACE,EAAMF,OAAAA,CAAQvN,MAAAA,CAAS,EAAC,AAAD,EAAE,KAAA,EAAvCgO,EAAyCP,KAAAA,CAAMrT,EAA7D,AACA,AACa,OAAX8T,GADFurB,AAAAA,CAAAA,EAAAA,EAAAA,gBAAAA,AAAAA,EAAS,CAAA,GAKT,GAAI,CAACzsB,EAAW,CAAG6qB,EAAM9xB,QAAAA,CAAS,IAAMoI,OAAO,EAAE+rB,IAC7C,CAAC9rB,EAAK,CAAGypB,EAAM9xB,QAAAA,CAAS,KAC1B,AAAUmI,GAAVurB,AAAAA,CAAAA,EAAAA,EAAAA,gBAAAA,AAAAA,EAAS,CAAA,GAtCO5B,EAAMhxB,UAAAA,CACtB,CAACgD,EAAO9C,KACN,IAAI+C,EAASgwB,EAqCU9sB,EAAYkB,GApCnC,OAAO2pB,EAAC/0B,aAAAA,CAAAk2B,EAAQzB,EAAA,CAAA,EAAK1tB,EAAK,CAAE9C,IAAKA,EAAK+C,OAAQA,CAAM,GACtD,KAqCE,CAACuE,EAAK,CAAGwpB,EAAM9xB,QAAAA,CAAS,IAAO8B,AAAAA,IACjC,AAAU4E,GAAVgtB,AAAAA,CAAAA,EAAAA,EAAAA,gBAAAA,AAAAA,EAAS,CAAA,GACT,AAAUvrB,GAAVurB,AAAAA,CAAAA,EAAAA,EAAAA,gBAAAA,AAAAA,EAAS,CAAA,GACThtB,EAAOU,KAAAA,CAAMH,EAAYkB,EAASrG,EACpC,GACIiC,EAASgwB,EAAiB9sB,EAAYkB,GAEtCI,EAAU7B,EAAO8B,UAAAA,CAAkBvB,GAEnCwB,EAAwBqpB,EAAM/rB,OAAAA,CAChC,IAAAyrB,EAAA,CACEnpB,KAAAA,EACAtE,OAAAA,EACAuE,KAAAA,CAAI,EACDC,GAEL,CAACA,EAASF,EAAMtE,EAAQuE,EAAK,EAgB/B,OAbAwpB,EAAMppB,SAAAA,CAAU,IAIP,KACL,GAAI,CAAChC,EAAQ,CACXiC,QAAQC,IAAAA,CAAI,qDACZ,MACD,CACDlC,EAAOmC,aAAAA,CAAc5B,EACtB,EACA,CAACP,EAAQO,EAAW,EAEhBwB,CACT,CAMgB4rB,SAAAA,IAEd,MAAO,IAAIh2B,AADCs1B,EAAmBt6B,EAAoByP,WAAnD,EACiBC,QAAAA,CAASC,MAAf3K,GAAwB,AACrC,CAEA,IAAMi2B,EAAiC,gCACnChR,EAA+C,CAAA,EAKnD,SAASgQ,EAAoBnqB,CAAA,EAMvB,GANwB,CAAA,OAC5BvE,CAAM,CAAA,WACNC,CAAAA,CAIE,CAAA,AAAA,KAAA,IAAA,EAAA,CAAA,EAAEsE,EACA,CAAA,OAAEzC,CAAAA,CAAQ,CAAG8sB,EAAqBp6B,EAAegQ,oBAArD,EACI,CAAA,sBAAEC,CAAqB,CAAA,mBAAE9H,CAAAA,CAAoB,CAAGoyB,EAClDt6B,EAAoB+P,oBADtB,EAGI,CAAA,SAAErN,CAAAA,CAAU,CAAG+1B,EAAMrwB,UAAAA,CAAW+wB,EAAAA,wBAAAA,EAChCvyB,EAAW3H,AAAAA,CAAAA,EAAAA,EAAAA,WAAAA,AAAAA,IACXkP,EAAUhP,AAAAA,CAAAA,EAAAA,EAAAA,UAAAA,AAAAA,IACV+K,EAAa7K,AAAAA,CAAAA,EAAAA,EAAAA,aAAAA,AAAAA,IAGjBo5B,EAAMppB,SAAAA,CAAU,KACd1U,OAAO4J,OAAAA,CAAQ0L,iBAAAA,CAAoB,SAC5B,KACLtV,OAAO4J,OAAAA,CAAQ0L,iBAAAA,CAAoB,MACpC,GACA,EAAE,EAGLirB,AA2HF,SACE/qB,CAA6C,CAC7C3C,CAA+B,EAE/B,GAAI,CAAA,QAAE4C,CAAAA,CAAS,CAAc,CAAA,EAC7BqoB,EAAMppB,SAAAA,CAAU,KACd,IAAIlL,EAAOiM,AAAW,MAAXA,EAAkB,CAAEA,QAAAA,CAAS,EAAGtM,KAAAA,EAE3C,OADAnJ,OAAO0V,gBAAAA,CAAiB,WAAYF,EAAUhM,GACvC,KACLxJ,OAAO2V,mBAAAA,CAAoB,WAAYH,EAAUhM,EAClD,CACH,EAAG,CAACgM,EAAUC,EAAQ,CACxB,EAtIIqoB,EAAM1xB,WAAAA,CAAY,KACS,SAArBmD,EAAWlF,KAAAA,EAEbilB,CAAAA,CAAoB,CADT1e,AAAAA,CAAAA,EAASA,EAAO3E,EAAUuH,GAAW,IAAA,GAASvH,EAAS9F,GAAlE,CACyB,CAAGnG,OAAO4V,OAAnC0Z,AAAAA,EAEFzZ,eAAeC,OAAAA,CACbjF,GAAcyvB,EACdvqB,KAAKC,SAAAA,CAAUsZ,IAEjBtvB,OAAO4J,OAAAA,CAAQ0L,iBAAAA,CAAoB,MACrC,EAAG,CAACzE,EAAYD,EAAQrB,EAAWlF,KAAXkF,CAAkBtD,EAAUuH,EAAQ,GAItC,aAApB,OAAO1K,WAETg1B,EAAMxxB,eAAAA,CAAgB,KACpB,GAAI,CACF,IAAI2J,EAAmBJ,eAAeK,OAAAA,CACpCrF,GAAcyvB,GAEZrqB,GACFqZ,CAAAA,EAAuBvZ,KAAKI,KAAAA,CAAMF,EADpC,CAGD,CAAC,MAAO9W,EAAG,CACV,CAEJ,EAAG,CAAC0R,EAAW,EAIfitB,EAAMxxB,eAAAA,CAAgB,KACpB,IAAI8J,EACFxF,GAAU7I,AAAa,MAAbA,EACN,CAACkE,EAAUuH,IACT5C,EACE4sB,EAAA,CAAA,EAEKvxB,EAAQ,CACXkC,SACE5F,AAAAA,CAAAA,EAAAA,EAAAA,aAAAA,AAAAA,EAAc0D,EAASkC,QAAAA,CAAUpG,IACjCkE,EAASkC,QAFXA,AAIFqF,GAAAA,GAEJ5C,EACFyF,EAA2B3D,AAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAQ4D,uBAAAA,CACrCgZ,EACA,IAAMtvB,OAAO4V,OAAAA,CACbQ,GAEF,MAAO,IAAMC,GAA4BA,GAC1C,EAAE,CAAC3D,EAAQ3K,EAAU6I,EAAO,EAI7BktB,EAAMxxB,eAAAA,CAAgB,KAEpB,GAAI+I,AAA0B,CAAA,IAA1BA,GAKJ,GAAI,AAAiC,UAAjC,OAAOA,EAAoC,CAC7CrV,OAAOuW,QAAAA,CAAS,EAAGlB,GACnB,MACD,CAGD,GAAIpJ,EAASqC,IAAAA,CAAM,CACjB,IAAIkI,EAAK1N,SAAS2N,cAAAA,CAChBC,mBAAmBzK,EAASqC,IAAAA,CAAKmF,KAAAA,CAAM,KAEzC,GAAI+C,EAAI,CACNA,EAAGG,cAAHH,GACA,MACD,CACF,CAG0B,CAAA,IAAvBjJ,GAKJvN,OAAOuW,QAAAA,CAAS,EAAG,GACpB,EAAE,CAACtK,EAAUoJ,EAAuB9H,EAAmB,EAE5D,CAYgB,SAAAizB,EACdhrB,CAA2C,CAC3C3C,CAA+B,EAE/B,GAAI,CAAA,QAAE4C,CAAAA,CAAS,CAAG5C,GAAW,CAAA,EAC7BirB,EAAMppB,SAAAA,CAAU,KACd,IAAIlL,EAAOiM,AAAW,MAAXA,EAAkB,CAAEA,QAAAA,CAAS,EAAGtM,KAAAA,EAE3C,OADAnJ,OAAO0V,gBAAAA,CAAiB,eAAgBF,EAAUhM,GAC3C,KACLxJ,OAAO2V,mBAAAA,CAAoB,eAAgBH,EAAUhM,EACtD,CACH,EAAG,CAACgM,EAAUC,EAAQ,CACxB,CAgCA,SAASgrB,EAAS7pB,CAAA,EAAsD,GAArD,CAAA,KAAEC,CAAI,CAAA,QAAExL,CAAAA,CAA6C,CAAAuL,EAClEE,EAAU4pB,AAAAA,CAAAA,EAAAA,EAAAA,mBAAAA,AAAAA,EAAW7pB,GAEzBinB,EAAMppB,SAAAA,CAAU,KACQ,YAAlBoC,EAAQzM,KAAAA,EAAwBwM,GAClCC,EAAQC,KADV,EAGF,EAAG,CAACD,EAASD,EAAK,EAElBinB,EAAMppB,SAAAA,CAAU,KACQ,YAAlBoC,EAAQzM,KAAAA,GACIrK,OAAOgX,OAAAA,CAAQ3L,GAE3B4L,WAAWH,EAAQI,OAAAA,CAAS,GAE5BJ,EAAQC,KAARD,GAGN,EAAG,CAACA,EAASzL,EAAQ,CACvB,C,G,E,Q,C,Q,S,C,C,C,E,E,E,O,C,2B,I,G,E,E,O,C,gC,I,G,E,E,O,C,2B,I,G,E,E,O,C,yB,I,G,E,E,O,C,sB,I,G,E,E,O,C,U,I,G,E,E,O,C,qB,I,G,E,E,O,C,kB,I,G,E,E,O,C,c,I,G,E,E,O,C,oB,I,G,E,E,O,C,W,I,G,E,E,O,C,c,I,G,E,E,O,C,mB,I,G,E,E,O,C,Y,I,G,E,E,O,C,Y,I,G,E,E,O,C,Y,I,G,E,E,O,C,gB,I,G,E,E,O,C,oB,I,G,E,E,O,C,gB,I,G,E,E,O,C,iB,I,G,E,E,O,C,a,I,G,E,E,O,C,gB,I,G,E,E,O,C,qB,I,G,E,E,O,C,gB,I,G,E,E,O,C,gB,I,G,E,E,O,C,gB,I,G,E,E,O,C,sB,I,G,E,E,O,C,iB,I,I,E,E,O,C,S,I,I,E,E,O,C,e,I,I,E,E,O,C,W,I,I,E,E,O,C,S,I,I,E,E,O,C,Q,I,I,E,E,O,C,S,I,I,E,E,O,C,2B,I,I,E,E,O,C,Q,I,I,E,E,O,C,gB,I,I,E,E,O,C,4B,I,I,E,E,O,C,qB,I,I,E,E,O,C,2B,I,I,E,E,O,C,uB,I,A,E,S,oB,E,E,E,O,C,iB,I,A,E,S,M,E,E,E,O,C,uB,I,A,E,S,oB,E,E,E,O,C,Y,I,A,E,S,S,E,E,E,O,C,c,I,A,E,S,W,E,E,E,O,C,Y,I,A,E,S,S,E,IG7tBKjG,EAMAC,EChQAqU,ED0PAtU,EAMAC,EChQAqU,E,E,E,S,E,E,S,S,I,M,A,C,E,O,M,C,O,M,C,I,G,S,C,E,I,I,E,E,E,U,M,C,I,C,I,E,S,C,E,C,I,I,K,E,O,S,C,c,C,I,C,E,I,C,C,C,E,C,C,C,E,A,C,C,O,C,C,E,K,C,I,C,U,CFvaE,IAAM+lB,EACX3B,EAAM/jB,aAAAA,CAA8C,MAKzC+kB,EAAyBhB,EAAM/jB,aAAAA,CAE1C,MAKW4mB,EAAe7C,EAAM/jB,aAAAA,CAAqC,MAoC1DykB,EAAoBV,EAAM/jB,aAAAA,CACrC,MAYW6mB,EAAkB9C,EAAM/jB,aAAAA,CACnC,MAaWimB,EAAelC,EAAM/jB,aAAAA,CAAkC,CAClEE,OAAQ,KACRzG,QAAS,EAAE,CACX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vU,KAAAA,CACjB,GAGKwZ,CACT,CAEO,SAAS1f,GACdsG,CAAqB,CACrBC,CAMC,EAED,MAAOC,AAAAA,CAAAA,EAAAA,EAAAA,YAAAA,AAAAA,EAAa,CAClB1B,SAAUyB,AAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAMzB,QAAhBA,CACA2B,OAAM8zB,EAAA,CAAA,EACDh0B,AAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAME,MAAAA,CAAM,CACfC,mBAAoB,CAAA,CACrB,GACDC,QAASgX,AAAAA,CAAAA,EAAAA,EAAAA,mBAAAA,AAAAA,EAAoB,CAC3BF,eAAgBlX,AAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAMkX,cAAtBA,CACAC,aAAcnX,AAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAMmX,YAApBA,AACF,GACA7W,cAAeN,AAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAMM,aAArBA,CACAP,OAAAA,EACAS,mBAAAA,EACF,GAAGE,UAAH,EACF,C,G,E,Q,C,Q,S,C,C,C,MEjRY7H,ECGAygB,EDHAzgB,ECGAygB,E,S,I,M,A,C,E,O,M,C,O,M,C,I,G,S,C,E,I,I,E,E,E,U,M,C,I,C,I,E,S,C,E,C,I,I,K,E,O,S,C,c,C,I,C,E,I,C,C,C,E,C,C,C,E,A,C,C,O,C,C,E,K,C,I,C,U,C,E,E,O,C,S,I,G,E,E,O,C,sB,I,G,E,E,O,C,a,I,G,E,E,O,C,Y,I,G,E,E,O,C,uB,I,G,E,E,O,C,oB,I,G,E,E,O,C,mB,I,G,E,E,O,C,c,I,G,E,E,O,C,gB,I,G,E,E,O,C,Y,I,G,E,E,O,C,Y,I,G,E,E,O,C,e,I,G,E,E,O,C,c,I,G,E,E,O,C,oC,I,G,E,E,O,C,Y,I,G,E,E,O,C,O,I,G,E,E,O,C,uB,I,G,E,E,O,C,Q,I,G,E,E,O,C,W,I,G,E,E,O,C,gB,I,G,E,E,O,C,uB,I,G,E,E,O,C,e,I,G,E,E,O,C,e,I,GDKVzgB,CARUA,EAAAA,GAAAA,CAAAA,EAsBX,CAAA,CAAA,GAdC,GAAA,CAAA,MAOAA,EAAA,IAAA,CAAA,OAMAA,EAAA,OAAA,CAAA,UAmKF,IAAMsgC,EAAoB,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","sources":["<anon>","node_modules/react-router-dom/dist/index.js","node_modules/react-router-dom/dom.ts","node_modules/react-router-dom/index.tsx","node_modules/react-router/dist/index.js","node_modules/react-router/lib/context.ts","node_modules/react-router/lib/hooks.tsx","node_modules/react-router/lib/components.tsx","node_modules/react-router/index.ts","node_modules/@remix-run/router/dist/router.js","node_modules/@remix-run/router/history.ts","node_modules/@remix-run/router/utils.ts","node_modules/@remix-run/router/router.ts"],"sourcesContent":["function $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire344c\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire344c\"] = parcelRequire;\n}\nparcelRequire.register(\"lgECU\", function(module, exports) {\n\n$parcel$export(module.exports, \"createSearchParams\", () => $f7ba9b356b6d67df$export$a2e4e2dcc7b1f22f);\n$parcel$export(module.exports, \"createBrowserRouter\", () => $f7ba9b356b6d67df$export$1f3f55432a00e06d);\n$parcel$export(module.exports, \"createHashRouter\", () => $f7ba9b356b6d67df$export$1ba7ed8a3a7b3765);\n$parcel$export(module.exports, \"BrowserRouter\", () => $f7ba9b356b6d67df$export$9ba4e89fdfa1fc54);\n$parcel$export(module.exports, \"HashRouter\", () => $f7ba9b356b6d67df$export$7221d69dcfc8e36b);\n$parcel$export(module.exports, \"unstable_HistoryRouter\", () => $f7ba9b356b6d67df$export$eefb0c834599897e);\n$parcel$export(module.exports, \"Link\", () => $f7ba9b356b6d67df$export$a6c7ac8248d6e38a);\n$parcel$export(module.exports, \"useLinkClickHandler\", () => $f7ba9b356b6d67df$export$67621102c14d847);\n$parcel$export(module.exports, \"NavLink\", () => $f7ba9b356b6d67df$export$b0d92dbee9b5b60d);\n$parcel$export(module.exports, \"Form\", () => $f7ba9b356b6d67df$export$a7fed597f4b8afd8);\n$parcel$export(module.exports, \"useSubmit\", () => $f7ba9b356b6d67df$export$47c85c6e3a081d3);\n$parcel$export(module.exports, \"useFormAction\", () => $f7ba9b356b6d67df$export$89a6bd6db0d97c56);\n$parcel$export(module.exports, \"ScrollRestoration\", () => $f7ba9b356b6d67df$export$11aac1aab828f1fa);\n$parcel$export(module.exports, \"UNSAFE_useScrollRestoration\", () => $f7ba9b356b6d67df$export$25057cfe5591e3e9);\n$parcel$export(module.exports, \"useSearchParams\", () => $f7ba9b356b6d67df$export$f1a78c17382fe22a);\n$parcel$export(module.exports, \"useFetcher\", () => $f7ba9b356b6d67df$export$5b0d2d9a9921565a);\n$parcel$export(module.exports, \"useFetchers\", () => $f7ba9b356b6d67df$export$fa996778a3a31087);\n$parcel$export(module.exports, \"useBeforeUnload\", () => $f7ba9b356b6d67df$export$c0a586b329cae57d);\n$parcel$export(module.exports, \"unstable_usePrompt\", () => $f7ba9b356b6d67df$export$39f4eb3dbd812741);\n$parcel$export(module.exports, \"AbortedDeferredError\", () => (parcelRequire(\"bZ2h6\")).AbortedDeferredError);\n$parcel$export(module.exports, \"Await\", () => (parcelRequire(\"8wGzW\")).Await);\n$parcel$export(module.exports, \"MemoryRouter\", () => (parcelRequire(\"8wGzW\")).MemoryRouter);\n$parcel$export(module.exports, \"Navigate\", () => (parcelRequire(\"8wGzW\")).Navigate);\n$parcel$export(module.exports, \"NavigationType\", () => (parcelRequire(\"bZ2h6\")).Action);\n$parcel$export(module.exports, \"Outlet\", () => (parcelRequire(\"8wGzW\")).Outlet);\n$parcel$export(module.exports, \"Route\", () => (parcelRequire(\"8wGzW\")).Route);\n$parcel$export(module.exports, \"Router\", () => (parcelRequire(\"8wGzW\")).Router);\n$parcel$export(module.exports, \"RouterProvider\", () => (parcelRequire(\"8wGzW\")).RouterProvider);\n$parcel$export(module.exports, \"Routes\", () => (parcelRequire(\"8wGzW\")).Routes);\n$parcel$export(module.exports, \"UNSAFE_DataRouterContext\", () => (parcelRequire(\"8wGzW\")).UNSAFE_DataRouterContext);\n$parcel$export(module.exports, \"UNSAFE_DataRouterStateContext\", () => (parcelRequire(\"8wGzW\")).UNSAFE_DataRouterStateContext);\n$parcel$export(module.exports, \"UNSAFE_LocationContext\", () => (parcelRequire(\"8wGzW\")).UNSAFE_LocationContext);\n$parcel$export(module.exports, \"UNSAFE_NavigationContext\", () => (parcelRequire(\"8wGzW\")).UNSAFE_NavigationContext);\n$parcel$export(module.exports, \"UNSAFE_RouteContext\", () => (parcelRequire(\"8wGzW\")).UNSAFE_RouteContext);\n$parcel$export(module.exports, \"UNSAFE_useRouteId\", () => (parcelRequire(\"8wGzW\")).UNSAFE_useRouteId);\n$parcel$export(module.exports, \"createMemoryRouter\", () => (parcelRequire(\"8wGzW\")).createMemoryRouter);\n$parcel$export(module.exports, \"createPath\", () => (parcelRequire(\"bZ2h6\")).createPath);\n$parcel$export(module.exports, \"createRoutesFromChildren\", () => (parcelRequire(\"8wGzW\")).createRoutesFromChildren);\n$parcel$export(module.exports, \"createRoutesFromElements\", () => (parcelRequire(\"8wGzW\")).createRoutesFromElements);\n$parcel$export(module.exports, \"defer\", () => (parcelRequire(\"bZ2h6\")).defer);\n$parcel$export(module.exports, \"generatePath\", () => (parcelRequire(\"bZ2h6\")).generatePath);\n$parcel$export(module.exports, \"isRouteErrorResponse\", () => (parcelRequire(\"bZ2h6\")).isRouteErrorResponse);\n$parcel$export(module.exports, \"json\", () => (parcelRequire(\"bZ2h6\")).json);\n$parcel$export(module.exports, \"matchPath\", () => (parcelRequire(\"bZ2h6\")).matchPath);\n$parcel$export(module.exports, \"matchRoutes\", () => (parcelRequire(\"bZ2h6\")).matchRoutes);\n$parcel$export(module.exports, \"parsePath\", () => (parcelRequire(\"bZ2h6\")).parsePath);\n$parcel$export(module.exports, \"redirect\", () => (parcelRequire(\"bZ2h6\")).redirect);\n$parcel$export(module.exports, \"renderMatches\", () => (parcelRequire(\"8wGzW\")).renderMatches);\n$parcel$export(module.exports, \"resolvePath\", () => (parcelRequire(\"bZ2h6\")).resolvePath);\n$parcel$export(module.exports, \"unstable_useBlocker\", () => (parcelRequire(\"8wGzW\")).unstable_useBlocker);\n$parcel$export(module.exports, \"useActionData\", () => (parcelRequire(\"8wGzW\")).useActionData);\n$parcel$export(module.exports, \"useAsyncError\", () => (parcelRequire(\"8wGzW\")).useAsyncError);\n$parcel$export(module.exports, \"useAsyncValue\", () => (parcelRequire(\"8wGzW\")).useAsyncValue);\n$parcel$export(module.exports, \"useHref\", () => (parcelRequire(\"8wGzW\")).useHref);\n$parcel$export(module.exports, \"useInRouterContext\", () => (parcelRequire(\"8wGzW\")).useInRouterContext);\n$parcel$export(module.exports, \"useLoaderData\", () => (parcelRequire(\"8wGzW\")).useLoaderData);\n$parcel$export(module.exports, \"useLocation\", () => (parcelRequire(\"8wGzW\")).useLocation);\n$parcel$export(module.exports, \"useMatch\", () => (parcelRequire(\"8wGzW\")).useMatch);\n$parcel$export(module.exports, \"useMatches\", () => (parcelRequire(\"8wGzW\")).useMatches);\n$parcel$export(module.exports, \"useNavigate\", () => (parcelRequire(\"8wGzW\")).useNavigate);\n$parcel$export(module.exports, \"useNavigation\", () => (parcelRequire(\"8wGzW\")).useNavigation);\n$parcel$export(module.exports, \"useNavigationType\", () => (parcelRequire(\"8wGzW\")).useNavigationType);\n$parcel$export(module.exports, \"useOutlet\", () => (parcelRequire(\"8wGzW\")).useOutlet);\n$parcel$export(module.exports, \"useOutletContext\", () => (parcelRequire(\"8wGzW\")).useOutletContext);\n$parcel$export(module.exports, \"useParams\", () => (parcelRequire(\"8wGzW\")).useParams);\n$parcel$export(module.exports, \"useResolvedPath\", () => (parcelRequire(\"8wGzW\")).useResolvedPath);\n$parcel$export(module.exports, \"useRevalidator\", () => (parcelRequire(\"8wGzW\")).useRevalidator);\n$parcel$export(module.exports, \"useRouteError\", () => (parcelRequire(\"8wGzW\")).useRouteError);\n$parcel$export(module.exports, \"useRouteLoaderData\", () => (parcelRequire(\"8wGzW\")).useRouteLoaderData);\n$parcel$export(module.exports, \"useRoutes\", () => (parcelRequire(\"8wGzW\")).useRoutes);\n/**\n * React Router DOM v6.14.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \nvar $5kUFm = parcelRequire(\"5kUFm\");\n\nvar $8wGzW = parcelRequire(\"8wGzW\");\nvar $bZ2h6 = parcelRequire(\"bZ2h6\");\nvar $bZ2h6 = parcelRequire(\"bZ2h6\");\n\nvar $bZ2h6 = parcelRequire(\"bZ2h6\");\nfunction $f7ba9b356b6d67df$var$_extends() {\n    $f7ba9b356b6d67df$var$_extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];\n        }\n        return target;\n    };\n    return $f7ba9b356b6d67df$var$_extends.apply(this, arguments);\n}\nfunction $f7ba9b356b6d67df$var$_objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nconst $f7ba9b356b6d67df$var$defaultMethod = \"get\";\nconst $f7ba9b356b6d67df$var$defaultEncType = \"application/x-www-form-urlencoded\";\nfunction $f7ba9b356b6d67df$var$isHtmlElement(object) {\n    return object != null && typeof object.tagName === \"string\";\n}\nfunction $f7ba9b356b6d67df$var$isButtonElement(object) {\n    return $f7ba9b356b6d67df$var$isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction $f7ba9b356b6d67df$var$isFormElement(object) {\n    return $f7ba9b356b6d67df$var$isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction $f7ba9b356b6d67df$var$isInputElement(object) {\n    return $f7ba9b356b6d67df$var$isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction $f7ba9b356b6d67df$var$isModifiedEvent(event) {\n    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction $f7ba9b356b6d67df$var$shouldProcessLinkClick(event, target) {\n    return event.button === 0 && // Ignore everything but left clicks\n    (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n    !$f7ba9b356b6d67df$var$isModifiedEvent(event) // Ignore clicks with modifier keys\n    ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */ function $f7ba9b356b6d67df$export$a2e4e2dcc7b1f22f(init) {\n    if (init === void 0) init = \"\";\n    return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key)=>{\n        let value = init[key];\n        return memo.concat(Array.isArray(value) ? value.map((v)=>[\n                key,\n                v\n            ]) : [\n            [\n                key,\n                value\n            ]\n        ]);\n    }, []));\n}\nfunction $f7ba9b356b6d67df$var$getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n    let searchParams = $f7ba9b356b6d67df$export$a2e4e2dcc7b1f22f(locationSearch);\n    if (defaultSearchParams) {\n        for (let key of defaultSearchParams.keys())if (!searchParams.has(key)) defaultSearchParams.getAll(key).forEach((value)=>{\n            searchParams.append(key, value);\n        });\n    }\n    return searchParams;\n}\n// One-time check for submitter support\nlet $f7ba9b356b6d67df$var$_formDataSupportsSubmitter = null;\nfunction $f7ba9b356b6d67df$var$isFormDataSubmitterSupported() {\n    if ($f7ba9b356b6d67df$var$_formDataSupportsSubmitter === null) try {\n        new FormData(document.createElement(\"form\"), // @ts-expect-error if FormData supports the submitter parameter, this will throw\n        0);\n        $f7ba9b356b6d67df$var$_formDataSupportsSubmitter = false;\n    } catch (e) {\n        $f7ba9b356b6d67df$var$_formDataSupportsSubmitter = true;\n    }\n    return $f7ba9b356b6d67df$var$_formDataSupportsSubmitter;\n}\nconst $f7ba9b356b6d67df$var$supportedFormEncTypes = new Set([\n    \"application/x-www-form-urlencoded\",\n    \"multipart/form-data\",\n    \"text/plain\"\n]);\nfunction $f7ba9b356b6d67df$var$getFormEncType(encType) {\n    if (encType != null && !$f7ba9b356b6d67df$var$supportedFormEncTypes.has(encType)) return null;\n    return encType;\n}\nfunction $f7ba9b356b6d67df$var$getFormSubmissionInfo(target, basename) {\n    let method;\n    let action;\n    let encType;\n    let formData;\n    let body;\n    if ($f7ba9b356b6d67df$var$isFormElement(target)) {\n        // When grabbing the action from the element, it will have had the basename\n        // prefixed to ensure non-JS scenarios work, so strip it since we'll\n        // re-prefix in the router\n        let attr = target.getAttribute(\"action\");\n        action = attr ? (0, $bZ2h6.stripBasename)(attr, basename) : null;\n        method = target.getAttribute(\"method\") || $f7ba9b356b6d67df$var$defaultMethod;\n        encType = $f7ba9b356b6d67df$var$getFormEncType(target.getAttribute(\"enctype\")) || $f7ba9b356b6d67df$var$defaultEncType;\n        formData = new FormData(target);\n    } else if ($f7ba9b356b6d67df$var$isButtonElement(target) || $f7ba9b356b6d67df$var$isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n        let form = target.form;\n        if (form == null) throw new Error('Cannot submit a <button> or <input type=\"submit\"> without a <form>');\n        // <button>/<input type=\"submit\"> may override attributes of <form>\n        // When grabbing the action from the element, it will have had the basename\n        // prefixed to ensure non-JS scenarios work, so strip it since we'll\n        // re-prefix in the router\n        let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n        action = attr ? (0, $bZ2h6.stripBasename)(attr, basename) : null;\n        method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || $f7ba9b356b6d67df$var$defaultMethod;\n        encType = $f7ba9b356b6d67df$var$getFormEncType(target.getAttribute(\"formenctype\")) || $f7ba9b356b6d67df$var$getFormEncType(form.getAttribute(\"enctype\")) || $f7ba9b356b6d67df$var$defaultEncType;\n        // Build a FormData object populated from a form and submitter\n        formData = new FormData(form, target);\n        // If this browser doesn't support the `FormData(el, submitter)` format,\n        // then tack on the submitter value at the end.  This is a lightweight\n        // solution that is not 100% spec compliant.  For complete support in older\n        // browsers, consider using the `formdata-submitter-polyfill` package\n        if (!$f7ba9b356b6d67df$var$isFormDataSubmitterSupported()) {\n            let { name: name, type: type, value: value } = target;\n            if (type === \"image\") {\n                let prefix = name ? name + \".\" : \"\";\n                formData.append(prefix + \"x\", \"0\");\n                formData.append(prefix + \"y\", \"0\");\n            } else if (name) formData.append(name, value);\n        }\n    } else if ($f7ba9b356b6d67df$var$isHtmlElement(target)) throw new Error('Cannot submit element that is not <form>, <button>, or <input type=\"submit|image\">');\n    else {\n        method = $f7ba9b356b6d67df$var$defaultMethod;\n        action = null;\n        encType = $f7ba9b356b6d67df$var$defaultEncType;\n        body = target;\n    }\n    // Send body for <Form encType=\"text/plain\" so we encode it into text\n    if (formData && encType === \"text/plain\") {\n        body = formData;\n        formData = undefined;\n    }\n    return {\n        action: action,\n        method: method.toLowerCase(),\n        encType: encType,\n        formData: formData,\n        body: body\n    };\n}\nconst $f7ba9b356b6d67df$var$_excluded = [\n    \"onClick\",\n    \"relative\",\n    \"reloadDocument\",\n    \"replace\",\n    \"state\",\n    \"target\",\n    \"to\",\n    \"preventScrollReset\"\n], $f7ba9b356b6d67df$var$_excluded2 = [\n    \"aria-current\",\n    \"caseSensitive\",\n    \"className\",\n    \"end\",\n    \"style\",\n    \"to\",\n    \"children\"\n], $f7ba9b356b6d67df$var$_excluded3 = [\n    \"reloadDocument\",\n    \"replace\",\n    \"state\",\n    \"method\",\n    \"action\",\n    \"onSubmit\",\n    \"submit\",\n    \"relative\",\n    \"preventScrollReset\"\n];\nfunction $f7ba9b356b6d67df$export$1f3f55432a00e06d(routes, opts) {\n    return (0, $bZ2h6.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: $f7ba9b356b6d67df$var$_extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0, $bZ2h6.createBrowserHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || $f7ba9b356b6d67df$var$parseHydrationData(),\n        routes: routes,\n        mapRouteProperties: (0, $8wGzW.UNSAFE_mapRouteProperties)\n    }).initialize();\n}\nfunction $f7ba9b356b6d67df$export$1ba7ed8a3a7b3765(routes, opts) {\n    return (0, $bZ2h6.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: $f7ba9b356b6d67df$var$_extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0, $bZ2h6.createHashHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || $f7ba9b356b6d67df$var$parseHydrationData(),\n        routes: routes,\n        mapRouteProperties: (0, $8wGzW.UNSAFE_mapRouteProperties)\n    }).initialize();\n}\nfunction $f7ba9b356b6d67df$var$parseHydrationData() {\n    var _window;\n    let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n    if (state && state.errors) state = $f7ba9b356b6d67df$var$_extends({}, state, {\n        errors: $f7ba9b356b6d67df$var$deserializeErrors(state.errors)\n    });\n    return state;\n}\nfunction $f7ba9b356b6d67df$var$deserializeErrors(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        // Hey you!  If you change this, please change the corresponding logic in\n        // serializeErrors in react-router-dom/server.tsx :)\n        if (val && val.__type === \"RouteErrorResponse\") serialized[key] = new (0, $bZ2h6.ErrorResponse)(val.status, val.statusText, val.data, val.internal === true);\n        else if (val && val.__type === \"Error\") {\n            // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n            if (val.__subType) {\n                let ErrorConstructor = window[val.__subType];\n                if (typeof ErrorConstructor === \"function\") try {\n                    // @ts-expect-error\n                    let error = new ErrorConstructor(val.message);\n                    // Wipe away the client-side stack trace.  Nothing to fill it in with\n                    // because we don't serialize SSR stack traces for security reasons\n                    error.stack = \"\";\n                    serialized[key] = error;\n                } catch (e) {\n                // no-op - fall through and create a normal Error\n                }\n            }\n            if (serialized[key] == null) {\n                let error = new Error(val.message);\n                // Wipe away the client-side stack trace.  Nothing to fill it in with\n                // because we don't serialize SSR stack traces for security reasons\n                error.stack = \"\";\n                serialized[key] = error;\n            }\n        } else serialized[key] = val;\n    }\n    return serialized;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/ const $f7ba9b356b6d67df$var$START_TRANSITION = \"startTransition\";\nconst $f7ba9b356b6d67df$var$startTransitionImpl = $5kUFm[$f7ba9b356b6d67df$var$START_TRANSITION];\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */ function $f7ba9b356b6d67df$export$9ba4e89fdfa1fc54(_ref) {\n    let { basename: basename, children: children, future: future, window: window1 } = _ref;\n    let historyRef = $5kUFm.useRef();\n    if (historyRef.current == null) historyRef.current = (0, $bZ2h6.createBrowserHistory)({\n        window: window1,\n        v5Compat: true\n    });\n    let history = historyRef.current;\n    let [state, setStateImpl] = $5kUFm.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition: v7_startTransition } = future || {};\n    let setState = $5kUFm.useCallback((newState)=>{\n        v7_startTransition && $f7ba9b356b6d67df$var$startTransitionImpl ? $f7ba9b356b6d67df$var$startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    $5kUFm.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ $5kUFm.createElement((0, $8wGzW.Router), {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */ function $f7ba9b356b6d67df$export$7221d69dcfc8e36b(_ref2) {\n    let { basename: basename, children: children, future: future, window: window1 } = _ref2;\n    let historyRef = $5kUFm.useRef();\n    if (historyRef.current == null) historyRef.current = (0, $bZ2h6.createHashHistory)({\n        window: window1,\n        v5Compat: true\n    });\n    let history = historyRef.current;\n    let [state, setStateImpl] = $5kUFm.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition: v7_startTransition } = future || {};\n    let setState = $5kUFm.useCallback((newState)=>{\n        v7_startTransition && $f7ba9b356b6d67df$var$startTransitionImpl ? $f7ba9b356b6d67df$var$startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    $5kUFm.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ $5kUFm.createElement((0, $8wGzW.Router), {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */ function $f7ba9b356b6d67df$export$eefb0c834599897e(_ref3) {\n    let { basename: basename, children: children, future: future, history: history } = _ref3;\n    let [state, setStateImpl] = $5kUFm.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition: v7_startTransition } = future || {};\n    let setState = $5kUFm.useCallback((newState)=>{\n        v7_startTransition && $f7ba9b356b6d67df$var$startTransitionImpl ? $f7ba9b356b6d67df$var$startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    $5kUFm.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ $5kUFm.createElement((0, $8wGzW.Router), {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nconst $f7ba9b356b6d67df$var$isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\nconst $f7ba9b356b6d67df$var$ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n/**\n * The public API for rendering a history-aware <a>.\n */ const $f7ba9b356b6d67df$export$a6c7ac8248d6e38a = /*#__PURE__*/ $5kUFm.forwardRef(function LinkWithRef(_ref4, ref) {\n    let { onClick: onClick, relative: relative, reloadDocument: reloadDocument, replace: replace, state: state, target: target, to: to, preventScrollReset: preventScrollReset } = _ref4, rest = $f7ba9b356b6d67df$var$_objectWithoutPropertiesLoose(_ref4, $f7ba9b356b6d67df$var$_excluded);\n    let { basename: basename } = $5kUFm.useContext((0, $8wGzW.UNSAFE_NavigationContext));\n    // Rendered into <a href> for absolute URLs\n    let absoluteHref;\n    let isExternal = false;\n    if (typeof to === \"string\" && $f7ba9b356b6d67df$var$ABSOLUTE_URL_REGEX.test(to)) {\n        // Render the absolute href server- and client-side\n        absoluteHref = to;\n        // Only check for external origins client-side\n        if ($f7ba9b356b6d67df$var$isBrowser) try {\n            let currentUrl = new URL(window.location.href);\n            let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n            let path = (0, $bZ2h6.stripBasename)(targetUrl.pathname, basename);\n            if (targetUrl.origin === currentUrl.origin && path != null) // Strip the protocol/origin/basename for same-origin absolute URLs\n            to = path + targetUrl.search + targetUrl.hash;\n            else isExternal = true;\n        } catch (e) {}\n    }\n    // Rendered into <a href> for relative URLs\n    let href = (0, $8wGzW.useHref)(to, {\n        relative: relative\n    });\n    let internalOnClick = $f7ba9b356b6d67df$export$67621102c14d847(to, {\n        replace: replace,\n        state: state,\n        target: target,\n        preventScrollReset: preventScrollReset,\n        relative: relative\n    });\n    function handleClick(event) {\n        if (onClick) onClick(event);\n        if (!event.defaultPrevented) internalOnClick(event);\n    }\n    return(/*#__PURE__*/ // eslint-disable-next-line jsx-a11y/anchor-has-content\n    $5kUFm.createElement(\"a\", $f7ba9b356b6d67df$var$_extends({}, rest, {\n        href: absoluteHref || href,\n        onClick: isExternal || reloadDocument ? onClick : handleClick,\n        ref: ref,\n        target: target\n    })));\n});\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */ const $f7ba9b356b6d67df$export$b0d92dbee9b5b60d = /*#__PURE__*/ $5kUFm.forwardRef(function NavLinkWithRef(_ref5, ref) {\n    let { \"aria-current\": ariaCurrentProp = \"page\", caseSensitive: caseSensitive = false, className: classNameProp = \"\", end: end = false, style: styleProp, to: to, children: children } = _ref5, rest = $f7ba9b356b6d67df$var$_objectWithoutPropertiesLoose(_ref5, $f7ba9b356b6d67df$var$_excluded2);\n    let path = (0, $8wGzW.useResolvedPath)(to, {\n        relative: rest.relative\n    });\n    let location = (0, $8wGzW.useLocation)();\n    let routerState = $5kUFm.useContext((0, $8wGzW.UNSAFE_DataRouterStateContext));\n    let { navigator: navigator } = $5kUFm.useContext((0, $8wGzW.UNSAFE_NavigationContext));\n    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n    if (!caseSensitive) {\n        locationPathname = locationPathname.toLowerCase();\n        nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n        toPathname = toPathname.toLowerCase();\n    }\n    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === \"/\";\n    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n    let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n    let className;\n    if (typeof classNameProp === \"function\") className = classNameProp({\n        isActive: isActive,\n        isPending: isPending\n    });\n    else // If the className prop is not a function, we use a default `active`\n    // class for <NavLink />s that are active. In v5 `active` was the default\n    // value for `activeClassName`, but we are removing that API and can still\n    // use the old default behavior for a cleaner upgrade path and keep the\n    // simple styling rules working as they currently do.\n    className = [\n        classNameProp,\n        isActive ? \"active\" : null,\n        isPending ? \"pending\" : null\n    ].filter(Boolean).join(\" \");\n    let style = typeof styleProp === \"function\" ? styleProp({\n        isActive: isActive,\n        isPending: isPending\n    }) : styleProp;\n    return /*#__PURE__*/ $5kUFm.createElement($f7ba9b356b6d67df$export$a6c7ac8248d6e38a, $f7ba9b356b6d67df$var$_extends({}, rest, {\n        \"aria-current\": ariaCurrent,\n        className: className,\n        ref: ref,\n        style: style,\n        to: to\n    }), typeof children === \"function\" ? children({\n        isActive: isActive,\n        isPending: isPending\n    }) : children);\n});\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */ const $f7ba9b356b6d67df$export$a7fed597f4b8afd8 = /*#__PURE__*/ $5kUFm.forwardRef((props, ref)=>{\n    let submit = $f7ba9b356b6d67df$export$47c85c6e3a081d3();\n    return /*#__PURE__*/ $5kUFm.createElement($f7ba9b356b6d67df$var$FormImpl, $f7ba9b356b6d67df$var$_extends({}, props, {\n        submit: submit,\n        ref: ref\n    }));\n});\nconst $f7ba9b356b6d67df$var$FormImpl = /*#__PURE__*/ $5kUFm.forwardRef((_ref6, forwardedRef)=>{\n    let { reloadDocument: reloadDocument, replace: replace, state: state, method: method = $f7ba9b356b6d67df$var$defaultMethod, action: action, onSubmit: onSubmit, submit: submit, relative: relative, preventScrollReset: preventScrollReset } = _ref6, props = $f7ba9b356b6d67df$var$_objectWithoutPropertiesLoose(_ref6, $f7ba9b356b6d67df$var$_excluded3);\n    let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let formAction = $f7ba9b356b6d67df$export$89a6bd6db0d97c56(action, {\n        relative: relative\n    });\n    let submitHandler = (event)=>{\n        onSubmit && onSubmit(event);\n        if (event.defaultPrevented) return;\n        event.preventDefault();\n        let submitter = event.nativeEvent.submitter;\n        let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n        submit(submitter || event.currentTarget, {\n            method: submitMethod,\n            replace: replace,\n            state: state,\n            relative: relative,\n            preventScrollReset: preventScrollReset\n        });\n    };\n    return /*#__PURE__*/ $5kUFm.createElement(\"form\", $f7ba9b356b6d67df$var$_extends({\n        ref: forwardedRef,\n        method: formMethod,\n        action: formAction,\n        onSubmit: reloadDocument ? onSubmit : submitHandler\n    }, props));\n});\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */ function $f7ba9b356b6d67df$export$11aac1aab828f1fa(_ref7) {\n    let { getKey: getKey, storageKey: storageKey } = _ref7;\n    $f7ba9b356b6d67df$export$25057cfe5591e3e9({\n        getKey: getKey,\n        storageKey: storageKey\n    });\n    return null;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar $f7ba9b356b6d67df$var$DataRouterHook;\n(function(DataRouterHook) {\n    DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n    DataRouterHook[\"UseSubmit\"] = \"useSubmit\";\n    DataRouterHook[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\n    DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n})($f7ba9b356b6d67df$var$DataRouterHook || ($f7ba9b356b6d67df$var$DataRouterHook = {}));\nvar $f7ba9b356b6d67df$var$DataRouterStateHook;\n(function(DataRouterStateHook) {\n    DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n    DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})($f7ba9b356b6d67df$var$DataRouterStateHook || ($f7ba9b356b6d67df$var$DataRouterStateHook = {}));\nfunction $f7ba9b356b6d67df$var$getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction $f7ba9b356b6d67df$var$useDataRouterContext(hookName) {\n    let ctx = $5kUFm.useContext((0, $8wGzW.UNSAFE_DataRouterContext));\n    !ctx && (0, $bZ2h6.UNSAFE_invariant)(false);\n    return ctx;\n}\nfunction $f7ba9b356b6d67df$var$useDataRouterState(hookName) {\n    let state = $5kUFm.useContext((0, $8wGzW.UNSAFE_DataRouterStateContext));\n    !state && (0, $bZ2h6.UNSAFE_invariant)(false);\n    return state;\n}\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */ function $f7ba9b356b6d67df$export$67621102c14d847(to, _temp) {\n    let { target: target, replace: replaceProp, state: state, preventScrollReset: preventScrollReset, relative: relative } = _temp === void 0 ? {} : _temp;\n    let navigate = (0, $8wGzW.useNavigate)();\n    let location = (0, $8wGzW.useLocation)();\n    let path = (0, $8wGzW.useResolvedPath)(to, {\n        relative: relative\n    });\n    return $5kUFm.useCallback((event)=>{\n        if ($f7ba9b356b6d67df$var$shouldProcessLinkClick(event, target)) {\n            event.preventDefault();\n            // If the URL hasn't changed, a regular <a> will do a replace instead of\n            // a push, so do the same here unless the replace prop is explicitly set\n            let replace = replaceProp !== undefined ? replaceProp : (0, $bZ2h6.createPath)(location) === (0, $bZ2h6.createPath)(path);\n            navigate(to, {\n                replace: replace,\n                state: state,\n                preventScrollReset: preventScrollReset,\n                relative: relative\n            });\n        }\n    }, [\n        location,\n        navigate,\n        path,\n        replaceProp,\n        state,\n        target,\n        to,\n        preventScrollReset,\n        relative\n    ]);\n}\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */ function $f7ba9b356b6d67df$export$f1a78c17382fe22a(defaultInit) {\n    let defaultSearchParamsRef = $5kUFm.useRef($f7ba9b356b6d67df$export$a2e4e2dcc7b1f22f(defaultInit));\n    let hasSetSearchParamsRef = $5kUFm.useRef(false);\n    let location = (0, $8wGzW.useLocation)();\n    let searchParams = $5kUFm.useMemo(()=>// Only merge in the defaults if we haven't yet called setSearchParams.\n        // Once we call that we want those to take precedence, otherwise you can't\n        // remove a param with setSearchParams({}) if it has an initial value\n        $f7ba9b356b6d67df$var$getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [\n        location.search\n    ]);\n    let navigate = (0, $8wGzW.useNavigate)();\n    let setSearchParams = $5kUFm.useCallback((nextInit, navigateOptions)=>{\n        const newSearchParams = $f7ba9b356b6d67df$export$a2e4e2dcc7b1f22f(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n        hasSetSearchParamsRef.current = true;\n        navigate(\"?\" + newSearchParams, navigateOptions);\n    }, [\n        navigate,\n        searchParams\n    ]);\n    return [\n        searchParams,\n        setSearchParams\n    ];\n}\nfunction $f7ba9b356b6d67df$var$validateClientSideSubmission() {\n    if (typeof document === \"undefined\") throw new Error(\"You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.\");\n}\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */ function $f7ba9b356b6d67df$export$47c85c6e3a081d3() {\n    let { router: router } = $f7ba9b356b6d67df$var$useDataRouterContext($f7ba9b356b6d67df$var$DataRouterHook.UseSubmit);\n    let { basename: basename } = $5kUFm.useContext((0, $8wGzW.UNSAFE_NavigationContext));\n    let currentRouteId = (0, $8wGzW.UNSAFE_useRouteId)();\n    return $5kUFm.useCallback(function(target, options) {\n        if (options === void 0) options = {};\n        $f7ba9b356b6d67df$var$validateClientSideSubmission();\n        let { action: action, method: method, encType: encType, formData: formData, body: body } = $f7ba9b356b6d67df$var$getFormSubmissionInfo(target, basename);\n        router.navigate(options.action || action, {\n            preventScrollReset: options.preventScrollReset,\n            formData: formData,\n            body: body,\n            formMethod: options.method || method,\n            formEncType: options.encType || encType,\n            replace: options.replace,\n            state: options.state,\n            fromRouteId: currentRouteId\n        });\n    }, [\n        router,\n        basename,\n        currentRouteId\n    ]);\n}\n/**\n * Returns the implementation for fetcher.submit\n */ function $f7ba9b356b6d67df$var$useSubmitFetcher(fetcherKey, fetcherRouteId) {\n    let { router: router } = $f7ba9b356b6d67df$var$useDataRouterContext($f7ba9b356b6d67df$var$DataRouterHook.UseSubmitFetcher);\n    let { basename: basename } = $5kUFm.useContext((0, $8wGzW.UNSAFE_NavigationContext));\n    return $5kUFm.useCallback(function(target, options) {\n        if (options === void 0) options = {};\n        $f7ba9b356b6d67df$var$validateClientSideSubmission();\n        let { action: action, method: method, encType: encType, formData: formData, body: body } = $f7ba9b356b6d67df$var$getFormSubmissionInfo(target, basename);\n        !(fetcherRouteId != null) && (0, $bZ2h6.UNSAFE_invariant)(false);\n        router.fetch(fetcherKey, fetcherRouteId, options.action || action, {\n            preventScrollReset: options.preventScrollReset,\n            formData: formData,\n            body: body,\n            formMethod: options.method || method,\n            formEncType: options.encType || encType\n        });\n    }, [\n        router,\n        basename,\n        fetcherKey,\n        fetcherRouteId\n    ]);\n}\n// v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction $f7ba9b356b6d67df$export$89a6bd6db0d97c56(action, _temp2) {\n    let { relative: relative } = _temp2 === void 0 ? {} : _temp2;\n    let { basename: basename } = $5kUFm.useContext((0, $8wGzW.UNSAFE_NavigationContext));\n    let routeContext = $5kUFm.useContext((0, $8wGzW.UNSAFE_RouteContext));\n    !routeContext && (0, $bZ2h6.UNSAFE_invariant)(false);\n    let [match] = routeContext.matches.slice(-1);\n    // Shallow clone path so we can modify it below, otherwise we modify the\n    // object referenced by useMemo inside useResolvedPath\n    let path = $f7ba9b356b6d67df$var$_extends({}, (0, $8wGzW.useResolvedPath)(action ? action : \".\", {\n        relative: relative\n    }));\n    // Previously we set the default action to \".\". The problem with this is that\n    // `useResolvedPath(\".\")` excludes search params and the hash of the resolved\n    // URL. This is the intended behavior of when \".\" is specifically provided as\n    // the form action, but inconsistent w/ browsers when the action is omitted.\n    // https://github.com/remix-run/remix/issues/927\n    let location = (0, $8wGzW.useLocation)();\n    if (action == null) {\n        // Safe to write to these directly here since if action was undefined, we\n        // would have called useResolvedPath(\".\") which will never include a search\n        // or hash\n        path.search = location.search;\n        path.hash = location.hash;\n        // When grabbing search params from the URL, remove the automatically\n        // inserted ?index param so we match the useResolvedPath search behavior\n        // which would not include ?index\n        if (match.route.index) {\n            let params = new URLSearchParams(path.search);\n            params.delete(\"index\");\n            path.search = params.toString() ? \"?\" + params.toString() : \"\";\n        }\n    }\n    if ((!action || action === \".\") && match.route.index) path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the form action.  If this is a root navigation, then just use\n    // the raw basename which allows the basename to have full control over the\n    // presence of a trailing slash on root actions\n    if (basename !== \"/\") path.pathname = path.pathname === \"/\" ? basename : (0, $bZ2h6.joinPaths)([\n        basename,\n        path.pathname\n    ]);\n    return (0, $bZ2h6.createPath)(path);\n}\nfunction $f7ba9b356b6d67df$var$createFetcherForm(fetcherKey, routeId) {\n    let FetcherForm = /*#__PURE__*/ $5kUFm.forwardRef((props, ref)=>{\n        let submit = $f7ba9b356b6d67df$var$useSubmitFetcher(fetcherKey, routeId);\n        return /*#__PURE__*/ $5kUFm.createElement($f7ba9b356b6d67df$var$FormImpl, $f7ba9b356b6d67df$var$_extends({}, props, {\n            ref: ref,\n            submit: submit\n        }));\n    });\n    return FetcherForm;\n}\nlet $f7ba9b356b6d67df$var$fetcherId = 0;\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */ function $f7ba9b356b6d67df$export$5b0d2d9a9921565a() {\n    var _route$matches;\n    let { router: router } = $f7ba9b356b6d67df$var$useDataRouterContext($f7ba9b356b6d67df$var$DataRouterHook.UseFetcher);\n    let route = $5kUFm.useContext((0, $8wGzW.UNSAFE_RouteContext));\n    !route && (0, $bZ2h6.UNSAFE_invariant)(false);\n    let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n    !(routeId != null) && (0, $bZ2h6.UNSAFE_invariant)(false);\n    let [fetcherKey] = $5kUFm.useState(()=>String(++$f7ba9b356b6d67df$var$fetcherId));\n    let [Form] = $5kUFm.useState(()=>{\n        !routeId && (0, $bZ2h6.UNSAFE_invariant)(false);\n        return $f7ba9b356b6d67df$var$createFetcherForm(fetcherKey, routeId);\n    });\n    let [load] = $5kUFm.useState(()=>(href)=>{\n            !router && (0, $bZ2h6.UNSAFE_invariant)(false);\n            !routeId && (0, $bZ2h6.UNSAFE_invariant)(false);\n            router.fetch(fetcherKey, routeId, href);\n        });\n    let submit = $f7ba9b356b6d67df$var$useSubmitFetcher(fetcherKey, routeId);\n    let fetcher = router.getFetcher(fetcherKey);\n    let fetcherWithComponents = $5kUFm.useMemo(()=>$f7ba9b356b6d67df$var$_extends({\n            Form: Form,\n            submit: submit,\n            load: load\n        }, fetcher), [\n        fetcher,\n        Form,\n        submit,\n        load\n    ]);\n    $5kUFm.useEffect(()=>{\n        // Is this busted when the React team gets real weird and calls effects\n        // twice on mount?  We really just need to garbage collect here when this\n        // fetcher is no longer around.\n        return ()=>{\n            if (!router) {\n                console.warn(\"No router available to clean up from useFetcher()\");\n                return;\n            }\n            router.deleteFetcher(fetcherKey);\n        };\n    }, [\n        router,\n        fetcherKey\n    ]);\n    return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */ function $f7ba9b356b6d67df$export$fa996778a3a31087() {\n    let state = $f7ba9b356b6d67df$var$useDataRouterState($f7ba9b356b6d67df$var$DataRouterStateHook.UseFetchers);\n    return [\n        ...state.fetchers.values()\n    ];\n}\nconst $f7ba9b356b6d67df$var$SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nlet $f7ba9b356b6d67df$var$savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */ function $f7ba9b356b6d67df$export$25057cfe5591e3e9(_temp3) {\n    let { getKey: getKey, storageKey: storageKey } = _temp3 === void 0 ? {} : _temp3;\n    let { router: router } = $f7ba9b356b6d67df$var$useDataRouterContext($f7ba9b356b6d67df$var$DataRouterHook.UseScrollRestoration);\n    let { restoreScrollPosition: restoreScrollPosition, preventScrollReset: preventScrollReset } = $f7ba9b356b6d67df$var$useDataRouterState($f7ba9b356b6d67df$var$DataRouterStateHook.UseScrollRestoration);\n    let { basename: basename } = $5kUFm.useContext((0, $8wGzW.UNSAFE_NavigationContext));\n    let location = (0, $8wGzW.useLocation)();\n    let matches = (0, $8wGzW.useMatches)();\n    let navigation = (0, $8wGzW.useNavigation)();\n    // Trigger manual scroll restoration while we're active\n    $5kUFm.useEffect(()=>{\n        window.history.scrollRestoration = \"manual\";\n        return ()=>{\n            window.history.scrollRestoration = \"auto\";\n        };\n    }, []);\n    // Save positions on pagehide\n    $f7ba9b356b6d67df$var$usePageHide($5kUFm.useCallback(()=>{\n        if (navigation.state === \"idle\") {\n            let key = (getKey ? getKey(location, matches) : null) || location.key;\n            $f7ba9b356b6d67df$var$savedScrollPositions[key] = window.scrollY;\n        }\n        sessionStorage.setItem(storageKey || $f7ba9b356b6d67df$var$SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify($f7ba9b356b6d67df$var$savedScrollPositions));\n        window.history.scrollRestoration = \"auto\";\n    }, [\n        storageKey,\n        getKey,\n        navigation.state,\n        location,\n        matches\n    ]));\n    // Read in any saved scroll locations\n    if (typeof document !== \"undefined\") {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        $5kUFm.useLayoutEffect(()=>{\n            try {\n                let sessionPositions = sessionStorage.getItem(storageKey || $f7ba9b356b6d67df$var$SCROLL_RESTORATION_STORAGE_KEY);\n                if (sessionPositions) $f7ba9b356b6d67df$var$savedScrollPositions = JSON.parse(sessionPositions);\n            } catch (e) {\n            // no-op, use default empty object\n            }\n        }, [\n            storageKey\n        ]);\n        // Enable scroll restoration in the router\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        $5kUFm.useLayoutEffect(()=>{\n            let getKeyWithoutBasename = getKey && basename !== \"/\" ? (location, matches)=>getKey($f7ba9b356b6d67df$var$_extends({}, location, {\n                    pathname: (0, $bZ2h6.stripBasename)(location.pathname, basename) || location.pathname\n                }), matches) : getKey;\n            let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration($f7ba9b356b6d67df$var$savedScrollPositions, ()=>window.scrollY, getKeyWithoutBasename);\n            return ()=>disableScrollRestoration && disableScrollRestoration();\n        }, [\n            router,\n            basename,\n            getKey\n        ]);\n        // Restore scrolling when state.restoreScrollPosition changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        $5kUFm.useLayoutEffect(()=>{\n            // Explicit false means don't do anything (used for submissions)\n            if (restoreScrollPosition === false) return;\n            // been here before, scroll to it\n            if (typeof restoreScrollPosition === \"number\") {\n                window.scrollTo(0, restoreScrollPosition);\n                return;\n            }\n            // try to scroll to the hash\n            if (location.hash) {\n                let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n                if (el) {\n                    el.scrollIntoView();\n                    return;\n                }\n            }\n            // Don't reset if this navigation opted out\n            if (preventScrollReset === true) return;\n            // otherwise go to the top on new locations\n            window.scrollTo(0, 0);\n        }, [\n            location,\n            restoreScrollPosition,\n            preventScrollReset\n        ]);\n    }\n}\n/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */ function $f7ba9b356b6d67df$export$c0a586b329cae57d(callback, options) {\n    let { capture: capture } = options || {};\n    $5kUFm.useEffect(()=>{\n        let opts = capture != null ? {\n            capture: capture\n        } : undefined;\n        window.addEventListener(\"beforeunload\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"beforeunload\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\n/**\n * Setup a callback to be fired on the window's `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */ function $f7ba9b356b6d67df$var$usePageHide(callback, options) {\n    let { capture: capture } = options || {};\n    $5kUFm.useEffect(()=>{\n        let opts = capture != null ? {\n            capture: capture\n        } : undefined;\n        window.addEventListener(\"pagehide\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"pagehide\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\n/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */ function $f7ba9b356b6d67df$export$39f4eb3dbd812741(_ref8) {\n    let { when: when, message: message } = _ref8;\n    let blocker = (0, $8wGzW.unstable_useBlocker)(when);\n    $5kUFm.useEffect(()=>{\n        if (blocker.state === \"blocked\" && !when) blocker.reset();\n    }, [\n        blocker,\n        when\n    ]);\n    $5kUFm.useEffect(()=>{\n        if (blocker.state === \"blocked\") {\n            let proceed = window.confirm(message);\n            if (proceed) setTimeout(blocker.proceed, 0);\n            else blocker.reset();\n        }\n    }, [\n        blocker,\n        message\n    ]);\n}\n\n});\nparcelRequire.register(\"8wGzW\", function(module, exports) {\n\n$parcel$export(module.exports, \"UNSAFE_DataRouterContext\", () => $6352571d8ae2d252$export$3add0d5dce533e2e);\n$parcel$export(module.exports, \"UNSAFE_DataRouterStateContext\", () => $6352571d8ae2d252$export$145dfa71566a64dc);\n$parcel$export(module.exports, \"UNSAFE_NavigationContext\", () => $6352571d8ae2d252$export$26749e8557646306);\n$parcel$export(module.exports, \"UNSAFE_LocationContext\", () => $6352571d8ae2d252$export$c7914228fb69b0f5);\n$parcel$export(module.exports, \"UNSAFE_RouteContext\", () => $6352571d8ae2d252$export$9072aa6dd1f93057);\n$parcel$export(module.exports, \"useHref\", () => $6352571d8ae2d252$export$b66bb29c5006f12f);\n$parcel$export(module.exports, \"useInRouterContext\", () => $6352571d8ae2d252$export$9c954a9d03d32f4a);\n$parcel$export(module.exports, \"useResolvedPath\", () => $6352571d8ae2d252$export$e75d2a2d1b3c245b);\n$parcel$export(module.exports, \"useLocation\", () => $6352571d8ae2d252$export$45d76561a5302f2b);\n$parcel$export(module.exports, \"useNavigationType\", () => $6352571d8ae2d252$export$1b3f31771c5d07c);\n$parcel$export(module.exports, \"useMatch\", () => $6352571d8ae2d252$export$6c330e8992e8a295);\n$parcel$export(module.exports, \"useNavigate\", () => $6352571d8ae2d252$export$9770f232ac06a008);\n$parcel$export(module.exports, \"useOutletContext\", () => $6352571d8ae2d252$export$4138103a3ae699cc);\n$parcel$export(module.exports, \"useOutlet\", () => $6352571d8ae2d252$export$a3be3530d8e40d0b);\n$parcel$export(module.exports, \"useParams\", () => $6352571d8ae2d252$export$99eaa27ddbbb95ef);\n$parcel$export(module.exports, \"useRoutes\", () => $6352571d8ae2d252$export$5d3fca4a98652595);\n$parcel$export(module.exports, \"useRouteError\", () => $6352571d8ae2d252$export$ed527bf60f6e05f2);\n$parcel$export(module.exports, \"UNSAFE_useRouteId\", () => $6352571d8ae2d252$export$5fc8298006ad9e58);\n$parcel$export(module.exports, \"useNavigation\", () => $6352571d8ae2d252$export$d0fd4b7106de2769);\n$parcel$export(module.exports, \"useRevalidator\", () => $6352571d8ae2d252$export$600dc272ed516c15);\n$parcel$export(module.exports, \"useMatches\", () => $6352571d8ae2d252$export$2378eb7f5ff86053);\n$parcel$export(module.exports, \"useLoaderData\", () => $6352571d8ae2d252$export$1448a5050d252c4d);\n$parcel$export(module.exports, \"useRouteLoaderData\", () => $6352571d8ae2d252$export$fd5d37484eab868d);\n$parcel$export(module.exports, \"useActionData\", () => $6352571d8ae2d252$export$fdc00f3f26066d5e);\n$parcel$export(module.exports, \"useAsyncValue\", () => $6352571d8ae2d252$export$78a72ddb39bdd145);\n$parcel$export(module.exports, \"useAsyncError\", () => $6352571d8ae2d252$export$17f53340677d5831);\n$parcel$export(module.exports, \"unstable_useBlocker\", () => $6352571d8ae2d252$export$2af03a1de5c0910);\n$parcel$export(module.exports, \"RouterProvider\", () => $6352571d8ae2d252$export$323e4fc2fa4753fb);\n$parcel$export(module.exports, \"Router\", () => $6352571d8ae2d252$export$55185c17a0fcbe46);\n$parcel$export(module.exports, \"MemoryRouter\", () => $6352571d8ae2d252$export$ae46f04cfaffe093);\n$parcel$export(module.exports, \"Navigate\", () => $6352571d8ae2d252$export$444b3ab0cb9aec40);\n$parcel$export(module.exports, \"Outlet\", () => $6352571d8ae2d252$export$910ae8079b2c2852);\n$parcel$export(module.exports, \"Route\", () => $6352571d8ae2d252$export$e7b0ac011bb776c6);\n$parcel$export(module.exports, \"Routes\", () => $6352571d8ae2d252$export$3565eb3d00ca5a74);\n$parcel$export(module.exports, \"createRoutesFromChildren\", () => $6352571d8ae2d252$export$16da398f5434bdec);\n$parcel$export(module.exports, \"Await\", () => $6352571d8ae2d252$export$6ddabde395c8c576);\n$parcel$export(module.exports, \"renderMatches\", () => $6352571d8ae2d252$export$daf73786167a7f72);\n$parcel$export(module.exports, \"UNSAFE_mapRouteProperties\", () => $6352571d8ae2d252$export$52b333d321859367);\n$parcel$export(module.exports, \"createMemoryRouter\", () => $6352571d8ae2d252$export$f30f7e456d254e83);\n$parcel$export(module.exports, \"createRoutesFromElements\", () => $6352571d8ae2d252$export$16da398f5434bdec);\n$parcel$export(module.exports, \"AbortedDeferredError\", () => (parcelRequire(\"bZ2h6\")).AbortedDeferredError);\n$parcel$export(module.exports, \"NavigationType\", () => (parcelRequire(\"bZ2h6\")).Action);\n$parcel$export(module.exports, \"isRouteErrorResponse\", () => (parcelRequire(\"bZ2h6\")).isRouteErrorResponse);\n$parcel$export(module.exports, \"matchPath\", () => (parcelRequire(\"bZ2h6\")).matchPath);\n$parcel$export(module.exports, \"matchRoutes\", () => (parcelRequire(\"bZ2h6\")).matchRoutes);\n$parcel$export(module.exports, \"parsePath\", () => (parcelRequire(\"bZ2h6\")).parsePath);\n/**\n * React Router v6.14.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \nvar $5kUFm = parcelRequire(\"5kUFm\");\n\nvar $bZ2h6 = parcelRequire(\"bZ2h6\");\nfunction $6352571d8ae2d252$var$_extends() {\n    $6352571d8ae2d252$var$_extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];\n        }\n        return target;\n    };\n    return $6352571d8ae2d252$var$_extends.apply(this, arguments);\n}\n// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nconst $6352571d8ae2d252$export$3add0d5dce533e2e = /*#__PURE__*/ $5kUFm.createContext(null);\nconst $6352571d8ae2d252$export$145dfa71566a64dc = /*#__PURE__*/ $5kUFm.createContext(null);\nconst $6352571d8ae2d252$var$AwaitContext = /*#__PURE__*/ $5kUFm.createContext(null);\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level <Router> API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */ const $6352571d8ae2d252$export$26749e8557646306 = /*#__PURE__*/ $5kUFm.createContext(null);\nconst $6352571d8ae2d252$export$c7914228fb69b0f5 = /*#__PURE__*/ $5kUFm.createContext(null);\nconst $6352571d8ae2d252$export$9072aa6dd1f93057 = /*#__PURE__*/ $5kUFm.createContext({\n    outlet: null,\n    matches: [],\n    isDataRoute: false\n});\nconst $6352571d8ae2d252$var$RouteErrorContext = /*#__PURE__*/ $5kUFm.createContext(null);\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/hooks/use-href\n */ function $6352571d8ae2d252$export$b66bb29c5006f12f(to, _temp) {\n    let { relative: relative } = _temp === void 0 ? {} : _temp;\n    !$6352571d8ae2d252$export$9c954a9d03d32f4a() && (0, $bZ2h6.UNSAFE_invariant)(false);\n    let { basename: basename, navigator: navigator } = $5kUFm.useContext($6352571d8ae2d252$export$26749e8557646306);\n    let { hash: hash, pathname: pathname, search: search } = $6352571d8ae2d252$export$e75d2a2d1b3c245b(to, {\n        relative: relative\n    });\n    let joinedPathname = pathname;\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the href.  If this is a root navigation, then just use the raw\n    // basename which allows the basename to have full control over the presence\n    // of a trailing slash on root links\n    if (basename !== \"/\") joinedPathname = pathname === \"/\" ? basename : (0, $bZ2h6.joinPaths)([\n        basename,\n        pathname\n    ]);\n    return navigator.createHref({\n        pathname: joinedPathname,\n        search: search,\n        hash: hash\n    });\n}\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/hooks/use-in-router-context\n */ function $6352571d8ae2d252$export$9c954a9d03d32f4a() {\n    return $5kUFm.useContext($6352571d8ae2d252$export$c7914228fb69b0f5) != null;\n}\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/hooks/use-location\n */ function $6352571d8ae2d252$export$45d76561a5302f2b() {\n    !$6352571d8ae2d252$export$9c954a9d03d32f4a() && (0, $bZ2h6.UNSAFE_invariant)(false);\n    return $5kUFm.useContext($6352571d8ae2d252$export$c7914228fb69b0f5).location;\n}\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/hooks/use-navigation-type\n */ function $6352571d8ae2d252$export$1b3f31771c5d07c() {\n    return $5kUFm.useContext($6352571d8ae2d252$export$c7914228fb69b0f5).navigationType;\n}\n/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/hooks/use-match\n */ function $6352571d8ae2d252$export$6c330e8992e8a295(pattern) {\n    !$6352571d8ae2d252$export$9c954a9d03d32f4a() && (0, $bZ2h6.UNSAFE_invariant)(false);\n    let { pathname: pathname } = $6352571d8ae2d252$export$45d76561a5302f2b();\n    return $5kUFm.useMemo(()=>(0, $bZ2h6.matchPath)(pattern, pathname), [\n        pathname,\n        pattern\n    ]);\n}\n/**\n * The interface for the navigate() function returned from useNavigate().\n */ const $6352571d8ae2d252$var$navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when your component is first rendered.\";\n// Mute warnings for calls to useNavigate in SSR environments\nfunction $6352571d8ae2d252$var$useIsomorphicLayoutEffect(cb) {\n    let isStatic = $5kUFm.useContext($6352571d8ae2d252$export$26749e8557646306).static;\n    if (!isStatic) // We should be able to get rid of this once react 18.3 is released\n    // See: https://github.com/facebook/react/pull/26395\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    $5kUFm.useLayoutEffect(cb);\n}\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/hooks/use-navigate\n */ function $6352571d8ae2d252$export$9770f232ac06a008() {\n    let { isDataRoute: isDataRoute } = $5kUFm.useContext($6352571d8ae2d252$export$9072aa6dd1f93057);\n    // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return isDataRoute ? $6352571d8ae2d252$var$useNavigateStable() : $6352571d8ae2d252$var$useNavigateUnstable();\n}\nfunction $6352571d8ae2d252$var$useNavigateUnstable() {\n    !$6352571d8ae2d252$export$9c954a9d03d32f4a() && (0, $bZ2h6.UNSAFE_invariant)(false);\n    let dataRouterContext = $5kUFm.useContext($6352571d8ae2d252$export$3add0d5dce533e2e);\n    let { basename: basename, navigator: navigator } = $5kUFm.useContext($6352571d8ae2d252$export$26749e8557646306);\n    let { matches: matches } = $5kUFm.useContext($6352571d8ae2d252$export$9072aa6dd1f93057);\n    let { pathname: locationPathname } = $6352571d8ae2d252$export$45d76561a5302f2b();\n    let routePathnamesJson = JSON.stringify((0, $bZ2h6.UNSAFE_getPathContributingMatches)(matches).map((match)=>match.pathnameBase));\n    let activeRef = $5kUFm.useRef(false);\n    $6352571d8ae2d252$var$useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = $5kUFm.useCallback(function(to, options) {\n        if (options === void 0) options = {};\n        // Short circuit here since if this happens on first render the navigate\n        // is useless because we haven't wired up our history listener yet\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            navigator.go(to);\n            return;\n        }\n        let path = (0, $bZ2h6.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n        // If we're operating within a basename, prepend it to the pathname prior\n        // to handing off to history (but only if we're not in a data router,\n        // otherwise it'll prepend the basename inside of the router).\n        // If this is a root navigation, then we navigate to the raw basename\n        // which allows the basename to have full control over the presence of a\n        // trailing slash on root links\n        if (dataRouterContext == null && basename !== \"/\") path.pathname = path.pathname === \"/\" ? basename : (0, $bZ2h6.joinPaths)([\n            basename,\n            path.pathname\n        ]);\n        (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n    }, [\n        basename,\n        navigator,\n        routePathnamesJson,\n        locationPathname,\n        dataRouterContext\n    ]);\n    return navigate;\n}\nconst $6352571d8ae2d252$var$OutletContext = /*#__PURE__*/ $5kUFm.createContext(null);\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/hooks/use-outlet-context\n */ function $6352571d8ae2d252$export$4138103a3ae699cc() {\n    return $5kUFm.useContext($6352571d8ae2d252$var$OutletContext);\n}\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/hooks/use-outlet\n */ function $6352571d8ae2d252$export$a3be3530d8e40d0b(context) {\n    let outlet = $5kUFm.useContext($6352571d8ae2d252$export$9072aa6dd1f93057).outlet;\n    if (outlet) return /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$var$OutletContext.Provider, {\n        value: context\n    }, outlet);\n    return outlet;\n}\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/hooks/use-params\n */ function $6352571d8ae2d252$export$99eaa27ddbbb95ef() {\n    let { matches: matches } = $5kUFm.useContext($6352571d8ae2d252$export$9072aa6dd1f93057);\n    let routeMatch = matches[matches.length - 1];\n    return routeMatch ? routeMatch.params : {};\n}\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/hooks/use-resolved-path\n */ function $6352571d8ae2d252$export$e75d2a2d1b3c245b(to, _temp2) {\n    let { relative: relative } = _temp2 === void 0 ? {} : _temp2;\n    let { matches: matches } = $5kUFm.useContext($6352571d8ae2d252$export$9072aa6dd1f93057);\n    let { pathname: locationPathname } = $6352571d8ae2d252$export$45d76561a5302f2b();\n    let routePathnamesJson = JSON.stringify((0, $bZ2h6.UNSAFE_getPathContributingMatches)(matches).map((match)=>match.pathnameBase));\n    return $5kUFm.useMemo(()=>(0, $bZ2h6.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [\n        to,\n        routePathnamesJson,\n        locationPathname,\n        relative\n    ]);\n}\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/hooks/use-routes\n */ function $6352571d8ae2d252$export$5d3fca4a98652595(routes, locationArg) {\n    return $6352571d8ae2d252$export$5fcee62552a12fbf(routes, locationArg);\n}\n// Internal implementation with accept optional param for RouterProvider usage\nfunction $6352571d8ae2d252$export$5fcee62552a12fbf(routes, locationArg, dataRouterState) {\n    !$6352571d8ae2d252$export$9c954a9d03d32f4a() && (0, $bZ2h6.UNSAFE_invariant)(false);\n    let { navigator: navigator } = $5kUFm.useContext($6352571d8ae2d252$export$26749e8557646306);\n    let { matches: parentMatches } = $5kUFm.useContext($6352571d8ae2d252$export$9072aa6dd1f93057);\n    let routeMatch = parentMatches[parentMatches.length - 1];\n    let parentParams = routeMatch ? routeMatch.params : {};\n    let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n    let parentRoute = routeMatch && routeMatch.route;\n    let locationFromContext = $6352571d8ae2d252$export$45d76561a5302f2b();\n    let location;\n    if (locationArg) {\n        var _parsedLocationArg$pa;\n        let parsedLocationArg = typeof locationArg === \"string\" ? (0, $bZ2h6.parsePath)(locationArg) : locationArg;\n        !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) && (0, $bZ2h6.UNSAFE_invariant)(false);\n        location = parsedLocationArg;\n    } else location = locationFromContext;\n    let pathname = location.pathname || \"/\";\n    let remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n    let matches = (0, $bZ2h6.matchRoutes)(routes, {\n        pathname: remainingPathname\n    });\n    let renderedMatches = $6352571d8ae2d252$var$_renderMatches(matches && matches.map((match)=>Object.assign({}, match, {\n            params: Object.assign({}, parentParams, match.params),\n            pathname: (0, $bZ2h6.joinPaths)([\n                parentPathnameBase,\n                // Re-encode pathnames that were decoded inside matchRoutes\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname\n            ]),\n            pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : (0, $bZ2h6.joinPaths)([\n                parentPathnameBase,\n                // Re-encode pathnames that were decoded inside matchRoutes\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase\n            ])\n        })), parentMatches, dataRouterState);\n    // When a user passes in a `locationArg`, the associated routes need to\n    // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n    // to use the scoped location instead of the global location.\n    if (locationArg && renderedMatches) return /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$export$c7914228fb69b0f5.Provider, {\n        value: {\n            location: $6352571d8ae2d252$var$_extends({\n                pathname: \"/\",\n                search: \"\",\n                hash: \"\",\n                state: null,\n                key: \"default\"\n            }, location),\n            navigationType: (0, $bZ2h6.Action).Pop\n        }\n    }, renderedMatches);\n    return renderedMatches;\n}\nfunction $6352571d8ae2d252$var$DefaultErrorComponent() {\n    let error = $6352571d8ae2d252$export$ed527bf60f6e05f2();\n    let message = (0, $bZ2h6.isRouteErrorResponse)(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n    let stack = error instanceof Error ? error.stack : null;\n    let lightgrey = \"rgba(200,200,200, 0.5)\";\n    let preStyles = {\n        padding: \"0.5rem\",\n        backgroundColor: lightgrey\n    };\n    let codeStyles = {\n        padding: \"2px 4px\",\n        backgroundColor: lightgrey\n    };\n    let devInfo = null;\n    return /*#__PURE__*/ $5kUFm.createElement($5kUFm.Fragment, null, /*#__PURE__*/ $5kUFm.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/ $5kUFm.createElement(\"h3\", {\n        style: {\n            fontStyle: \"italic\"\n        }\n    }, message), stack ? /*#__PURE__*/ $5kUFm.createElement(\"pre\", {\n        style: preStyles\n    }, stack) : null, devInfo);\n}\nconst $6352571d8ae2d252$var$defaultErrorElement = /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$var$DefaultErrorComponent, null);\nclass $6352571d8ae2d252$var$RenderErrorBoundary extends $5kUFm.Component {\n    static getDerivedStateFromError(error) {\n        return {\n            error: error\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        // When we get into an error state, the user will likely click \"back\" to the\n        // previous page that didn't have an error. Because this wraps the entire\n        // application, that will have no effect--the error page continues to display.\n        // This gives us a mechanism to recover from the error when the location changes.\n        //\n        // Whether we're in an error state or not, we update the location in state\n        // so that when we are in an error state, it gets reset when a new location\n        // comes in and the user recovers from the error.\n        if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") return {\n            error: props.error,\n            location: props.location,\n            revalidation: props.revalidation\n        };\n        // If we're not changing locations, preserve the location but still surface\n        // any new errors that may come through. We retain the existing error, we do\n        // this because the error provided from the app state may be cleared without\n        // the location changing.\n        return {\n            error: props.error || state.error,\n            location: state.location,\n            revalidation: props.revalidation || state.revalidation\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"React Router caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        return this.state.error ? /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$export$9072aa6dd1f93057.Provider, {\n            value: this.props.routeContext\n        }, /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$var$RouteErrorContext.Provider, {\n            value: this.state.error,\n            children: this.props.component\n        })) : this.props.children;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            location: props.location,\n            revalidation: props.revalidation,\n            error: props.error\n        };\n    }\n}\nfunction $6352571d8ae2d252$var$RenderedRoute(_ref) {\n    let { routeContext: routeContext, match: match, children: children } = _ref;\n    let dataRouterContext = $5kUFm.useContext($6352571d8ae2d252$export$3add0d5dce533e2e);\n    // Track how deep we got in our render pass to emulate SSR componentDidCatch\n    // in a DataStaticRouter\n    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n    return /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$export$9072aa6dd1f93057.Provider, {\n        value: routeContext\n    }, children);\n}\nfunction $6352571d8ae2d252$var$_renderMatches(matches, parentMatches, dataRouterState) {\n    var _dataRouterState2;\n    if (parentMatches === void 0) parentMatches = [];\n    if (dataRouterState === void 0) dataRouterState = null;\n    if (matches == null) {\n        var _dataRouterState;\n        if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) // Don't bail if we have data router errors so we can render them in the\n        // boundary.  Use the pre-matched (or shimmed) matches\n        matches = dataRouterState.matches;\n        else return null;\n    }\n    let renderedMatches = matches;\n    // If we have data errors, trim matches to the highest error boundary\n    let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n    if (errors != null) {\n        let errorIndex = renderedMatches.findIndex((m)=>m.route.id && (errors == null ? void 0 : errors[m.route.id]));\n        !(errorIndex >= 0) && (0, $bZ2h6.UNSAFE_invariant)(false);\n        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n    }\n    return renderedMatches.reduceRight((outlet, match, index)=>{\n        let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null;\n        // Only data routers handle errors\n        let errorElement = null;\n        if (dataRouterState) errorElement = match.route.errorElement || $6352571d8ae2d252$var$defaultErrorElement;\n        let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n        let getChildren = ()=>{\n            let children;\n            if (error) children = errorElement;\n            else if (match.route.Component) // Note: This is a de-optimized path since React won't re-use the\n            // ReactElement since it's identity changes with each new\n            // React.createElement call.  We keep this so folks can use\n            // `<Route Component={...}>` in `<Routes>` but generally `Component`\n            // usage is only advised in `RouterProvider` when we can convert it to\n            // `element` ahead of time.\n            children = /*#__PURE__*/ $5kUFm.createElement(match.route.Component, null);\n            else if (match.route.element) children = match.route.element;\n            else children = outlet;\n            return /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$var$RenderedRoute, {\n                match: match,\n                routeContext: {\n                    outlet: outlet,\n                    matches: matches,\n                    isDataRoute: dataRouterState != null\n                },\n                children: children\n            });\n        };\n        // Only wrap in an error boundary within data router usages when we have an\n        // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n        // an ancestor ErrorBoundary/errorElement\n        return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$var$RenderErrorBoundary, {\n            location: dataRouterState.location,\n            revalidation: dataRouterState.revalidation,\n            component: errorElement,\n            error: error,\n            children: getChildren(),\n            routeContext: {\n                outlet: null,\n                matches: matches,\n                isDataRoute: true\n            }\n        }) : getChildren();\n    }, null);\n}\nvar $6352571d8ae2d252$var$DataRouterHook;\n(function(DataRouterHook) {\n    DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterHook[\"UseNavigateStable\"] = \"useNavigate\";\n})($6352571d8ae2d252$var$DataRouterHook || ($6352571d8ae2d252$var$DataRouterHook = {}));\nvar $6352571d8ae2d252$var$DataRouterStateHook;\n(function(DataRouterStateHook) {\n    DataRouterStateHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n    DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n    DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n    DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n    DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n    DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n    DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterStateHook[\"UseNavigateStable\"] = \"useNavigate\";\n    DataRouterStateHook[\"UseRouteId\"] = \"useRouteId\";\n})($6352571d8ae2d252$var$DataRouterStateHook || ($6352571d8ae2d252$var$DataRouterStateHook = {}));\nfunction $6352571d8ae2d252$var$getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction $6352571d8ae2d252$var$useDataRouterContext(hookName) {\n    let ctx = $5kUFm.useContext($6352571d8ae2d252$export$3add0d5dce533e2e);\n    !ctx && (0, $bZ2h6.UNSAFE_invariant)(false);\n    return ctx;\n}\nfunction $6352571d8ae2d252$var$useDataRouterState(hookName) {\n    let state = $5kUFm.useContext($6352571d8ae2d252$export$145dfa71566a64dc);\n    !state && (0, $bZ2h6.UNSAFE_invariant)(false);\n    return state;\n}\nfunction $6352571d8ae2d252$var$useRouteContext(hookName) {\n    let route = $5kUFm.useContext($6352571d8ae2d252$export$9072aa6dd1f93057);\n    !route && (0, $bZ2h6.UNSAFE_invariant)(false);\n    return route;\n}\n// Internal version with hookName-aware debugging\nfunction $6352571d8ae2d252$var$useCurrentRouteId(hookName) {\n    let route = $6352571d8ae2d252$var$useRouteContext(hookName);\n    let thisRoute = route.matches[route.matches.length - 1];\n    !thisRoute.route.id && (0, $bZ2h6.UNSAFE_invariant)(false);\n    return thisRoute.route.id;\n}\n/**\n * Returns the ID for the nearest contextual route\n */ function $6352571d8ae2d252$export$5fc8298006ad9e58() {\n    return $6352571d8ae2d252$var$useCurrentRouteId($6352571d8ae2d252$var$DataRouterStateHook.UseRouteId);\n}\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */ function $6352571d8ae2d252$export$d0fd4b7106de2769() {\n    let state = $6352571d8ae2d252$var$useDataRouterState($6352571d8ae2d252$var$DataRouterStateHook.UseNavigation);\n    return state.navigation;\n}\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */ function $6352571d8ae2d252$export$600dc272ed516c15() {\n    let dataRouterContext = $6352571d8ae2d252$var$useDataRouterContext($6352571d8ae2d252$var$DataRouterHook.UseRevalidator);\n    let state = $6352571d8ae2d252$var$useDataRouterState($6352571d8ae2d252$var$DataRouterStateHook.UseRevalidator);\n    return {\n        revalidate: dataRouterContext.router.revalidate,\n        state: state.revalidation\n    };\n}\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */ function $6352571d8ae2d252$export$2378eb7f5ff86053() {\n    let { matches: matches, loaderData: loaderData } = $6352571d8ae2d252$var$useDataRouterState($6352571d8ae2d252$var$DataRouterStateHook.UseMatches);\n    return $5kUFm.useMemo(()=>matches.map((match)=>{\n            let { pathname: pathname, params: params } = match;\n            // Note: This structure matches that created by createUseMatchesMatch\n            // in the @remix-run/router , so if you change this please also change\n            // that :)  Eventually we'll DRY this up\n            return {\n                id: match.route.id,\n                pathname: pathname,\n                params: params,\n                data: loaderData[match.route.id],\n                handle: match.route.handle\n            };\n        }), [\n        matches,\n        loaderData\n    ]);\n}\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */ function $6352571d8ae2d252$export$1448a5050d252c4d() {\n    let state = $6352571d8ae2d252$var$useDataRouterState($6352571d8ae2d252$var$DataRouterStateHook.UseLoaderData);\n    let routeId = $6352571d8ae2d252$var$useCurrentRouteId($6352571d8ae2d252$var$DataRouterStateHook.UseLoaderData);\n    if (state.errors && state.errors[routeId] != null) {\n        console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n        return undefined;\n    }\n    return state.loaderData[routeId];\n}\n/**\n * Returns the loaderData for the given routeId\n */ function $6352571d8ae2d252$export$fd5d37484eab868d(routeId) {\n    let state = $6352571d8ae2d252$var$useDataRouterState($6352571d8ae2d252$var$DataRouterStateHook.UseRouteLoaderData);\n    return state.loaderData[routeId];\n}\n/**\n * Returns the action data for the nearest ancestor Route action\n */ function $6352571d8ae2d252$export$fdc00f3f26066d5e() {\n    let state = $6352571d8ae2d252$var$useDataRouterState($6352571d8ae2d252$var$DataRouterStateHook.UseActionData);\n    let route = $5kUFm.useContext($6352571d8ae2d252$export$9072aa6dd1f93057);\n    !route && (0, $bZ2h6.UNSAFE_invariant)(false);\n    return Object.values((state == null ? void 0 : state.actionData) || {})[0];\n}\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * ErrorBoundary/errorElement to display a proper error message.\n */ function $6352571d8ae2d252$export$ed527bf60f6e05f2() {\n    var _state$errors;\n    let error = $5kUFm.useContext($6352571d8ae2d252$var$RouteErrorContext);\n    let state = $6352571d8ae2d252$var$useDataRouterState($6352571d8ae2d252$var$DataRouterStateHook.UseRouteError);\n    let routeId = $6352571d8ae2d252$var$useCurrentRouteId($6352571d8ae2d252$var$DataRouterStateHook.UseRouteError);\n    // If this was a render error, we put it in a RouteError context inside\n    // of RenderErrorBoundary\n    if (error) return error;\n    // Otherwise look for errors from our data router state\n    return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n}\n/**\n * Returns the happy-path data from the nearest ancestor <Await /> value\n */ function $6352571d8ae2d252$export$78a72ddb39bdd145() {\n    let value = $5kUFm.useContext($6352571d8ae2d252$var$AwaitContext);\n    return value == null ? void 0 : value._data;\n}\n/**\n * Returns the error from the nearest ancestor <Await /> value\n */ function $6352571d8ae2d252$export$17f53340677d5831() {\n    let value = $5kUFm.useContext($6352571d8ae2d252$var$AwaitContext);\n    return value == null ? void 0 : value._error;\n}\nlet $6352571d8ae2d252$var$blockerId = 0;\n/**\n * Allow the application to block navigations within the SPA and present the\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n * using half-filled form data.  This does not handle hard-reloads or\n * cross-origin navigations.\n */ function $6352571d8ae2d252$export$2af03a1de5c0910(shouldBlock) {\n    let { router: router, basename: basename } = $6352571d8ae2d252$var$useDataRouterContext($6352571d8ae2d252$var$DataRouterHook.UseBlocker);\n    let state = $6352571d8ae2d252$var$useDataRouterState($6352571d8ae2d252$var$DataRouterStateHook.UseBlocker);\n    let [blockerKey, setBlockerKey] = $5kUFm.useState(\"\");\n    let blockerFunction = $5kUFm.useCallback((arg)=>{\n        if (typeof shouldBlock !== \"function\") return !!shouldBlock;\n        if (basename === \"/\") return shouldBlock(arg);\n        // If they provided us a function and we've got an active basename, strip\n        // it from the locations we expose to the user to match the behavior of\n        // useLocation\n        let { currentLocation: currentLocation, nextLocation: nextLocation, historyAction: historyAction } = arg;\n        return shouldBlock({\n            currentLocation: $6352571d8ae2d252$var$_extends({}, currentLocation, {\n                pathname: (0, $bZ2h6.stripBasename)(currentLocation.pathname, basename) || currentLocation.pathname\n            }),\n            nextLocation: $6352571d8ae2d252$var$_extends({}, nextLocation, {\n                pathname: (0, $bZ2h6.stripBasename)(nextLocation.pathname, basename) || nextLocation.pathname\n            }),\n            historyAction: historyAction\n        });\n    }, [\n        basename,\n        shouldBlock\n    ]);\n    // This effect is in charge of blocker key assignment and deletion (which is\n    // tightly coupled to the key)\n    $5kUFm.useEffect(()=>{\n        let key = String(++$6352571d8ae2d252$var$blockerId);\n        setBlockerKey(key);\n        return ()=>router.deleteBlocker(key);\n    }, [\n        router\n    ]);\n    // This effect handles assigning the blockerFunction.  This is to handle\n    // unstable blocker function identities, and happens only after the prior\n    // effect so we don't get an orphaned blockerFunction in the router with a\n    // key of \"\".  Until then we just have the IDLE_BLOCKER.\n    $5kUFm.useEffect(()=>{\n        if (blockerKey !== \"\") router.getBlocker(blockerKey, blockerFunction);\n    }, [\n        router,\n        blockerKey,\n        blockerFunction\n    ]);\n    // Prefer the blocker from `state` not `router.state` since DataRouterContext\n    // is memoized so this ensures we update on blocker state updates\n    return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : (0, $bZ2h6.IDLE_BLOCKER);\n}\n/**\n * Stable version of useNavigate that is used when we are in the context of\n * a RouterProvider.\n */ function $6352571d8ae2d252$var$useNavigateStable() {\n    let { router: router } = $6352571d8ae2d252$var$useDataRouterContext($6352571d8ae2d252$var$DataRouterHook.UseNavigateStable);\n    let id = $6352571d8ae2d252$var$useCurrentRouteId($6352571d8ae2d252$var$DataRouterStateHook.UseNavigateStable);\n    let activeRef = $5kUFm.useRef(false);\n    $6352571d8ae2d252$var$useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = $5kUFm.useCallback(function(to, options) {\n        if (options === void 0) options = {};\n        // Short circuit here since if this happens on first render the navigate\n        // is useless because we haven't wired up our router subscriber yet\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") router.navigate(to);\n        else router.navigate(to, $6352571d8ae2d252$var$_extends({\n            fromRouteId: id\n        }, options));\n    }, [\n        router,\n        id\n    ]);\n    return navigate;\n}\nconst $6352571d8ae2d252$var$alreadyWarned = {};\nfunction $6352571d8ae2d252$var$warningOnce(key, cond, message) {\n    if (!cond && !$6352571d8ae2d252$var$alreadyWarned[key]) $6352571d8ae2d252$var$alreadyWarned[key] = true;\n}\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/ const $6352571d8ae2d252$var$START_TRANSITION = \"startTransition\";\nconst $6352571d8ae2d252$var$startTransitionImpl = $5kUFm[$6352571d8ae2d252$var$START_TRANSITION];\n/**\n * Given a Remix Router instance, render the appropriate UI\n */ function $6352571d8ae2d252$export$323e4fc2fa4753fb(_ref) {\n    let { fallbackElement: fallbackElement, router: router, future: future } = _ref;\n    // Need to use a layout effect here so we are subscribed early enough to\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n    let [state, setStateImpl] = $5kUFm.useState(router.state);\n    let { v7_startTransition: v7_startTransition } = future || {};\n    let setState = $5kUFm.useCallback((newState)=>{\n        v7_startTransition && $6352571d8ae2d252$var$startTransitionImpl ? $6352571d8ae2d252$var$startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    $5kUFm.useLayoutEffect(()=>router.subscribe(setState), [\n        router,\n        setState\n    ]);\n    let navigator = $5kUFm.useMemo(()=>{\n        return {\n            createHref: router.createHref,\n            encodeLocation: router.encodeLocation,\n            go: (n)=>router.navigate(n),\n            push: (to, state, opts)=>router.navigate(to, {\n                    state: state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                }),\n            replace: (to, state, opts)=>router.navigate(to, {\n                    replace: true,\n                    state: state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                })\n        };\n    }, [\n        router\n    ]);\n    let basename = router.basename || \"/\";\n    let dataRouterContext = $5kUFm.useMemo(()=>({\n            router: router,\n            navigator: navigator,\n            static: false,\n            basename: basename\n        }), [\n        router,\n        navigator,\n        basename\n    ]);\n    // The fragment and {null} here are important!  We need them to keep React 18's\n    // useId happy when we are server-rendering since we may have a <script> here\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\n    // useId relies on the component tree structure to generate deterministic id's\n    // so we need to ensure it remains the same on the client even though\n    // we don't need the <script> tag\n    return /*#__PURE__*/ $5kUFm.createElement($5kUFm.Fragment, null, /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$export$3add0d5dce533e2e.Provider, {\n        value: dataRouterContext\n    }, /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$export$145dfa71566a64dc.Provider, {\n        value: state\n    }, /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$export$55185c17a0fcbe46, {\n        basename: basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator: navigator\n    }, state.initialized ? /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$var$DataRoutes, {\n        routes: router.routes,\n        state: state\n    }) : fallbackElement))), null);\n}\nfunction $6352571d8ae2d252$var$DataRoutes(_ref2) {\n    let { routes: routes, state: state } = _ref2;\n    return $6352571d8ae2d252$export$5fcee62552a12fbf(routes, undefined, state);\n}\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/router-components/memory-router\n */ function $6352571d8ae2d252$export$ae46f04cfaffe093(_ref3) {\n    let { basename: basename, children: children, initialEntries: initialEntries, initialIndex: initialIndex, future: future } = _ref3;\n    let historyRef = $5kUFm.useRef();\n    if (historyRef.current == null) historyRef.current = (0, $bZ2h6.createMemoryHistory)({\n        initialEntries: initialEntries,\n        initialIndex: initialIndex,\n        v5Compat: true\n    });\n    let history = historyRef.current;\n    let [state, setStateImpl] = $5kUFm.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition: v7_startTransition } = future || {};\n    let setState = $5kUFm.useCallback((newState)=>{\n        v7_startTransition && $6352571d8ae2d252$var$startTransitionImpl ? $6352571d8ae2d252$var$startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    $5kUFm.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$export$55185c17a0fcbe46, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/components/navigate\n */ function $6352571d8ae2d252$export$444b3ab0cb9aec40(_ref4) {\n    let { to: to, replace: replace, state: state, relative: relative } = _ref4;\n    !$6352571d8ae2d252$export$9c954a9d03d32f4a() && (0, $bZ2h6.UNSAFE_invariant)(false);\n    let { matches: matches } = $5kUFm.useContext($6352571d8ae2d252$export$9072aa6dd1f93057);\n    let { pathname: locationPathname } = $6352571d8ae2d252$export$45d76561a5302f2b();\n    let navigate = $6352571d8ae2d252$export$9770f232ac06a008();\n    // Resolve the path outside of the effect so that when effects run twice in\n    // StrictMode they navigate to the same place\n    let path = (0, $bZ2h6.resolveTo)(to, (0, $bZ2h6.UNSAFE_getPathContributingMatches)(matches).map((match)=>match.pathnameBase), locationPathname, relative === \"path\");\n    let jsonPath = JSON.stringify(path);\n    $5kUFm.useEffect(()=>navigate(JSON.parse(jsonPath), {\n            replace: replace,\n            state: state,\n            relative: relative\n        }), [\n        navigate,\n        jsonPath,\n        relative,\n        replace,\n        state\n    ]);\n    return null;\n}\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/components/outlet\n */ function $6352571d8ae2d252$export$910ae8079b2c2852(props) {\n    return $6352571d8ae2d252$export$a3be3530d8e40d0b(props.context);\n}\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/components/route\n */ function $6352571d8ae2d252$export$e7b0ac011bb776c6(_props) {\n    (0, $bZ2h6.UNSAFE_invariant)(false);\n}\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/router-components/router\n */ function $6352571d8ae2d252$export$55185c17a0fcbe46(_ref5) {\n    let { basename: basenameProp = \"/\", children: children = null, location: locationProp, navigationType: navigationType = (0, $bZ2h6.Action).Pop, navigator: navigator, static: staticProp = false } = _ref5;\n    !!$6352571d8ae2d252$export$9c954a9d03d32f4a() && (0, $bZ2h6.UNSAFE_invariant)(false);\n    // Preserve trailing slashes on basename, so we can let the user control\n    // the enforcement of trailing slashes throughout the app\n    let basename = basenameProp.replace(/^\\/*/, \"/\");\n    let navigationContext = $5kUFm.useMemo(()=>({\n            basename: basename,\n            navigator: navigator,\n            static: staticProp\n        }), [\n        basename,\n        navigator,\n        staticProp\n    ]);\n    if (typeof locationProp === \"string\") locationProp = (0, $bZ2h6.parsePath)(locationProp);\n    let { pathname: pathname = \"/\", search: search = \"\", hash: hash = \"\", state: state = null, key: key = \"default\" } = locationProp;\n    let locationContext = $5kUFm.useMemo(()=>{\n        let trailingPathname = (0, $bZ2h6.stripBasename)(pathname, basename);\n        if (trailingPathname == null) return null;\n        return {\n            location: {\n                pathname: trailingPathname,\n                search: search,\n                hash: hash,\n                state: state,\n                key: key\n            },\n            navigationType: navigationType\n        };\n    }, [\n        basename,\n        pathname,\n        search,\n        hash,\n        state,\n        key,\n        navigationType\n    ]);\n    if (locationContext == null) return null;\n    return /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$export$26749e8557646306.Provider, {\n        value: navigationContext\n    }, /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$export$c7914228fb69b0f5.Provider, {\n        children: children,\n        value: locationContext\n    }));\n}\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/components/routes\n */ function $6352571d8ae2d252$export$3565eb3d00ca5a74(_ref6) {\n    let { children: children, location: location } = _ref6;\n    return $6352571d8ae2d252$export$5d3fca4a98652595($6352571d8ae2d252$export$16da398f5434bdec(children), location);\n}\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */ function $6352571d8ae2d252$export$6ddabde395c8c576(_ref7) {\n    let { children: children, errorElement: errorElement, resolve: resolve } = _ref7;\n    return /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$var$AwaitErrorBoundary, {\n        resolve: resolve,\n        errorElement: errorElement\n    }, /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$var$ResolveAwait, null, children));\n}\nvar $6352571d8ae2d252$var$AwaitRenderStatus;\n(function(AwaitRenderStatus) {\n    AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n    AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n    AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n})($6352571d8ae2d252$var$AwaitRenderStatus || ($6352571d8ae2d252$var$AwaitRenderStatus = {}));\nconst $6352571d8ae2d252$var$neverSettledPromise = new Promise(()=>{});\nclass $6352571d8ae2d252$var$AwaitErrorBoundary extends $5kUFm.Component {\n    static getDerivedStateFromError(error) {\n        return {\n            error: error\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"<Await> caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        let { children: children, errorElement: errorElement, resolve: resolve } = this.props;\n        let promise = null;\n        let status = $6352571d8ae2d252$var$AwaitRenderStatus.pending;\n        if (!(resolve instanceof Promise)) {\n            // Didn't get a promise - provide as a resolved promise\n            status = $6352571d8ae2d252$var$AwaitRenderStatus.success;\n            promise = Promise.resolve();\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_data\", {\n                get: ()=>resolve\n            });\n        } else if (this.state.error) {\n            // Caught a render error, provide it as a rejected promise\n            status = $6352571d8ae2d252$var$AwaitRenderStatus.error;\n            let renderError = this.state.error;\n            promise = Promise.reject().catch(()=>{}); // Avoid unhandled rejection warnings\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>renderError\n            });\n        } else if (resolve._tracked) {\n            // Already tracked promise - check contents\n            promise = resolve;\n            status = promise._error !== undefined ? $6352571d8ae2d252$var$AwaitRenderStatus.error : promise._data !== undefined ? $6352571d8ae2d252$var$AwaitRenderStatus.success : $6352571d8ae2d252$var$AwaitRenderStatus.pending;\n        } else {\n            // Raw (untracked) promise - track it\n            status = $6352571d8ae2d252$var$AwaitRenderStatus.pending;\n            Object.defineProperty(resolve, \"_tracked\", {\n                get: ()=>true\n            });\n            promise = resolve.then((data)=>Object.defineProperty(resolve, \"_data\", {\n                    get: ()=>data\n                }), (error)=>Object.defineProperty(resolve, \"_error\", {\n                    get: ()=>error\n                }));\n        }\n        if (status === $6352571d8ae2d252$var$AwaitRenderStatus.error && promise._error instanceof (0, $bZ2h6.AbortedDeferredError)) // Freeze the UI by throwing a never resolved promise\n        throw $6352571d8ae2d252$var$neverSettledPromise;\n        if (status === $6352571d8ae2d252$var$AwaitRenderStatus.error && !errorElement) // No errorElement, throw to the nearest route-level error boundary\n        throw promise._error;\n        if (status === $6352571d8ae2d252$var$AwaitRenderStatus.error) // Render via our errorElement\n        return /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$var$AwaitContext.Provider, {\n            value: promise,\n            children: errorElement\n        });\n        if (status === $6352571d8ae2d252$var$AwaitRenderStatus.success) // Render children with resolved value\n        return /*#__PURE__*/ $5kUFm.createElement($6352571d8ae2d252$var$AwaitContext.Provider, {\n            value: promise,\n            children: children\n        });\n        // Throw to the suspense boundary\n        throw promise;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            error: null\n        };\n    }\n}\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on <Await>\n */ function $6352571d8ae2d252$var$ResolveAwait(_ref8) {\n    let { children: children } = _ref8;\n    let data = $6352571d8ae2d252$export$78a72ddb39bdd145();\n    let toRender = typeof children === \"function\" ? children(data) : children;\n    return /*#__PURE__*/ $5kUFm.createElement($5kUFm.Fragment, null, toRender);\n}\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/utils/create-routes-from-children\n */ function $6352571d8ae2d252$export$16da398f5434bdec(children, parentPath) {\n    if (parentPath === void 0) parentPath = [];\n    let routes = [];\n    $5kUFm.Children.forEach(children, (element, index)=>{\n        if (!/*#__PURE__*/ $5kUFm.isValidElement(element)) // Ignore non-elements. This allows people to more easily inline\n        // conditionals in their route config.\n        return;\n        let treePath = [\n            ...parentPath,\n            index\n        ];\n        if (element.type === $5kUFm.Fragment) {\n            // Transparently support React.Fragment and its children.\n            routes.push.apply(routes, $6352571d8ae2d252$export$16da398f5434bdec(element.props.children, treePath));\n            return;\n        }\n        !(element.type === $6352571d8ae2d252$export$e7b0ac011bb776c6) && (0, $bZ2h6.UNSAFE_invariant)(false);\n        !(!element.props.index || !element.props.children) && (0, $bZ2h6.UNSAFE_invariant)(false);\n        let route = {\n            id: element.props.id || treePath.join(\"-\"),\n            caseSensitive: element.props.caseSensitive,\n            element: element.props.element,\n            Component: element.props.Component,\n            index: element.props.index,\n            path: element.props.path,\n            loader: element.props.loader,\n            action: element.props.action,\n            errorElement: element.props.errorElement,\n            ErrorBoundary: element.props.ErrorBoundary,\n            hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n            shouldRevalidate: element.props.shouldRevalidate,\n            handle: element.props.handle,\n            lazy: element.props.lazy\n        };\n        if (element.props.children) route.children = $6352571d8ae2d252$export$16da398f5434bdec(element.props.children, treePath);\n        routes.push(route);\n    });\n    return routes;\n}\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */ function $6352571d8ae2d252$export$daf73786167a7f72(matches) {\n    return $6352571d8ae2d252$var$_renderMatches(matches);\n}\nfunction $6352571d8ae2d252$export$52b333d321859367(route) {\n    let updates = {\n        // Note: this check also occurs in createRoutesFromChildren so update\n        // there if you change this -- please and thank you!\n        hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n    };\n    if (route.Component) Object.assign(updates, {\n        element: /*#__PURE__*/ $5kUFm.createElement(route.Component),\n        Component: undefined\n    });\n    if (route.ErrorBoundary) Object.assign(updates, {\n        errorElement: /*#__PURE__*/ $5kUFm.createElement(route.ErrorBoundary),\n        ErrorBoundary: undefined\n    });\n    return updates;\n}\nfunction $6352571d8ae2d252$export$f30f7e456d254e83(routes, opts) {\n    return (0, $bZ2h6.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: $6352571d8ae2d252$var$_extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0, $bZ2h6.createMemoryHistory)({\n            initialEntries: opts == null ? void 0 : opts.initialEntries,\n            initialIndex: opts == null ? void 0 : opts.initialIndex\n        }),\n        hydrationData: opts == null ? void 0 : opts.hydrationData,\n        routes: routes,\n        mapRouteProperties: $6352571d8ae2d252$export$52b333d321859367\n    }).initialize();\n}\n\n});\nparcelRequire.register(\"bZ2h6\", function(module, exports) {\n\n$parcel$export(module.exports, \"Action\", () => $8b9727f4386a7666$export$e19cd5f9376f8cee);\n$parcel$export(module.exports, \"createMemoryHistory\", () => $8b9727f4386a7666$export$2b76ad033c6e6d08);\n$parcel$export(module.exports, \"createPath\", () => $8b9727f4386a7666$export$fe53371bee54353d);\n$parcel$export(module.exports, \"parsePath\", () => $8b9727f4386a7666$export$8ccf933b0513f8d0);\n$parcel$export(module.exports, \"createBrowserHistory\", () => $8b9727f4386a7666$export$719fc203c4e16dee);\n$parcel$export(module.exports, \"createHashHistory\", () => $8b9727f4386a7666$export$b71fdd3798280242);\n$parcel$export(module.exports, \"UNSAFE_invariant\", () => $8b9727f4386a7666$export$3e9cee6b33872309);\n$parcel$export(module.exports, \"matchRoutes\", () => $8b9727f4386a7666$export$2708184779ceb39d);\n$parcel$export(module.exports, \"stripBasename\", () => $8b9727f4386a7666$export$b69e3301ce081aa3);\n$parcel$export(module.exports, \"joinPaths\", () => $8b9727f4386a7666$export$86d9a7913e44197e);\n$parcel$export(module.exports, \"matchPath\", () => $8b9727f4386a7666$export$81336c211d5ff295);\n$parcel$export(module.exports, \"generatePath\", () => $8b9727f4386a7666$export$82476f982757e71e);\n$parcel$export(module.exports, \"resolvePath\", () => $8b9727f4386a7666$export$b09f2ff0bbcb43c7);\n$parcel$export(module.exports, \"UNSAFE_getPathContributingMatches\", () => $8b9727f4386a7666$export$90ba53ce1c7fdff2);\n$parcel$export(module.exports, \"resolveTo\", () => $8b9727f4386a7666$export$cae722b0cc860f13);\n$parcel$export(module.exports, \"json\", () => $8b9727f4386a7666$export$7b419323e6ed4f31);\n$parcel$export(module.exports, \"AbortedDeferredError\", () => $8b9727f4386a7666$export$42a99a7a4bc0e76a);\n$parcel$export(module.exports, \"defer\", () => $8b9727f4386a7666$export$260e5c0943f31606);\n$parcel$export(module.exports, \"redirect\", () => $8b9727f4386a7666$export$89e12c5b50f7529d);\n$parcel$export(module.exports, \"ErrorResponse\", () => $8b9727f4386a7666$export$acf1a680051f5031);\n$parcel$export(module.exports, \"isRouteErrorResponse\", () => $8b9727f4386a7666$export$972111febbeef05b);\n$parcel$export(module.exports, \"IDLE_BLOCKER\", () => $8b9727f4386a7666$export$386d57f03f0b2883);\n$parcel$export(module.exports, \"createRouter\", () => $8b9727f4386a7666$export$baddd0131ee8c05b);\n/**\n * @remix-run/router v1.7.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ function $8b9727f4386a7666$var$_extends() {\n    $8b9727f4386a7666$var$_extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];\n        }\n        return target;\n    };\n    return $8b9727f4386a7666$var$_extends.apply(this, arguments);\n}\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */ var $8b9727f4386a7666$export$e19cd5f9376f8cee;\n(function(Action) {\n    /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */ Action[\"Pop\"] = \"POP\";\n    /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */ Action[\"Push\"] = \"PUSH\";\n    /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */ Action[\"Replace\"] = \"REPLACE\";\n})($8b9727f4386a7666$export$e19cd5f9376f8cee || ($8b9727f4386a7666$export$e19cd5f9376f8cee = {}));\nconst $8b9727f4386a7666$var$PopStateEventType = \"popstate\";\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */ function $8b9727f4386a7666$export$2b76ad033c6e6d08(options) {\n    if (options === void 0) options = {};\n    let { initialEntries: initialEntries = [\n        \"/\"\n    ], initialIndex: initialIndex, v5Compat: v5Compat = false } = options;\n    let entries; // Declare so we can access from createMemoryLocation\n    entries = initialEntries.map((entry, index)=>createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index === 0 ? \"default\" : undefined));\n    let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n    let action = $8b9727f4386a7666$export$e19cd5f9376f8cee.Pop;\n    let listener = null;\n    function clampIndex(n) {\n        return Math.min(Math.max(n, 0), entries.length - 1);\n    }\n    function getCurrentLocation() {\n        return entries[index];\n    }\n    function createMemoryLocation(to, state, key) {\n        if (state === void 0) state = null;\n        let location = $8b9727f4386a7666$var$createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n        $8b9727f4386a7666$export$c0e02632e14916fd(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\n        return location;\n    }\n    function createHref(to) {\n        return typeof to === \"string\" ? to : $8b9727f4386a7666$export$fe53371bee54353d(to);\n    }\n    let history = {\n        get index () {\n            return index;\n        },\n        get action () {\n            return action;\n        },\n        get location () {\n            return getCurrentLocation();\n        },\n        createHref: createHref,\n        createURL (to) {\n            return new URL(createHref(to), \"http://localhost\");\n        },\n        encodeLocation (to) {\n            let path = typeof to === \"string\" ? $8b9727f4386a7666$export$8ccf933b0513f8d0(to) : to;\n            return {\n                pathname: path.pathname || \"\",\n                search: path.search || \"\",\n                hash: path.hash || \"\"\n            };\n        },\n        push (to, state) {\n            action = $8b9727f4386a7666$export$e19cd5f9376f8cee.Push;\n            let nextLocation = createMemoryLocation(to, state);\n            index += 1;\n            entries.splice(index, entries.length, nextLocation);\n            if (v5Compat && listener) listener({\n                action: action,\n                location: nextLocation,\n                delta: 1\n            });\n        },\n        replace (to, state) {\n            action = $8b9727f4386a7666$export$e19cd5f9376f8cee.Replace;\n            let nextLocation = createMemoryLocation(to, state);\n            entries[index] = nextLocation;\n            if (v5Compat && listener) listener({\n                action: action,\n                location: nextLocation,\n                delta: 0\n            });\n        },\n        go (delta) {\n            action = $8b9727f4386a7666$export$e19cd5f9376f8cee.Pop;\n            let nextIndex = clampIndex(index + delta);\n            let nextLocation = entries[nextIndex];\n            index = nextIndex;\n            if (listener) listener({\n                action: action,\n                location: nextLocation,\n                delta: delta\n            });\n        },\n        listen (fn) {\n            listener = fn;\n            return ()=>{\n                listener = null;\n            };\n        }\n    };\n    return history;\n}\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */ function $8b9727f4386a7666$export$719fc203c4e16dee(options) {\n    if (options === void 0) options = {};\n    function createBrowserLocation(window1, globalHistory) {\n        let { pathname: pathname, search: search, hash: hash } = window1.location;\n        return $8b9727f4386a7666$var$createLocation(\"\", {\n            pathname: pathname,\n            search: search,\n            hash: hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createBrowserHref(window1, to) {\n        return typeof to === \"string\" ? to : $8b9727f4386a7666$export$fe53371bee54353d(to);\n    }\n    return $8b9727f4386a7666$var$getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */ function $8b9727f4386a7666$export$b71fdd3798280242(options) {\n    if (options === void 0) options = {};\n    function createHashLocation(window1, globalHistory) {\n        let { pathname: pathname = \"/\", search: search = \"\", hash: hash = \"\" } = $8b9727f4386a7666$export$8ccf933b0513f8d0(window1.location.hash.substr(1));\n        return $8b9727f4386a7666$var$createLocation(\"\", {\n            pathname: pathname,\n            search: search,\n            hash: hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createHashHref(window1, to) {\n        let base = window1.document.querySelector(\"base\");\n        let href = \"\";\n        if (base && base.getAttribute(\"href\")) {\n            let url = window1.location.href;\n            let hashIndex = url.indexOf(\"#\");\n            href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n        }\n        return href + \"#\" + (typeof to === \"string\" ? to : $8b9727f4386a7666$export$fe53371bee54353d(to));\n    }\n    function validateHashLocation(location, to) {\n        $8b9727f4386a7666$export$c0e02632e14916fd(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\n    }\n    return $8b9727f4386a7666$var$getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction $8b9727f4386a7666$export$3e9cee6b33872309(value, message) {\n    if (value === false || value === null || typeof value === \"undefined\") throw new Error(message);\n}\nfunction $8b9727f4386a7666$export$c0e02632e14916fd(cond, message) {\n    if (!cond) {\n        // eslint-disable-next-line no-console\n        if (typeof console !== \"undefined\") console.warn(message);\n        try {\n            // Welcome to debugging history!\n            //\n            // This error is thrown as a convenience so you can more easily\n            // find the source for a warning that appears in the console by\n            // enabling \"pause on exceptions\" in your JavaScript debugger.\n            throw new Error(message);\n        // eslint-disable-next-line no-empty\n        } catch (e) {}\n    }\n}\nfunction $8b9727f4386a7666$var$createKey() {\n    return Math.random().toString(36).substr(2, 8);\n}\n/**\n * For browser-based histories, we combine the state and key into an object\n */ function $8b9727f4386a7666$var$getHistoryState(location, index) {\n    return {\n        usr: location.state,\n        key: location.key,\n        idx: index\n    };\n}\n/**\n * Creates a Location object with a unique key from the given Path\n */ function $8b9727f4386a7666$var$createLocation(current, to, state, key) {\n    if (state === void 0) state = null;\n    let location = $8b9727f4386a7666$var$_extends({\n        pathname: typeof current === \"string\" ? current : current.pathname,\n        search: \"\",\n        hash: \"\"\n    }, typeof to === \"string\" ? $8b9727f4386a7666$export$8ccf933b0513f8d0(to) : to, {\n        state: state,\n        // TODO: This could be cleaned up.  push/replace should probably just take\n        // full Locations now and avoid the need to run through this flow at all\n        // But that's a pretty big refactor to the current test suite so going to\n        // keep as is for the time being and just let any incoming keys take precedence\n        key: to && to.key || key || $8b9727f4386a7666$var$createKey()\n    });\n    return location;\n}\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */ function $8b9727f4386a7666$export$fe53371bee54353d(_ref) {\n    let { pathname: pathname = \"/\", search: search = \"\", hash: hash = \"\" } = _ref;\n    if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n    if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n    return pathname;\n}\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */ function $8b9727f4386a7666$export$8ccf933b0513f8d0(path) {\n    let parsedPath = {};\n    if (path) {\n        let hashIndex = path.indexOf(\"#\");\n        if (hashIndex >= 0) {\n            parsedPath.hash = path.substr(hashIndex);\n            path = path.substr(0, hashIndex);\n        }\n        let searchIndex = path.indexOf(\"?\");\n        if (searchIndex >= 0) {\n            parsedPath.search = path.substr(searchIndex);\n            path = path.substr(0, searchIndex);\n        }\n        if (path) parsedPath.pathname = path;\n    }\n    return parsedPath;\n}\nfunction $8b9727f4386a7666$var$getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n    if (options === void 0) options = {};\n    let { window: window1 = document.defaultView, v5Compat: v5Compat = false } = options;\n    let globalHistory = window1.history;\n    let action = $8b9727f4386a7666$export$e19cd5f9376f8cee.Pop;\n    let listener = null;\n    let index = getIndex();\n    // Index should only be null when we initialize. If not, it's because the\n    // user called history.pushState or history.replaceState directly, in which\n    // case we should log a warning as it will result in bugs.\n    if (index == null) {\n        index = 0;\n        globalHistory.replaceState($8b9727f4386a7666$var$_extends({}, globalHistory.state, {\n            idx: index\n        }), \"\");\n    }\n    function getIndex() {\n        let state = globalHistory.state || {\n            idx: null\n        };\n        return state.idx;\n    }\n    function handlePop() {\n        action = $8b9727f4386a7666$export$e19cd5f9376f8cee.Pop;\n        let nextIndex = getIndex();\n        let delta = nextIndex == null ? null : nextIndex - index;\n        index = nextIndex;\n        if (listener) listener({\n            action: action,\n            location: history.location,\n            delta: delta\n        });\n    }\n    function push(to, state) {\n        action = $8b9727f4386a7666$export$e19cd5f9376f8cee.Push;\n        let location = $8b9727f4386a7666$var$createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex() + 1;\n        let historyState = $8b9727f4386a7666$var$getHistoryState(location, index);\n        let url = history.createHref(location);\n        // try...catch because iOS limits us to 100 pushState calls :/\n        try {\n            globalHistory.pushState(historyState, \"\", url);\n        } catch (error) {\n            // If the exception is because `state` can't be serialized, let that throw\n            // outwards just like a replace call would so the dev knows the cause\n            // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n            // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n            if (error instanceof DOMException && error.name === \"DataCloneError\") throw error;\n            // They are going to lose state here, but there is no real\n            // way to warn them about it since the page will refresh...\n            window1.location.assign(url);\n        }\n        if (v5Compat && listener) listener({\n            action: action,\n            location: history.location,\n            delta: 1\n        });\n    }\n    function replace(to, state) {\n        action = $8b9727f4386a7666$export$e19cd5f9376f8cee.Replace;\n        let location = $8b9727f4386a7666$var$createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex();\n        let historyState = $8b9727f4386a7666$var$getHistoryState(location, index);\n        let url = history.createHref(location);\n        globalHistory.replaceState(historyState, \"\", url);\n        if (v5Compat && listener) listener({\n            action: action,\n            location: history.location,\n            delta: 0\n        });\n    }\n    function createURL(to) {\n        // window.location.origin is \"null\" (the literal string value) in Firefox\n        // under certain conditions, notably when serving from a local HTML file\n        // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n        let base = window1.location.origin !== \"null\" ? window1.location.origin : window1.location.href;\n        let href = typeof to === \"string\" ? to : $8b9727f4386a7666$export$fe53371bee54353d(to);\n        $8b9727f4386a7666$export$3e9cee6b33872309(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\n        return new URL(href, base);\n    }\n    let history = {\n        get action () {\n            return action;\n        },\n        get location () {\n            return getLocation(window1, globalHistory);\n        },\n        listen (fn) {\n            if (listener) throw new Error(\"A history only accepts one active listener\");\n            window1.addEventListener($8b9727f4386a7666$var$PopStateEventType, handlePop);\n            listener = fn;\n            return ()=>{\n                window1.removeEventListener($8b9727f4386a7666$var$PopStateEventType, handlePop);\n                listener = null;\n            };\n        },\n        createHref (to) {\n            return createHref(window1, to);\n        },\n        createURL: createURL,\n        encodeLocation (to) {\n            // Encode a Location the same way window.location would\n            let url = createURL(to);\n            return {\n                pathname: url.pathname,\n                search: url.search,\n                hash: url.hash\n            };\n        },\n        push: push,\n        replace: replace,\n        go (n) {\n            return globalHistory.go(n);\n        }\n    };\n    return history;\n}\n//#endregion\nvar $8b9727f4386a7666$var$ResultType;\n(function(ResultType) {\n    ResultType[\"data\"] = \"data\";\n    ResultType[\"deferred\"] = \"deferred\";\n    ResultType[\"redirect\"] = \"redirect\";\n    ResultType[\"error\"] = \"error\";\n})($8b9727f4386a7666$var$ResultType || ($8b9727f4386a7666$var$ResultType = {}));\nconst $8b9727f4386a7666$var$immutableRouteKeys = new Set([\n    \"lazy\",\n    \"caseSensitive\",\n    \"path\",\n    \"id\",\n    \"index\",\n    \"children\"\n]);\nfunction $8b9727f4386a7666$var$isIndexRoute(route) {\n    return route.index === true;\n}\n// Walk the route tree generating unique IDs where necessary so we are working\n// solely with AgnosticDataRouteObject's within the Router\nfunction $8b9727f4386a7666$export$4a6d22b32134ea5d(routes, mapRouteProperties, parentPath, manifest) {\n    if (parentPath === void 0) parentPath = [];\n    if (manifest === void 0) manifest = {};\n    return routes.map((route, index)=>{\n        let treePath = [\n            ...parentPath,\n            index\n        ];\n        let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n        $8b9727f4386a7666$export$3e9cee6b33872309(route.index !== true || !route.children, \"Cannot specify children on an index route\");\n        $8b9727f4386a7666$export$3e9cee6b33872309(!manifest[id], 'Found a route id collision on id \"' + id + '\".  Route ' + \"id's must be globally unique within Data Router usages\");\n        if ($8b9727f4386a7666$var$isIndexRoute(route)) {\n            let indexRoute = $8b9727f4386a7666$var$_extends({}, route, mapRouteProperties(route), {\n                id: id\n            });\n            manifest[id] = indexRoute;\n            return indexRoute;\n        } else {\n            let pathOrLayoutRoute = $8b9727f4386a7666$var$_extends({}, route, mapRouteProperties(route), {\n                id: id,\n                children: undefined\n            });\n            manifest[id] = pathOrLayoutRoute;\n            if (route.children) pathOrLayoutRoute.children = $8b9727f4386a7666$export$4a6d22b32134ea5d(route.children, mapRouteProperties, treePath, manifest);\n            return pathOrLayoutRoute;\n        }\n    });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */ function $8b9727f4386a7666$export$2708184779ceb39d(routes, locationArg, basename) {\n    if (basename === void 0) basename = \"/\";\n    let location = typeof locationArg === \"string\" ? $8b9727f4386a7666$export$8ccf933b0513f8d0(locationArg) : locationArg;\n    let pathname = $8b9727f4386a7666$export$b69e3301ce081aa3(location.pathname || \"/\", basename);\n    if (pathname == null) return null;\n    let branches = $8b9727f4386a7666$var$flattenRoutes(routes);\n    $8b9727f4386a7666$var$rankRouteBranches(branches);\n    let matches = null;\n    for(let i = 0; matches == null && i < branches.length; ++i)matches = $8b9727f4386a7666$var$matchRouteBranch(branches[i], // Incoming pathnames are generally encoded from either window.location\n    // or from router.navigate, but we want to match against the unencoded\n    // paths in the route definitions.  Memory router locations won't be\n    // encoded here but there also shouldn't be anything to decode so this\n    // should be a safe operation.  This avoids needing matchRoutes to be\n    // history-aware.\n    $8b9727f4386a7666$var$safelyDecodeURI(pathname));\n    return matches;\n}\nfunction $8b9727f4386a7666$var$flattenRoutes(routes, branches, parentsMeta, parentPath) {\n    if (branches === void 0) branches = [];\n    if (parentsMeta === void 0) parentsMeta = [];\n    if (parentPath === void 0) parentPath = \"\";\n    let flattenRoute = (route, index, relativePath)=>{\n        let meta = {\n            relativePath: relativePath === undefined ? route.path || \"\" : relativePath,\n            caseSensitive: route.caseSensitive === true,\n            childrenIndex: index,\n            route: route\n        };\n        if (meta.relativePath.startsWith(\"/\")) {\n            $8b9727f4386a7666$export$3e9cee6b33872309(meta.relativePath.startsWith(parentPath), 'Absolute route path \"' + meta.relativePath + '\" nested under path ' + ('\"' + parentPath + '\" is not valid. An absolute child route path ') + \"must start with the combined path of all its parent routes.\");\n            meta.relativePath = meta.relativePath.slice(parentPath.length);\n        }\n        let path = $8b9727f4386a7666$export$86d9a7913e44197e([\n            parentPath,\n            meta.relativePath\n        ]);\n        let routesMeta = parentsMeta.concat(meta);\n        // Add the children before adding this route to the array so we traverse the\n        // route tree depth-first and child routes appear before their parents in\n        // the \"flattened\" version.\n        if (route.children && route.children.length > 0) {\n            $8b9727f4386a7666$export$3e9cee6b33872309(// Our types know better, but runtime JS may not!\n            // @ts-expect-error\n            route.index !== true, \"Index routes must not have child routes. Please remove \" + ('all child routes from route path \"' + path + '\".'));\n            $8b9727f4386a7666$var$flattenRoutes(route.children, branches, routesMeta, path);\n        }\n        // Routes without a path shouldn't ever match by themselves unless they are\n        // index routes, so don't add them to the list of possible branches.\n        if (route.path == null && !route.index) return;\n        branches.push({\n            path: path,\n            score: $8b9727f4386a7666$var$computeScore(path, route.index),\n            routesMeta: routesMeta\n        });\n    };\n    routes.forEach((route, index)=>{\n        var _route$path;\n        // coarse-grain check for optional params\n        if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) flattenRoute(route, index);\n        else for (let exploded of $8b9727f4386a7666$var$explodeOptionalSegments(route.path))flattenRoute(route, index, exploded);\n    });\n    return branches;\n}\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */ function $8b9727f4386a7666$var$explodeOptionalSegments(path) {\n    let segments = path.split(\"/\");\n    if (segments.length === 0) return [];\n    let [first, ...rest] = segments;\n    // Optional path segments are denoted by a trailing `?`\n    let isOptional = first.endsWith(\"?\");\n    // Compute the corresponding required segment: `foo?` -> `foo`\n    let required = first.replace(/\\?$/, \"\");\n    if (rest.length === 0) // Intepret empty string as omitting an optional segment\n    // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n    return isOptional ? [\n        required,\n        \"\"\n    ] : [\n        required\n    ];\n    let restExploded = $8b9727f4386a7666$var$explodeOptionalSegments(rest.join(\"/\"));\n    let result = [];\n    // All child paths with the prefix.  Do this for all children before the\n    // optional version for all children so we get consistent ordering where the\n    // parent optional aspect is preferred as required.  Otherwise, we can get\n    // child sections interspersed where deeper optional segments are higher than\n    // parent optional segments, where for example, /:two would explodes _earlier_\n    // then /:one.  By always including the parent as required _for all children_\n    // first, we avoid this issue\n    result.push(...restExploded.map((subpath)=>subpath === \"\" ? required : [\n            required,\n            subpath\n        ].join(\"/\")));\n    // Then if this is an optional value, add all child versions without\n    if (isOptional) result.push(...restExploded);\n    // for absolute paths, ensure `/` instead of empty segment\n    return result.map((exploded)=>path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction $8b9727f4386a7666$var$rankRouteBranches(branches) {\n    branches.sort((a, b)=>a.score !== b.score ? b.score - a.score // Higher score first\n         : $8b9727f4386a7666$var$compareIndexes(a.routesMeta.map((meta)=>meta.childrenIndex), b.routesMeta.map((meta)=>meta.childrenIndex)));\n}\nconst $8b9727f4386a7666$var$paramRe = /^:\\w+$/;\nconst $8b9727f4386a7666$var$dynamicSegmentValue = 3;\nconst $8b9727f4386a7666$var$indexRouteValue = 2;\nconst $8b9727f4386a7666$var$emptySegmentValue = 1;\nconst $8b9727f4386a7666$var$staticSegmentValue = 10;\nconst $8b9727f4386a7666$var$splatPenalty = -2;\nconst $8b9727f4386a7666$var$isSplat = (s)=>s === \"*\";\nfunction $8b9727f4386a7666$var$computeScore(path, index) {\n    let segments = path.split(\"/\");\n    let initialScore = segments.length;\n    if (segments.some($8b9727f4386a7666$var$isSplat)) initialScore += $8b9727f4386a7666$var$splatPenalty;\n    if (index) initialScore += $8b9727f4386a7666$var$indexRouteValue;\n    return segments.filter((s)=>!$8b9727f4386a7666$var$isSplat(s)).reduce((score, segment)=>score + ($8b9727f4386a7666$var$paramRe.test(segment) ? $8b9727f4386a7666$var$dynamicSegmentValue : segment === \"\" ? $8b9727f4386a7666$var$emptySegmentValue : $8b9727f4386a7666$var$staticSegmentValue), initialScore);\n}\nfunction $8b9727f4386a7666$var$compareIndexes(a, b) {\n    let siblings = a.length === b.length && a.slice(0, -1).every((n, i)=>n === b[i]);\n    return siblings ? // If two routes are siblings, we should try to match the earlier sibling\n    // first. This allows people to have fine-grained control over the matching\n    // behavior by simply putting routes with identical paths in the order they\n    // want them tried.\n    a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n    // so they sort equally.\n    0;\n}\nfunction $8b9727f4386a7666$var$matchRouteBranch(branch, pathname) {\n    let { routesMeta: routesMeta } = branch;\n    let matchedParams = {};\n    let matchedPathname = \"/\";\n    let matches = [];\n    for(let i = 0; i < routesMeta.length; ++i){\n        let meta = routesMeta[i];\n        let end = i === routesMeta.length - 1;\n        let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n        let match = $8b9727f4386a7666$export$81336c211d5ff295({\n            path: meta.relativePath,\n            caseSensitive: meta.caseSensitive,\n            end: end\n        }, remainingPathname);\n        if (!match) return null;\n        Object.assign(matchedParams, match.params);\n        let route = meta.route;\n        matches.push({\n            // TODO: Can this as be avoided?\n            params: matchedParams,\n            pathname: $8b9727f4386a7666$export$86d9a7913e44197e([\n                matchedPathname,\n                match.pathname\n            ]),\n            pathnameBase: $8b9727f4386a7666$export$a5c6d149b50c1d86($8b9727f4386a7666$export$86d9a7913e44197e([\n                matchedPathname,\n                match.pathnameBase\n            ])),\n            route: route\n        });\n        if (match.pathnameBase !== \"/\") matchedPathname = $8b9727f4386a7666$export$86d9a7913e44197e([\n            matchedPathname,\n            match.pathnameBase\n        ]);\n    }\n    return matches;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */ function $8b9727f4386a7666$export$82476f982757e71e(originalPath, params) {\n    if (params === void 0) params = {};\n    let path = originalPath;\n    if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n        $8b9727f4386a7666$export$c0e02632e14916fd(false, 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n        path = path.replace(/\\*$/, \"/*\");\n    }\n    // ensure `/` is added at the beginning if the path is absolute\n    const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n    const stringify = (p)=>p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n    const segments = path.split(/\\/+/).map((segment, index, array)=>{\n        const isLastSegment = index === array.length - 1;\n        // only apply the splat if it's the last segment\n        if (isLastSegment && segment === \"*\") {\n            const star = \"*\";\n            // Apply the splat\n            return stringify(params[star]);\n        }\n        const keyMatch = segment.match(/^:(\\w+)(\\??)$/);\n        if (keyMatch) {\n            const [, key, optional] = keyMatch;\n            let param = params[key];\n            $8b9727f4386a7666$export$3e9cee6b33872309(optional === \"?\" || param != null, 'Missing \":' + key + '\" param');\n            return stringify(param);\n        }\n        // Remove any optional markers from optional static segments\n        return segment.replace(/\\?$/g, \"\");\n    })// Remove empty segments\n    .filter((segment)=>!!segment);\n    return prefix + segments.join(\"/\");\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */ function $8b9727f4386a7666$export$81336c211d5ff295(pattern, pathname) {\n    if (typeof pattern === \"string\") pattern = {\n        path: pattern,\n        caseSensitive: false,\n        end: true\n    };\n    let [matcher, paramNames] = $8b9727f4386a7666$var$compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n    let match = pathname.match(matcher);\n    if (!match) return null;\n    let matchedPathname = match[0];\n    let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n    let captureGroups = match.slice(1);\n    let params = paramNames.reduce((memo, paramName, index)=>{\n        // We need to compute the pathnameBase here using the raw splat value\n        // instead of using params[\"*\"] later because it will be decoded then\n        if (paramName === \"*\") {\n            let splatValue = captureGroups[index] || \"\";\n            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n        }\n        memo[paramName] = $8b9727f4386a7666$var$safelyDecodeURIComponent(captureGroups[index] || \"\", paramName);\n        return memo;\n    }, {});\n    return {\n        params: params,\n        pathname: matchedPathname,\n        pathnameBase: pathnameBase,\n        pattern: pattern\n    };\n}\nfunction $8b9727f4386a7666$var$compilePath(path, caseSensitive, end) {\n    if (caseSensitive === void 0) caseSensitive = false;\n    if (end === void 0) end = true;\n    $8b9727f4386a7666$export$c0e02632e14916fd(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n    let paramNames = [];\n    let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n    .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n    .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n    .replace(/\\/:(\\w+)/g, (_, paramName)=>{\n        paramNames.push(paramName);\n        return \"/([^\\\\/]+)\";\n    });\n    if (path.endsWith(\"*\")) {\n        paramNames.push(\"*\");\n        regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\n         : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n    } else if (end) // When matching to the end, ignore trailing slashes\n    regexpSource += \"\\\\/*$\";\n    else if (path !== \"\" && path !== \"/\") // If our path is non-empty and contains anything beyond an initial slash,\n    // then we have _some_ form of path in our regex so we should expect to\n    // match only if we find the end of this path segment.  Look for an optional\n    // non-captured trailing slash (to match a portion of the URL) or the end\n    // of the path (if we've matched to the end).  We used to do this with a\n    // word boundary but that gives false positives on routes like\n    // /user-preferences since `-` counts as a word boundary.\n    regexpSource += \"(?:(?=\\\\/|$))\";\n    let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n    return [\n        matcher,\n        paramNames\n    ];\n}\nfunction $8b9727f4386a7666$var$safelyDecodeURI(value) {\n    try {\n        return decodeURI(value);\n    } catch (error) {\n        $8b9727f4386a7666$export$c0e02632e14916fd(false, 'The URL path \"' + value + '\" could not be decoded because it is is a ' + \"malformed URL segment. This is probably due to a bad percent \" + (\"encoding (\" + error + \").\"));\n        return value;\n    }\n}\nfunction $8b9727f4386a7666$var$safelyDecodeURIComponent(value, paramName) {\n    try {\n        return decodeURIComponent(value);\n    } catch (error) {\n        $8b9727f4386a7666$export$c0e02632e14916fd(false, 'The value for the URL param \"' + paramName + '\" will not be decoded because' + (' the string \"' + value + '\" is a malformed URL segment. This is probably') + (\" due to a bad percent encoding (\" + error + \").\"));\n        return value;\n    }\n}\n/**\n * @private\n */ function $8b9727f4386a7666$export$b69e3301ce081aa3(pathname, basename) {\n    if (basename === \"/\") return pathname;\n    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) return null;\n    // We want to leave trailing slash behavior in the user's control, so if they\n    // specify a basename with a trailing slash, we should support it\n    let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n    let nextChar = pathname.charAt(startIndex);\n    if (nextChar && nextChar !== \"/\") // pathname does not start with basename/\n    return null;\n    return pathname.slice(startIndex) || \"/\";\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */ function $8b9727f4386a7666$export$b09f2ff0bbcb43c7(to, fromPathname) {\n    if (fromPathname === void 0) fromPathname = \"/\";\n    let { pathname: toPathname, search: search = \"\", hash: hash = \"\" } = typeof to === \"string\" ? $8b9727f4386a7666$export$8ccf933b0513f8d0(to) : to;\n    let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : $8b9727f4386a7666$var$resolvePathname(toPathname, fromPathname) : fromPathname;\n    return {\n        pathname: pathname,\n        search: $8b9727f4386a7666$var$normalizeSearch(search),\n        hash: $8b9727f4386a7666$var$normalizeHash(hash)\n    };\n}\nfunction $8b9727f4386a7666$var$resolvePathname(relativePath, fromPathname) {\n    let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n    let relativeSegments = relativePath.split(\"/\");\n    relativeSegments.forEach((segment)=>{\n        if (segment === \"..\") // Keep the root \"\" segment so the pathname starts at /\n        {\n            if (segments.length > 1) segments.pop();\n        } else if (segment !== \".\") segments.push(segment);\n    });\n    return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction $8b9727f4386a7666$var$getInvalidPathError(char, field, dest, path) {\n    return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + 'a string in <Link to=\"...\"> and the router will parse it for you.';\n}\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */ function $8b9727f4386a7666$export$90ba53ce1c7fdff2(matches) {\n    return matches.filter((match, index)=>index === 0 || match.route.path && match.route.path.length > 0);\n}\n/**\n * @private\n */ function $8b9727f4386a7666$export$cae722b0cc860f13(toArg, routePathnames, locationPathname, isPathRelative) {\n    if (isPathRelative === void 0) isPathRelative = false;\n    let to;\n    if (typeof toArg === \"string\") to = $8b9727f4386a7666$export$8ccf933b0513f8d0(toArg);\n    else {\n        to = $8b9727f4386a7666$var$_extends({}, toArg);\n        $8b9727f4386a7666$export$3e9cee6b33872309(!to.pathname || !to.pathname.includes(\"?\"), $8b9727f4386a7666$var$getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n        $8b9727f4386a7666$export$3e9cee6b33872309(!to.pathname || !to.pathname.includes(\"#\"), $8b9727f4386a7666$var$getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n        $8b9727f4386a7666$export$3e9cee6b33872309(!to.search || !to.search.includes(\"#\"), $8b9727f4386a7666$var$getInvalidPathError(\"#\", \"search\", \"hash\", to));\n    }\n    let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n    let toPathname = isEmptyPath ? \"/\" : to.pathname;\n    let from;\n    // Routing is relative to the current pathname if explicitly requested.\n    //\n    // If a pathname is explicitly provided in `to`, it should be relative to the\n    // route context. This is explained in `Note on `<Link to>` values` in our\n    // migration guide from v5 as a means of disambiguation between `to` values\n    // that begin with `/` and those that do not. However, this is problematic for\n    // `to` values that do not provide a pathname. `to` can simply be a search or\n    // hash string, in which case we should assume that the navigation is relative\n    // to the current location's pathname and *not* the route pathname.\n    if (isPathRelative || toPathname == null) from = locationPathname;\n    else {\n        let routePathnameIndex = routePathnames.length - 1;\n        if (toPathname.startsWith(\"..\")) {\n            let toSegments = toPathname.split(\"/\");\n            // Each leading .. segment means \"go up one route\" instead of \"go up one\n            // URL segment\".  This is a key difference from how <a href> works and a\n            // major reason we call this a \"to\" value instead of a \"href\".\n            while(toSegments[0] === \"..\"){\n                toSegments.shift();\n                routePathnameIndex -= 1;\n            }\n            to.pathname = toSegments.join(\"/\");\n        }\n        // If there are more \"..\" segments than parent routes, resolve relative to\n        // the root / URL.\n        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n    }\n    let path = $8b9727f4386a7666$export$b09f2ff0bbcb43c7(to, from);\n    // Ensure the pathname has a trailing slash if the original \"to\" had one\n    let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n    // Or if this was a link to the current path which has a trailing slash\n    let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n    if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) path.pathname += \"/\";\n    return path;\n}\n/**\n * @private\n */ function $8b9727f4386a7666$export$f5655dfea9d981c7(to) {\n    // Empty strings should be treated the same as / paths\n    return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? $8b9727f4386a7666$export$8ccf933b0513f8d0(to).pathname : to.pathname;\n}\n/**\n * @private\n */ const $8b9727f4386a7666$export$86d9a7913e44197e = (paths)=>paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n/**\n * @private\n */ const $8b9727f4386a7666$export$a5c6d149b50c1d86 = (pathname)=>pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n/**\n * @private\n */ const $8b9727f4386a7666$var$normalizeSearch = (search)=>!search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n/**\n * @private\n */ const $8b9727f4386a7666$var$normalizeHash = (hash)=>!hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */ const $8b9727f4386a7666$export$7b419323e6ed4f31 = function json(data, init) {\n    if (init === void 0) init = {};\n    let responseInit = typeof init === \"number\" ? {\n        status: init\n    } : init;\n    let headers = new Headers(responseInit.headers);\n    if (!headers.has(\"Content-Type\")) headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n    return new Response(JSON.stringify(data), $8b9727f4386a7666$var$_extends({}, responseInit, {\n        headers: headers\n    }));\n};\nclass $8b9727f4386a7666$export$42a99a7a4bc0e76a extends Error {\n}\nclass $8b9727f4386a7666$export$61d759255b4eec65 {\n    trackPromise(key, value) {\n        if (!(value instanceof Promise)) return value;\n        this.deferredKeys.push(key);\n        this.pendingKeysSet.add(key);\n        // We store a little wrapper promise that will be extended with\n        // _data/_error props upon resolve/reject\n        let promise = Promise.race([\n            value,\n            this.abortPromise\n        ]).then((data)=>this.onSettle(promise, key, undefined, data), (error)=>this.onSettle(promise, key, error));\n        // Register rejection listeners to avoid uncaught promise rejections on\n        // errors or aborted deferred values\n        promise.catch(()=>{});\n        Object.defineProperty(promise, \"_tracked\", {\n            get: ()=>true\n        });\n        return promise;\n    }\n    onSettle(promise, key, error, data) {\n        if (this.controller.signal.aborted && error instanceof $8b9727f4386a7666$export$42a99a7a4bc0e76a) {\n            this.unlistenAbortSignal();\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>error\n            });\n            return Promise.reject(error);\n        }\n        this.pendingKeysSet.delete(key);\n        if (this.done) // Nothing left to abort!\n        this.unlistenAbortSignal();\n        // If the promise was resolved/rejected with undefined, we'll throw an error as you\n        // should always resolve with a value or null\n        if (error === undefined && data === undefined) {\n            let undefinedError = new Error('Deferred data for key \"' + key + '\" resolved/rejected with `undefined`, ' + \"you must resolve/reject with a value or `null`.\");\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>undefinedError\n            });\n            this.emit(false, key);\n            return Promise.reject(undefinedError);\n        }\n        if (data === undefined) {\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>error\n            });\n            this.emit(false, key);\n            return Promise.reject(error);\n        }\n        Object.defineProperty(promise, \"_data\", {\n            get: ()=>data\n        });\n        this.emit(false, key);\n        return data;\n    }\n    emit(aborted, settledKey) {\n        this.subscribers.forEach((subscriber)=>subscriber(aborted, settledKey));\n    }\n    subscribe(fn) {\n        this.subscribers.add(fn);\n        return ()=>this.subscribers.delete(fn);\n    }\n    cancel() {\n        this.controller.abort();\n        this.pendingKeysSet.forEach((v, k)=>this.pendingKeysSet.delete(k));\n        this.emit(true);\n    }\n    async resolveData(signal) {\n        let aborted = false;\n        if (!this.done) {\n            let onAbort = ()=>this.cancel();\n            signal.addEventListener(\"abort\", onAbort);\n            aborted = await new Promise((resolve)=>{\n                this.subscribe((aborted)=>{\n                    signal.removeEventListener(\"abort\", onAbort);\n                    if (aborted || this.done) resolve(aborted);\n                });\n            });\n        }\n        return aborted;\n    }\n    get done() {\n        return this.pendingKeysSet.size === 0;\n    }\n    get unwrappedData() {\n        $8b9727f4386a7666$export$3e9cee6b33872309(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\n        return Object.entries(this.data).reduce((acc, _ref2)=>{\n            let [key, value] = _ref2;\n            return Object.assign(acc, {\n                [key]: $8b9727f4386a7666$var$unwrapTrackedPromise(value)\n            });\n        }, {});\n    }\n    get pendingKeys() {\n        return Array.from(this.pendingKeysSet);\n    }\n    constructor(data, responseInit){\n        this.pendingKeysSet = new Set();\n        this.subscribers = new Set();\n        this.deferredKeys = [];\n        $8b9727f4386a7666$export$3e9cee6b33872309(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\");\n        // Set up an AbortController + Promise we can race against to exit early\n        // cancellation\n        let reject;\n        this.abortPromise = new Promise((_, r)=>reject = r);\n        this.controller = new AbortController();\n        let onAbort = ()=>reject(new $8b9727f4386a7666$export$42a99a7a4bc0e76a(\"Deferred data aborted\"));\n        this.unlistenAbortSignal = ()=>this.controller.signal.removeEventListener(\"abort\", onAbort);\n        this.controller.signal.addEventListener(\"abort\", onAbort);\n        this.data = Object.entries(data).reduce((acc, _ref)=>{\n            let [key, value] = _ref;\n            return Object.assign(acc, {\n                [key]: this.trackPromise(key, value)\n            });\n        }, {});\n        if (this.done) // All incoming values were resolved\n        this.unlistenAbortSignal();\n        this.init = responseInit;\n    }\n}\nfunction $8b9727f4386a7666$var$isTrackedPromise(value) {\n    return value instanceof Promise && value._tracked === true;\n}\nfunction $8b9727f4386a7666$var$unwrapTrackedPromise(value) {\n    if (!$8b9727f4386a7666$var$isTrackedPromise(value)) return value;\n    if (value._error) throw value._error;\n    return value._data;\n}\nconst $8b9727f4386a7666$export$260e5c0943f31606 = function defer(data, init) {\n    if (init === void 0) init = {};\n    let responseInit = typeof init === \"number\" ? {\n        status: init\n    } : init;\n    return new $8b9727f4386a7666$export$61d759255b4eec65(data, responseInit);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */ const $8b9727f4386a7666$export$89e12c5b50f7529d = function redirect(url, init) {\n    if (init === void 0) init = 302;\n    let responseInit = init;\n    if (typeof responseInit === \"number\") responseInit = {\n        status: responseInit\n    };\n    else if (typeof responseInit.status === \"undefined\") responseInit.status = 302;\n    let headers = new Headers(responseInit.headers);\n    headers.set(\"Location\", url);\n    return new Response(null, $8b9727f4386a7666$var$_extends({}, responseInit, {\n        headers: headers\n    }));\n};\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n */ class $8b9727f4386a7666$export$acf1a680051f5031 {\n    constructor(status, statusText, data, internal){\n        if (internal === void 0) internal = false;\n        this.status = status;\n        this.statusText = statusText || \"\";\n        this.internal = internal;\n        if (data instanceof Error) {\n            this.data = data.toString();\n            this.error = data;\n        } else this.data = data;\n    }\n}\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */ function $8b9727f4386a7666$export$972111febbeef05b(error) {\n    return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\nconst $8b9727f4386a7666$var$validMutationMethodsArr = [\n    \"post\",\n    \"put\",\n    \"patch\",\n    \"delete\"\n];\nconst $8b9727f4386a7666$var$validMutationMethods = new Set($8b9727f4386a7666$var$validMutationMethodsArr);\nconst $8b9727f4386a7666$var$validRequestMethodsArr = [\n    \"get\",\n    ...$8b9727f4386a7666$var$validMutationMethodsArr\n];\nconst $8b9727f4386a7666$var$validRequestMethods = new Set($8b9727f4386a7666$var$validRequestMethodsArr);\nconst $8b9727f4386a7666$var$redirectStatusCodes = new Set([\n    301,\n    302,\n    303,\n    307,\n    308\n]);\nconst $8b9727f4386a7666$var$redirectPreserveMethodStatusCodes = new Set([\n    307,\n    308\n]);\nconst $8b9727f4386a7666$export$ed3e14b2f9e105d0 = {\n    state: \"idle\",\n    location: undefined,\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined\n};\nconst $8b9727f4386a7666$export$52eace9c284d3585 = {\n    state: \"idle\",\n    data: undefined,\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined\n};\nconst $8b9727f4386a7666$export$386d57f03f0b2883 = {\n    state: \"unblocked\",\n    proceed: undefined,\n    reset: undefined,\n    location: undefined\n};\nconst $8b9727f4386a7666$var$ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nconst $8b9727f4386a7666$var$defaultMapRouteProperties = (route)=>({\n        hasErrorBoundary: Boolean(route.hasErrorBoundary)\n    });\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */ function $8b9727f4386a7666$export$baddd0131ee8c05b(init) {\n    const routerWindow = init.window ? init.window : typeof window !== \"undefined\" ? window : undefined;\n    const isBrowser = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n    const isServer = !isBrowser;\n    $8b9727f4386a7666$export$3e9cee6b33872309(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n    let mapRouteProperties;\n    if (init.mapRouteProperties) mapRouteProperties = init.mapRouteProperties;\n    else if (init.detectErrorBoundary) {\n        // If they are still using the deprecated version, wrap it with the new API\n        let detectErrorBoundary = init.detectErrorBoundary;\n        mapRouteProperties = (route)=>({\n                hasErrorBoundary: detectErrorBoundary(route)\n            });\n    } else mapRouteProperties = $8b9727f4386a7666$var$defaultMapRouteProperties;\n    // Routes keyed by ID\n    let manifest = {};\n    // Routes in tree format for matching\n    let dataRoutes = $8b9727f4386a7666$export$4a6d22b32134ea5d(init.routes, mapRouteProperties, undefined, manifest);\n    let inFlightDataRoutes;\n    let basename = init.basename || \"/\";\n    // Config driven behavior flags\n    let future = $8b9727f4386a7666$var$_extends({\n        v7_normalizeFormMethod: false,\n        v7_prependBasename: false\n    }, init.future);\n    // Cleanup function for history\n    let unlistenHistory = null;\n    // Externally-provided functions to call on all state changes\n    let subscribers = new Set();\n    // Externally-provided object to hold scroll restoration locations during routing\n    let savedScrollPositions = null;\n    // Externally-provided function to get scroll restoration keys\n    let getScrollRestorationKey = null;\n    // Externally-provided function to get current scroll position\n    let getScrollPosition = null;\n    // One-time flag to control the initial hydration scroll restoration.  Because\n    // we don't get the saved positions from <ScrollRestoration /> until _after_\n    // the initial render, we need to manually trigger a separate updateState to\n    // send along the restoreScrollPosition\n    // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n    // SSR did the initial scroll restoration.\n    let initialScrollRestored = init.hydrationData != null;\n    let initialMatches = $8b9727f4386a7666$export$2708184779ceb39d(dataRoutes, init.history.location, basename);\n    let initialErrors = null;\n    if (initialMatches == null) {\n        // If we do not match a user-provided-route, fall back to the root\n        // to allow the error boundary to take over\n        let error = $8b9727f4386a7666$var$getInternalRouterError(404, {\n            pathname: init.history.location.pathname\n        });\n        let { matches: matches, route: route } = $8b9727f4386a7666$var$getShortCircuitMatches(dataRoutes);\n        initialMatches = matches;\n        initialErrors = {\n            [route.id]: error\n        };\n    }\n    let initialized = // All initialMatches need to be loaded before we're ready.  If we have lazy\n    // functions around still then we'll need to run them in initialize()\n    !initialMatches.some((m)=>m.route.lazy) && // And we have to either have no loaders or have been provided hydrationData\n    (!initialMatches.some((m)=>m.route.loader) || init.hydrationData != null);\n    let router;\n    let state = {\n        historyAction: init.history.action,\n        location: init.history.location,\n        matches: initialMatches,\n        initialized: initialized,\n        navigation: $8b9727f4386a7666$export$ed3e14b2f9e105d0,\n        // Don't restore on initial updateState() if we were SSR'd\n        restoreScrollPosition: init.hydrationData != null ? false : null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n        actionData: init.hydrationData && init.hydrationData.actionData || null,\n        errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n        fetchers: new Map(),\n        blockers: new Map()\n    };\n    // -- Stateful internal variables to manage navigations --\n    // Current navigation in progress (to be committed in completeNavigation)\n    let pendingAction = $8b9727f4386a7666$export$e19cd5f9376f8cee.Pop;\n    // Should the current navigation prevent the scroll reset if scroll cannot\n    // be restored?\n    let pendingPreventScrollReset = false;\n    // AbortController for the active navigation\n    let pendingNavigationController;\n    // We use this to avoid touching history in completeNavigation if a\n    // revalidation is entirely uninterrupted\n    let isUninterruptedRevalidation = false;\n    // Use this internal flag to force revalidation of all loaders:\n    //  - submissions (completed or interrupted)\n    //  - useRevalidator()\n    //  - X-Remix-Revalidate (from redirect)\n    let isRevalidationRequired = false;\n    // Use this internal array to capture routes that require revalidation due\n    // to a cancelled deferred on action submission\n    let cancelledDeferredRoutes = [];\n    // Use this internal array to capture fetcher loads that were cancelled by an\n    // action navigation and require revalidation\n    let cancelledFetcherLoads = [];\n    // AbortControllers for any in-flight fetchers\n    let fetchControllers = new Map();\n    // Track loads based on the order in which they started\n    let incrementingLoadId = 0;\n    // Track the outstanding pending navigation data load to be compared against\n    // the globally incrementing load when a fetcher load lands after a completed\n    // navigation\n    let pendingNavigationLoadId = -1;\n    // Fetchers that triggered data reloads as a result of their actions\n    let fetchReloadIds = new Map();\n    // Fetchers that triggered redirect navigations\n    let fetchRedirectIds = new Set();\n    // Most recent href/match for fetcher.load calls for fetchers\n    let fetchLoadMatches = new Map();\n    // Store DeferredData instances for active route matches.  When a\n    // route loader returns defer() we stick one in here.  Then, when a nested\n    // promise resolves we update loaderData.  If a new navigation starts we\n    // cancel active deferreds for eliminated routes.\n    let activeDeferreds = new Map();\n    // Store blocker functions in a separate Map outside of router state since\n    // we don't need to update UI state if they change\n    let blockerFunctions = new Map();\n    // Flag to ignore the next history update, so we can revert the URL change on\n    // a POP navigation that was blocked by the user without touching router state\n    let ignoreNextHistoryUpdate = false;\n    // Initialize the router, all side effects should be kicked off from here.\n    // Implemented as a Fluent API for ease of:\n    //   let router = createRouter(init).initialize();\n    function initialize() {\n        // If history informs us of a POP navigation, start the navigation but do not update\n        // state.  We'll update our own state once the navigation completes\n        unlistenHistory = init.history.listen((_ref)=>{\n            let { action: historyAction, location: location, delta: delta } = _ref;\n            // Ignore this event if it was just us resetting the URL from a\n            // blocked POP navigation\n            if (ignoreNextHistoryUpdate) {\n                ignoreNextHistoryUpdate = false;\n                return;\n            }\n            $8b9727f4386a7666$export$c0e02632e14916fd(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.\");\n            let blockerKey = shouldBlockNavigation({\n                currentLocation: state.location,\n                nextLocation: location,\n                historyAction: historyAction\n            });\n            if (blockerKey && delta != null) {\n                // Restore the URL to match the current UI, but don't update router state\n                ignoreNextHistoryUpdate = true;\n                init.history.go(delta * -1);\n                // Put the blocker into a blocked state\n                updateBlocker(blockerKey, {\n                    state: \"blocked\",\n                    location: location,\n                    proceed () {\n                        updateBlocker(blockerKey, {\n                            state: \"proceeding\",\n                            proceed: undefined,\n                            reset: undefined,\n                            location: location\n                        });\n                        // Re-do the same POP navigation we just blocked\n                        init.history.go(delta);\n                    },\n                    reset () {\n                        let blockers = new Map(state.blockers);\n                        blockers.set(blockerKey, $8b9727f4386a7666$export$386d57f03f0b2883);\n                        updateState({\n                            blockers: blockers\n                        });\n                    }\n                });\n                return;\n            }\n            return startNavigation(historyAction, location);\n        });\n        // Kick off initial data load if needed.  Use Pop to avoid modifying history\n        // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n        // in the normal navigation flow.  For SSR it's expected that lazy modules are\n        // resolved prior to router creation since we can't go into a fallbackElement\n        // UI for SSR'd apps\n        if (!state.initialized) startNavigation($8b9727f4386a7666$export$e19cd5f9376f8cee.Pop, state.location);\n        return router;\n    }\n    // Clean up a router and it's side effects\n    function dispose() {\n        if (unlistenHistory) unlistenHistory();\n        subscribers.clear();\n        pendingNavigationController && pendingNavigationController.abort();\n        state.fetchers.forEach((_, key)=>deleteFetcher(key));\n        state.blockers.forEach((_, key)=>deleteBlocker(key));\n    }\n    // Subscribe to state updates for the router\n    function subscribe(fn) {\n        subscribers.add(fn);\n        return ()=>subscribers.delete(fn);\n    }\n    // Update our state and notify the calling context of the change\n    function updateState(newState) {\n        state = $8b9727f4386a7666$var$_extends({}, state, newState);\n        subscribers.forEach((subscriber)=>subscriber(state));\n    }\n    // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n    // and setting state.[historyAction/location/matches] to the new route.\n    // - Location is a required param\n    // - Navigation will always be set to IDLE_NAVIGATION\n    // - Can pass any other state in newState\n    function completeNavigation(location, newState) {\n        var _location$state, _location$state2;\n        // Deduce if we're in a loading/actionReload state:\n        // - We have committed actionData in the store\n        // - The current navigation was a mutation submission\n        // - We're past the submitting state and into the loading state\n        // - The location being loaded is not the result of a redirect\n        let isActionReload = state.actionData != null && state.navigation.formMethod != null && $8b9727f4386a7666$var$isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n        let actionData;\n        if (newState.actionData) {\n            if (Object.keys(newState.actionData).length > 0) actionData = newState.actionData;\n            else // Empty actionData -> clear prior actionData due to an action error\n            actionData = null;\n        } else if (isActionReload) // Keep the current data if we're wrapping up the action reload\n        actionData = state.actionData;\n        else // Clear actionData on any other completed navigations\n        actionData = null;\n        // Always preserve any existing loaderData from re-used routes\n        let loaderData = newState.loaderData ? $8b9727f4386a7666$var$mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n        // On a successful navigation we can assume we got through all blockers\n        // so we can start fresh\n        let blockers = state.blockers;\n        if (blockers.size > 0) {\n            blockers = new Map(blockers);\n            blockers.forEach((_, k)=>blockers.set(k, $8b9727f4386a7666$export$386d57f03f0b2883));\n        }\n        // Always respect the user flag.  Otherwise don't reset on mutation\n        // submission navigations unless they redirect\n        let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && $8b9727f4386a7666$var$isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n        if (inFlightDataRoutes) {\n            dataRoutes = inFlightDataRoutes;\n            inFlightDataRoutes = undefined;\n        }\n        if (isUninterruptedRevalidation) ;\n        else if (pendingAction === $8b9727f4386a7666$export$e19cd5f9376f8cee.Pop) ;\n        else if (pendingAction === $8b9727f4386a7666$export$e19cd5f9376f8cee.Push) init.history.push(location, location.state);\n        else if (pendingAction === $8b9727f4386a7666$export$e19cd5f9376f8cee.Replace) init.history.replace(location, location.state);\n        updateState($8b9727f4386a7666$var$_extends({}, newState, {\n            actionData: actionData,\n            loaderData: loaderData,\n            historyAction: pendingAction,\n            location: location,\n            initialized: true,\n            navigation: $8b9727f4386a7666$export$ed3e14b2f9e105d0,\n            revalidation: \"idle\",\n            restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n            preventScrollReset: preventScrollReset,\n            blockers: blockers\n        }));\n        // Reset stateful navigation vars\n        pendingAction = $8b9727f4386a7666$export$e19cd5f9376f8cee.Pop;\n        pendingPreventScrollReset = false;\n        isUninterruptedRevalidation = false;\n        isRevalidationRequired = false;\n        cancelledDeferredRoutes = [];\n        cancelledFetcherLoads = [];\n    }\n    // Trigger a navigation event, which can either be a numerical POP or a PUSH\n    // replace with an optional submission\n    async function navigate(to, opts) {\n        if (typeof to === \"number\") {\n            init.history.go(to);\n            return;\n        }\n        let normalizedPath = $8b9727f4386a7666$var$normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n        let { path: path, submission: submission, error: error } = $8b9727f4386a7666$var$normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\n        let currentLocation = state.location;\n        let nextLocation = $8b9727f4386a7666$var$createLocation(state.location, path, opts && opts.state);\n        // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n        // URL from window.location, so we need to encode it here so the behavior\n        // remains the same as POP and non-data-router usages.  new URL() does all\n        // the same encoding we'd get from a history.pushState/window.location read\n        // without having to touch history\n        nextLocation = $8b9727f4386a7666$var$_extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n        let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n        let historyAction = $8b9727f4386a7666$export$e19cd5f9376f8cee.Push;\n        if (userReplace === true) historyAction = $8b9727f4386a7666$export$e19cd5f9376f8cee.Replace;\n        else if (userReplace === false) ;\n        else if (submission != null && $8b9727f4386a7666$var$isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) // By default on submissions to the current location we REPLACE so that\n        // users don't have to double-click the back button to get to the prior\n        // location.  If the user redirects to a different location from the\n        // action/loader this will be ignored and the redirect will be a PUSH\n        historyAction = $8b9727f4386a7666$export$e19cd5f9376f8cee.Replace;\n        let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : undefined;\n        let blockerKey = shouldBlockNavigation({\n            currentLocation: currentLocation,\n            nextLocation: nextLocation,\n            historyAction: historyAction\n        });\n        if (blockerKey) {\n            // Put the blocker into a blocked state\n            updateBlocker(blockerKey, {\n                state: \"blocked\",\n                location: nextLocation,\n                proceed () {\n                    updateBlocker(blockerKey, {\n                        state: \"proceeding\",\n                        proceed: undefined,\n                        reset: undefined,\n                        location: nextLocation\n                    });\n                    // Send the same navigation through\n                    navigate(to, opts);\n                },\n                reset () {\n                    let blockers = new Map(state.blockers);\n                    blockers.set(blockerKey, $8b9727f4386a7666$export$386d57f03f0b2883);\n                    updateState({\n                        blockers: blockers\n                    });\n                }\n            });\n            return;\n        }\n        return await startNavigation(historyAction, nextLocation, {\n            submission: submission,\n            // Send through the formData serialization error if we have one so we can\n            // render at the right error boundary after we match routes\n            pendingError: error,\n            preventScrollReset: preventScrollReset,\n            replace: opts && opts.replace\n        });\n    }\n    // Revalidate all current loaders.  If a navigation is in progress or if this\n    // is interrupted by a navigation, allow this to \"succeed\" by calling all\n    // loaders during the next loader round\n    function revalidate() {\n        interruptActiveLoads();\n        updateState({\n            revalidation: \"loading\"\n        });\n        // If we're currently submitting an action, we don't need to start a new\n        // navigation, we'll just let the follow up loader execution call all loaders\n        if (state.navigation.state === \"submitting\") return;\n        // If we're currently in an idle state, start a new navigation for the current\n        // action/location and mark it as uninterrupted, which will skip the history\n        // update in completeNavigation\n        if (state.navigation.state === \"idle\") {\n            startNavigation(state.historyAction, state.location, {\n                startUninterruptedRevalidation: true\n            });\n            return;\n        }\n        // Otherwise, if we're currently in a loading state, just start a new\n        // navigation to the navigation.location but do not trigger an uninterrupted\n        // revalidation so that history correctly updates once the navigation completes\n        startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n            overrideNavigation: state.navigation\n        });\n    }\n    // Start a navigation to the given action/location.  Can optionally provide a\n    // overrideNavigation which will override the normalLoad in the case of a redirect\n    // navigation\n    async function startNavigation(historyAction, location, opts) {\n        // Abort any in-progress navigations and start a new one. Unset any ongoing\n        // uninterrupted revalidations unless told otherwise, since we want this\n        // new navigation to update history normally\n        pendingNavigationController && pendingNavigationController.abort();\n        pendingNavigationController = null;\n        pendingAction = historyAction;\n        isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n        // Save the current scroll position every time we start a new navigation,\n        // and track whether we should reset scroll on completion\n        saveScrollPosition(state.location, state.matches);\n        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let loadingNavigation = opts && opts.overrideNavigation;\n        let matches = $8b9727f4386a7666$export$2708184779ceb39d(routesToUse, location, basename);\n        // Short circuit with a 404 on the root error boundary if we match nothing\n        if (!matches) {\n            let error = $8b9727f4386a7666$var$getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n            let { matches: notFoundMatches, route: route } = $8b9727f4386a7666$var$getShortCircuitMatches(routesToUse);\n            // Cancel all pending deferred on 404s since we don't keep any routes\n            cancelActiveDeferreds();\n            completeNavigation(location, {\n                matches: notFoundMatches,\n                loaderData: {},\n                errors: {\n                    [route.id]: error\n                }\n            });\n            return;\n        }\n        // Short circuit if it's only a hash change and not a revalidation or\n        // mutation submission.\n        //\n        // Ignore on initial page loads because since the initial load will always\n        // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n        // which will default to a navigation to /page\n        if (state.initialized && !isRevalidationRequired && $8b9727f4386a7666$var$isHashChangeOnly(state.location, location) && !(opts && opts.submission && $8b9727f4386a7666$var$isMutationMethod(opts.submission.formMethod))) {\n            completeNavigation(location, {\n                matches: matches\n            });\n            return;\n        }\n        // Create a controller/Request for this navigation\n        pendingNavigationController = new AbortController();\n        let request = $8b9727f4386a7666$var$createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n        let pendingActionData;\n        let pendingError;\n        if (opts && opts.pendingError) // If we have a pendingError, it means the user attempted a GET submission\n        // with binary FormData so assign here and skip to handleLoaders.  That\n        // way we handle calling loaders above the boundary etc.  It's not really\n        // different from an actionError in that sense.\n        pendingError = {\n            [$8b9727f4386a7666$var$findNearestBoundary(matches).route.id]: opts.pendingError\n        };\n        else if (opts && opts.submission && $8b9727f4386a7666$var$isMutationMethod(opts.submission.formMethod)) {\n            // Call action if we received an action submission\n            let actionOutput = await handleAction(request, location, opts.submission, matches, {\n                replace: opts.replace\n            });\n            if (actionOutput.shortCircuited) return;\n            pendingActionData = actionOutput.pendingActionData;\n            pendingError = actionOutput.pendingActionError;\n            loadingNavigation = $8b9727f4386a7666$var$getLoadingNavigation(location, opts.submission);\n            // Create a GET request for the loaders\n            request = new Request(request.url, {\n                signal: request.signal\n            });\n        }\n        // Call loaders\n        let { shortCircuited: shortCircuited, loaderData: loaderData, errors: errors } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, pendingActionData, pendingError);\n        if (shortCircuited) return;\n        // Clean up now that the action/loaders have completed.  Don't clean up if\n        // we short circuited because pendingNavigationController will have already\n        // been assigned to a new controller for the next navigation\n        pendingNavigationController = null;\n        completeNavigation(location, $8b9727f4386a7666$var$_extends({\n            matches: matches\n        }, pendingActionData ? {\n            actionData: pendingActionData\n        } : {}, {\n            loaderData: loaderData,\n            errors: errors\n        }));\n    }\n    // Call the action matched by the leaf route for this navigation and handle\n    // redirects/errors\n    async function handleAction(request, location, submission, matches, opts) {\n        if (opts === void 0) opts = {};\n        interruptActiveLoads();\n        // Put us in a submitting state\n        let navigation = $8b9727f4386a7666$var$getSubmittingNavigation(location, submission);\n        updateState({\n            navigation: navigation\n        });\n        // Call our action and get the result\n        let result;\n        let actionMatch = $8b9727f4386a7666$var$getTargetMatch(matches, location);\n        if (!actionMatch.route.action && !actionMatch.route.lazy) result = {\n            type: $8b9727f4386a7666$var$ResultType.error,\n            error: $8b9727f4386a7666$var$getInternalRouterError(405, {\n                method: request.method,\n                pathname: location.pathname,\n                routeId: actionMatch.route.id\n            })\n        };\n        else {\n            result = await $8b9727f4386a7666$var$callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename);\n            if (request.signal.aborted) return {\n                shortCircuited: true\n            };\n        }\n        if ($8b9727f4386a7666$var$isRedirectResult(result)) {\n            let replace;\n            if (opts && opts.replace != null) replace = opts.replace;\n            else // If the user didn't explicity indicate replace behavior, replace if\n            // we redirected to the exact same location we're currently at to avoid\n            // double back-buttons\n            replace = result.location === state.location.pathname + state.location.search;\n            await startRedirectNavigation(state, result, {\n                submission: submission,\n                replace: replace\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        if ($8b9727f4386a7666$var$isErrorResult(result)) {\n            // Store off the pending error - we use it to determine which loaders\n            // to call and will commit it when we complete the navigation\n            let boundaryMatch = $8b9727f4386a7666$var$findNearestBoundary(matches, actionMatch.route.id);\n            // By default, all submissions are REPLACE navigations, but if the\n            // action threw an error that'll be rendered in an errorElement, we fall\n            // back to PUSH so that the user can use the back button to get back to\n            // the pre-submission form location to try again\n            if ((opts && opts.replace) !== true) pendingAction = $8b9727f4386a7666$export$e19cd5f9376f8cee.Push;\n            return {\n                // Send back an empty object we can use to clear out any prior actionData\n                pendingActionData: {},\n                pendingActionError: {\n                    [boundaryMatch.route.id]: result.error\n                }\n            };\n        }\n        if ($8b9727f4386a7666$var$isDeferredResult(result)) throw $8b9727f4386a7666$var$getInternalRouterError(400, {\n            type: \"defer-action\"\n        });\n        return {\n            pendingActionData: {\n                [actionMatch.route.id]: result.data\n            }\n        };\n    }\n    // Call all applicable loaders for the given matches, handling redirects,\n    // errors, etc.\n    async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, pendingActionData, pendingError) {\n        // Figure out the right navigation we want to use for data loading\n        let loadingNavigation = overrideNavigation || $8b9727f4386a7666$var$getLoadingNavigation(location, submission);\n        // If this was a redirect from an action we don't have a \"submission\" but\n        // we have it on the loading navigation so use that if available\n        let activeSubmission = submission || fetcherSubmission || $8b9727f4386a7666$var$getSubmissionFromNavigation(loadingNavigation);\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let [matchesToLoad, revalidatingFetchers] = $8b9727f4386a7666$var$getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);\n        // Cancel pending deferreds for no-longer-matched routes or routes we're\n        // about to reload.  Note that if this is an action reload we would have\n        // already cancelled all pending deferreds so this would be a no-op\n        cancelActiveDeferreds((routeId)=>!(matches && matches.some((m)=>m.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m)=>m.route.id === routeId));\n        pendingNavigationLoadId = ++incrementingLoadId;\n        // Short circuit if we have no loaders to run\n        if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n            let updatedFetchers = markFetchRedirectsDone();\n            completeNavigation(location, $8b9727f4386a7666$var$_extends({\n                matches: matches,\n                loaderData: {},\n                // Commit pending error if we're short circuiting\n                errors: pendingError || null\n            }, pendingActionData ? {\n                actionData: pendingActionData\n            } : {}, updatedFetchers ? {\n                fetchers: new Map(state.fetchers)\n            } : {}));\n            return {\n                shortCircuited: true\n            };\n        }\n        // If this is an uninterrupted revalidation, we remain in our current idle\n        // state.  If not, we need to switch to our loading state and load data,\n        // preserving any new action data or existing action data (in the case of\n        // a revalidation interrupting an actionReload)\n        if (!isUninterruptedRevalidation) {\n            revalidatingFetchers.forEach((rf)=>{\n                let fetcher = state.fetchers.get(rf.key);\n                let revalidatingFetcher = $8b9727f4386a7666$var$getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);\n                state.fetchers.set(rf.key, revalidatingFetcher);\n            });\n            let actionData = pendingActionData || state.actionData;\n            updateState($8b9727f4386a7666$var$_extends({\n                navigation: loadingNavigation\n            }, actionData ? Object.keys(actionData).length === 0 ? {\n                actionData: null\n            } : {\n                actionData: actionData\n            } : {}, revalidatingFetchers.length > 0 ? {\n                fetchers: new Map(state.fetchers)\n            } : {}));\n        }\n        revalidatingFetchers.forEach((rf)=>{\n            if (fetchControllers.has(rf.key)) abortFetcher(rf.key);\n            if (rf.controller) // Fetchers use an independent AbortController so that aborting a fetcher\n            // (via deleteFetcher) does not abort the triggering navigation that\n            // triggered the revalidation\n            fetchControllers.set(rf.key, rf.controller);\n        });\n        // Proxy navigation abort through to revalidation fetchers\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((f)=>abortFetcher(f.key));\n        if (pendingNavigationController) pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        let { results: results, loaderResults: loaderResults, fetcherResults: fetcherResults } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\n        if (request.signal.aborted) return {\n            shortCircuited: true\n        };\n        // Clean up _after_ loaders have completed.  Don't clean up if we short\n        // circuited because fetchControllers would have been aborted and\n        // reassigned to new controllers for the next navigation\n        if (pendingNavigationController) pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        revalidatingFetchers.forEach((rf)=>fetchControllers.delete(rf.key));\n        // If any loaders returned a redirect Response, start a new REPLACE navigation\n        let redirect = $8b9727f4386a7666$var$findRedirect(results);\n        if (redirect) {\n            if (redirect.idx >= matchesToLoad.length) {\n                // If this redirect came from a fetcher make sure we mark it in\n                // fetchRedirectIds so it doesn't get revalidated on the next set of\n                // loader executions\n                let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n                fetchRedirectIds.add(fetcherKey);\n            }\n            await startRedirectNavigation(state, redirect.result, {\n                replace: replace\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        // Process and commit output from loaders\n        let { loaderData: loaderData, errors: errors } = $8b9727f4386a7666$var$processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);\n        // Wire up subscribers to update loaderData as promises settle\n        activeDeferreds.forEach((deferredData, routeId)=>{\n            deferredData.subscribe((aborted)=>{\n                // Note: No need to updateState here since the TrackedPromise on\n                // loaderData is stable across resolve/reject\n                // Remove this instance if we were aborted or if promises have settled\n                if (aborted || deferredData.done) activeDeferreds.delete(routeId);\n            });\n        });\n        let updatedFetchers = markFetchRedirectsDone();\n        let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n        let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n        return $8b9727f4386a7666$var$_extends({\n            loaderData: loaderData,\n            errors: errors\n        }, shouldUpdateFetchers ? {\n            fetchers: new Map(state.fetchers)\n        } : {});\n    }\n    function getFetcher(key) {\n        return state.fetchers.get(key) || $8b9727f4386a7666$export$52eace9c284d3585;\n    }\n    // Trigger a fetcher load/submit for the given fetcher key\n    function fetch(key, routeId, href, opts) {\n        if (isServer) throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.\");\n        if (fetchControllers.has(key)) abortFetcher(key);\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let normalizedPath = $8b9727f4386a7666$var$normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, routeId, opts == null ? void 0 : opts.relative);\n        let matches = $8b9727f4386a7666$export$2708184779ceb39d(routesToUse, normalizedPath, basename);\n        if (!matches) {\n            setFetcherError(key, routeId, $8b9727f4386a7666$var$getInternalRouterError(404, {\n                pathname: normalizedPath\n            }));\n            return;\n        }\n        let { path: path, submission: submission, error: error } = $8b9727f4386a7666$var$normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\n        if (error) {\n            setFetcherError(key, routeId, error);\n            return;\n        }\n        let match = $8b9727f4386a7666$var$getTargetMatch(matches, path);\n        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n        if (submission && $8b9727f4386a7666$var$isMutationMethod(submission.formMethod)) {\n            handleFetcherAction(key, routeId, path, match, matches, submission);\n            return;\n        }\n        // Store off the match so we can call it's shouldRevalidate on subsequent\n        // revalidations\n        fetchLoadMatches.set(key, {\n            routeId: routeId,\n            path: path\n        });\n        handleFetcherLoader(key, routeId, path, match, matches, submission);\n    }\n    // Call the action for the matched fetcher.submit(), and then handle redirects,\n    // errors, and revalidation\n    async function handleFetcherAction(key, routeId, path, match, requestMatches, submission) {\n        interruptActiveLoads();\n        fetchLoadMatches.delete(key);\n        if (!match.route.action && !match.route.lazy) {\n            let error = $8b9727f4386a7666$var$getInternalRouterError(405, {\n                method: submission.formMethod,\n                pathname: path,\n                routeId: routeId\n            });\n            setFetcherError(key, routeId, error);\n            return;\n        }\n        // Put this fetcher into it's submitting state\n        let existingFetcher = state.fetchers.get(key);\n        let fetcher = $8b9727f4386a7666$var$getSubmittingFetcher(submission, existingFetcher);\n        state.fetchers.set(key, fetcher);\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n        // Call the action for the fetcher\n        let abortController = new AbortController();\n        let fetchRequest = $8b9727f4386a7666$var$createClientSideRequest(init.history, path, abortController.signal, submission);\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let actionResult = await $8b9727f4386a7666$var$callLoaderOrAction(\"action\", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename);\n        if (fetchRequest.signal.aborted) {\n            // We can delete this so long as we weren't aborted by ou our own fetcher\n            // re-submit which would have put _new_ controller is in fetchControllers\n            if (fetchControllers.get(key) === abortController) fetchControllers.delete(key);\n            return;\n        }\n        if ($8b9727f4386a7666$var$isRedirectResult(actionResult)) {\n            fetchControllers.delete(key);\n            if (pendingNavigationLoadId > originatingLoadId) {\n                // A new navigation was kicked off after our action started, so that\n                // should take precedence over this redirect navigation.  We already\n                // set isRevalidationRequired so all loaders for the new route should\n                // fire unless opted out via shouldRevalidate\n                let doneFetcher = $8b9727f4386a7666$var$getDoneFetcher(undefined);\n                state.fetchers.set(key, doneFetcher);\n                updateState({\n                    fetchers: new Map(state.fetchers)\n                });\n                return;\n            } else {\n                fetchRedirectIds.add(key);\n                let loadingFetcher = $8b9727f4386a7666$var$getLoadingFetcher(submission);\n                state.fetchers.set(key, loadingFetcher);\n                updateState({\n                    fetchers: new Map(state.fetchers)\n                });\n                return startRedirectNavigation(state, actionResult, {\n                    submission: submission,\n                    isFetchActionRedirect: true\n                });\n            }\n        }\n        // Process any non-redirect errors thrown\n        if ($8b9727f4386a7666$var$isErrorResult(actionResult)) {\n            setFetcherError(key, routeId, actionResult.error);\n            return;\n        }\n        if ($8b9727f4386a7666$var$isDeferredResult(actionResult)) throw $8b9727f4386a7666$var$getInternalRouterError(400, {\n            type: \"defer-action\"\n        });\n        // Start the data load for current matches, or the next location if we're\n        // in the middle of a navigation\n        let nextLocation = state.navigation.location || state.location;\n        let revalidationRequest = $8b9727f4386a7666$var$createClientSideRequest(init.history, nextLocation, abortController.signal);\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let matches = state.navigation.state !== \"idle\" ? $8b9727f4386a7666$export$2708184779ceb39d(routesToUse, state.navigation.location, basename) : state.matches;\n        $8b9727f4386a7666$export$3e9cee6b33872309(matches, \"Didn't find any matches after fetcher action\");\n        let loadId = ++incrementingLoadId;\n        fetchReloadIds.set(key, loadId);\n        let loadFetcher = $8b9727f4386a7666$var$getLoadingFetcher(submission, actionResult.data);\n        state.fetchers.set(key, loadFetcher);\n        let [matchesToLoad, revalidatingFetchers] = $8b9727f4386a7666$var$getMatchesToLoad(init.history, state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, {\n            [match.route.id]: actionResult.data\n        }, undefined // No need to send through errors since we short circuit above\n        );\n        // Put all revalidating fetchers into the loading state, except for the\n        // current fetcher which we want to keep in it's current loading state which\n        // contains it's action submission info + action data\n        revalidatingFetchers.filter((rf)=>rf.key !== key).forEach((rf)=>{\n            let staleKey = rf.key;\n            let existingFetcher = state.fetchers.get(staleKey);\n            let revalidatingFetcher = $8b9727f4386a7666$var$getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);\n            state.fetchers.set(staleKey, revalidatingFetcher);\n            if (fetchControllers.has(staleKey)) abortFetcher(staleKey);\n            if (rf.controller) fetchControllers.set(staleKey, rf.controller);\n        });\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((rf)=>abortFetcher(rf.key));\n        abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        let { results: results, loaderResults: loaderResults, fetcherResults: fetcherResults } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n        if (abortController.signal.aborted) return;\n        abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        fetchReloadIds.delete(key);\n        fetchControllers.delete(key);\n        revalidatingFetchers.forEach((r)=>fetchControllers.delete(r.key));\n        let redirect = $8b9727f4386a7666$var$findRedirect(results);\n        if (redirect) {\n            if (redirect.idx >= matchesToLoad.length) {\n                // If this redirect came from a fetcher make sure we mark it in\n                // fetchRedirectIds so it doesn't get revalidated on the next set of\n                // loader executions\n                let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n                fetchRedirectIds.add(fetcherKey);\n            }\n            return startRedirectNavigation(state, redirect.result);\n        }\n        // Process and commit output from loaders\n        let { loaderData: loaderData, errors: errors } = $8b9727f4386a7666$var$processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);\n        // Since we let revalidations complete even if the submitting fetcher was\n        // deleted, only put it back to idle if it hasn't been deleted\n        if (state.fetchers.has(key)) {\n            let doneFetcher = $8b9727f4386a7666$var$getDoneFetcher(actionResult.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n        let didAbortFetchLoads = abortStaleFetchLoads(loadId);\n        // If we are currently in a navigation loading state and this fetcher is\n        // more recent than the navigation, we want the newer data so abort the\n        // navigation and complete it with the fetcher data\n        if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n            $8b9727f4386a7666$export$3e9cee6b33872309(pendingAction, \"Expected pending action\");\n            pendingNavigationController && pendingNavigationController.abort();\n            completeNavigation(state.navigation.location, {\n                matches: matches,\n                loaderData: loaderData,\n                errors: errors,\n                fetchers: new Map(state.fetchers)\n            });\n        } else {\n            // otherwise just update with the fetcher data, preserving any existing\n            // loaderData for loaders that did not need to reload.  We have to\n            // manually merge here since we aren't going through completeNavigation\n            updateState($8b9727f4386a7666$var$_extends({\n                errors: errors,\n                loaderData: $8b9727f4386a7666$var$mergeLoaderData(state.loaderData, loaderData, matches, errors)\n            }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {\n                fetchers: new Map(state.fetchers)\n            } : {}));\n            isRevalidationRequired = false;\n        }\n    }\n    // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n    async function handleFetcherLoader(key, routeId, path, match, matches, submission) {\n        let existingFetcher = state.fetchers.get(key);\n        // Put this fetcher into it's loading state\n        let loadingFetcher = $8b9727f4386a7666$var$getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined);\n        state.fetchers.set(key, loadingFetcher);\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n        // Call the loader for this fetcher route match\n        let abortController = new AbortController();\n        let fetchRequest = $8b9727f4386a7666$var$createClientSideRequest(init.history, path, abortController.signal);\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let result = await $8b9727f4386a7666$var$callLoaderOrAction(\"loader\", fetchRequest, match, matches, manifest, mapRouteProperties, basename);\n        // Deferred isn't supported for fetcher loads, await everything and treat it\n        // as a normal load.  resolveDeferredData will return undefined if this\n        // fetcher gets aborted, so we just leave result untouched and short circuit\n        // below if that happens\n        if ($8b9727f4386a7666$var$isDeferredResult(result)) result = await $8b9727f4386a7666$var$resolveDeferredData(result, fetchRequest.signal, true) || result;\n        // We can delete this so long as we weren't aborted by our our own fetcher\n        // re-load which would have put _new_ controller is in fetchControllers\n        if (fetchControllers.get(key) === abortController) fetchControllers.delete(key);\n        if (fetchRequest.signal.aborted) return;\n        // If the loader threw a redirect Response, start a new REPLACE navigation\n        if ($8b9727f4386a7666$var$isRedirectResult(result)) {\n            if (pendingNavigationLoadId > originatingLoadId) {\n                // A new navigation was kicked off after our loader started, so that\n                // should take precedence over this redirect navigation\n                let doneFetcher = $8b9727f4386a7666$var$getDoneFetcher(undefined);\n                state.fetchers.set(key, doneFetcher);\n                updateState({\n                    fetchers: new Map(state.fetchers)\n                });\n                return;\n            } else {\n                fetchRedirectIds.add(key);\n                await startRedirectNavigation(state, result);\n                return;\n            }\n        }\n        // Process any non-redirect errors thrown\n        if ($8b9727f4386a7666$var$isErrorResult(result)) {\n            let boundaryMatch = $8b9727f4386a7666$var$findNearestBoundary(state.matches, routeId);\n            state.fetchers.delete(key);\n            // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -\n            // do we need to behave any differently with our non-redirect errors?\n            // What if it was a non-redirect Response?\n            updateState({\n                fetchers: new Map(state.fetchers),\n                errors: {\n                    [boundaryMatch.route.id]: result.error\n                }\n            });\n            return;\n        }\n        $8b9727f4386a7666$export$3e9cee6b33872309(!$8b9727f4386a7666$var$isDeferredResult(result), \"Unhandled fetcher deferred data\");\n        // Put the fetcher back into an idle state\n        let doneFetcher = $8b9727f4386a7666$var$getDoneFetcher(result.data);\n        state.fetchers.set(key, doneFetcher);\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n    }\n    /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */ async function startRedirectNavigation(state, redirect, _temp) {\n        let { submission: submission, replace: replace, isFetchActionRedirect: isFetchActionRedirect } = _temp === void 0 ? {} : _temp;\n        if (redirect.revalidate) isRevalidationRequired = true;\n        let redirectLocation = $8b9727f4386a7666$var$createLocation(state.location, redirect.location, $8b9727f4386a7666$var$_extends({\n            _isRedirect: true\n        }, isFetchActionRedirect ? {\n            _isFetchActionRedirect: true\n        } : {}));\n        $8b9727f4386a7666$export$3e9cee6b33872309(redirectLocation, \"Expected a location on the redirect navigation\");\n        // Check if this an absolute external redirect that goes to a new origin\n        if ($8b9727f4386a7666$var$ABSOLUTE_URL_REGEX.test(redirect.location) && isBrowser) {\n            let url = init.history.createURL(redirect.location);\n            let isDifferentBasename = $8b9727f4386a7666$export$b69e3301ce081aa3(url.pathname, basename) == null;\n            if (routerWindow.location.origin !== url.origin || isDifferentBasename) {\n                if (replace) routerWindow.location.replace(redirect.location);\n                else routerWindow.location.assign(redirect.location);\n                return;\n            }\n        }\n        // There's no need to abort on redirects, since we don't detect the\n        // redirect until the action/loaders have settled\n        pendingNavigationController = null;\n        let redirectHistoryAction = replace === true ? $8b9727f4386a7666$export$e19cd5f9376f8cee.Replace : $8b9727f4386a7666$export$e19cd5f9376f8cee.Push;\n        // Use the incoming submission if provided, fallback on the active one in\n        // state.navigation\n        let activeSubmission = submission || $8b9727f4386a7666$var$getSubmissionFromNavigation(state.navigation);\n        // If this was a 307/308 submission we want to preserve the HTTP method and\n        // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n        // redirected location\n        if ($8b9727f4386a7666$var$redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && $8b9727f4386a7666$var$isMutationMethod(activeSubmission.formMethod)) await startNavigation(redirectHistoryAction, redirectLocation, {\n            submission: $8b9727f4386a7666$var$_extends({}, activeSubmission, {\n                formAction: redirect.location\n            }),\n            // Preserve this flag across redirects\n            preventScrollReset: pendingPreventScrollReset\n        });\n        else if (isFetchActionRedirect) // For a fetch action redirect, we kick off a new loading navigation\n        // without the fetcher submission, but we send it along for shouldRevalidate\n        await startNavigation(redirectHistoryAction, redirectLocation, {\n            overrideNavigation: $8b9727f4386a7666$var$getLoadingNavigation(redirectLocation),\n            fetcherSubmission: activeSubmission,\n            // Preserve this flag across redirects\n            preventScrollReset: pendingPreventScrollReset\n        });\n        else {\n            // If we have a submission, we will preserve it through the redirect navigation\n            let overrideNavigation = $8b9727f4386a7666$var$getLoadingNavigation(redirectLocation, activeSubmission);\n            await startNavigation(redirectHistoryAction, redirectLocation, {\n                overrideNavigation: overrideNavigation,\n                // Preserve this flag across redirects\n                preventScrollReset: pendingPreventScrollReset\n            });\n        }\n    }\n    async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n        // Call all navigation loaders and revalidating fetcher loaders in parallel,\n        // then slice off the results into separate arrays so we can handle them\n        // accordingly\n        let results = await Promise.all([\n            ...matchesToLoad.map((match)=>$8b9727f4386a7666$var$callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename)),\n            ...fetchersToLoad.map((f)=>{\n                if (f.matches && f.match && f.controller) return $8b9727f4386a7666$var$callLoaderOrAction(\"loader\", $8b9727f4386a7666$var$createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties, basename);\n                else {\n                    let error = {\n                        type: $8b9727f4386a7666$var$ResultType.error,\n                        error: $8b9727f4386a7666$var$getInternalRouterError(404, {\n                            pathname: f.path\n                        })\n                    };\n                    return error;\n                }\n            })\n        ]);\n        let loaderResults = results.slice(0, matchesToLoad.length);\n        let fetcherResults = results.slice(matchesToLoad.length);\n        await Promise.all([\n            $8b9727f4386a7666$var$resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(()=>request.signal), false, state.loaderData),\n            $8b9727f4386a7666$var$resolveDeferredResults(currentMatches, fetchersToLoad.map((f)=>f.match), fetcherResults, fetchersToLoad.map((f)=>f.controller ? f.controller.signal : null), true)\n        ]);\n        return {\n            results: results,\n            loaderResults: loaderResults,\n            fetcherResults: fetcherResults\n        };\n    }\n    function interruptActiveLoads() {\n        // Every interruption triggers a revalidation\n        isRevalidationRequired = true;\n        // Cancel pending route-level deferreds and mark cancelled routes for\n        // revalidation\n        cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n        // Abort in-flight fetcher loads\n        fetchLoadMatches.forEach((_, key)=>{\n            if (fetchControllers.has(key)) {\n                cancelledFetcherLoads.push(key);\n                abortFetcher(key);\n            }\n        });\n    }\n    function setFetcherError(key, routeId, error) {\n        let boundaryMatch = $8b9727f4386a7666$var$findNearestBoundary(state.matches, routeId);\n        deleteFetcher(key);\n        updateState({\n            errors: {\n                [boundaryMatch.route.id]: error\n            },\n            fetchers: new Map(state.fetchers)\n        });\n    }\n    function deleteFetcher(key) {\n        let fetcher = state.fetchers.get(key);\n        // Don't abort the controller if this is a deletion of a fetcher.submit()\n        // in it's loading phase since - we don't want to abort the corresponding\n        // revalidation and want them to complete and land\n        if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) abortFetcher(key);\n        fetchLoadMatches.delete(key);\n        fetchReloadIds.delete(key);\n        fetchRedirectIds.delete(key);\n        state.fetchers.delete(key);\n    }\n    function abortFetcher(key) {\n        let controller = fetchControllers.get(key);\n        $8b9727f4386a7666$export$3e9cee6b33872309(controller, \"Expected fetch controller: \" + key);\n        controller.abort();\n        fetchControllers.delete(key);\n    }\n    function markFetchersDone(keys) {\n        for (let key of keys){\n            let fetcher = getFetcher(key);\n            let doneFetcher = $8b9727f4386a7666$var$getDoneFetcher(fetcher.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    function markFetchRedirectsDone() {\n        let doneKeys = [];\n        let updatedFetchers = false;\n        for (let key of fetchRedirectIds){\n            let fetcher = state.fetchers.get(key);\n            $8b9727f4386a7666$export$3e9cee6b33872309(fetcher, \"Expected fetcher: \" + key);\n            if (fetcher.state === \"loading\") {\n                fetchRedirectIds.delete(key);\n                doneKeys.push(key);\n                updatedFetchers = true;\n            }\n        }\n        markFetchersDone(doneKeys);\n        return updatedFetchers;\n    }\n    function abortStaleFetchLoads(landedId) {\n        let yeetedKeys = [];\n        for (let [key, id] of fetchReloadIds)if (id < landedId) {\n            let fetcher = state.fetchers.get(key);\n            $8b9727f4386a7666$export$3e9cee6b33872309(fetcher, \"Expected fetcher: \" + key);\n            if (fetcher.state === \"loading\") {\n                abortFetcher(key);\n                fetchReloadIds.delete(key);\n                yeetedKeys.push(key);\n            }\n        }\n        markFetchersDone(yeetedKeys);\n        return yeetedKeys.length > 0;\n    }\n    function getBlocker(key, fn) {\n        let blocker = state.blockers.get(key) || $8b9727f4386a7666$export$386d57f03f0b2883;\n        if (blockerFunctions.get(key) !== fn) blockerFunctions.set(key, fn);\n        return blocker;\n    }\n    function deleteBlocker(key) {\n        state.blockers.delete(key);\n        blockerFunctions.delete(key);\n    }\n    // Utility function to update blockers, ensuring valid state transitions\n    function updateBlocker(key, newBlocker) {\n        let blocker = state.blockers.get(key) || $8b9727f4386a7666$export$386d57f03f0b2883;\n        // Poor mans state machine :)\n        // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n        $8b9727f4386a7666$export$3e9cee6b33872309(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\n        let blockers = new Map(state.blockers);\n        blockers.set(key, newBlocker);\n        updateState({\n            blockers: blockers\n        });\n    }\n    function shouldBlockNavigation(_ref2) {\n        let { currentLocation: currentLocation, nextLocation: nextLocation, historyAction: historyAction } = _ref2;\n        if (blockerFunctions.size === 0) return;\n        // We ony support a single active blocker at the moment since we don't have\n        // any compelling use cases for multi-blocker yet\n        if (blockerFunctions.size > 1) $8b9727f4386a7666$export$c0e02632e14916fd(false, \"A router only supports one blocker at a time\");\n        let entries = Array.from(blockerFunctions.entries());\n        let [blockerKey, blockerFunction] = entries[entries.length - 1];\n        let blocker = state.blockers.get(blockerKey);\n        if (blocker && blocker.state === \"proceeding\") // If the blocker is currently proceeding, we don't need to re-check\n        // it and can let this navigation continue\n        return;\n        // At this point, we know we're unblocked/blocked so we need to check the\n        // user-provided blocker function\n        if (blockerFunction({\n            currentLocation: currentLocation,\n            nextLocation: nextLocation,\n            historyAction: historyAction\n        })) return blockerKey;\n    }\n    function cancelActiveDeferreds(predicate) {\n        let cancelledRouteIds = [];\n        activeDeferreds.forEach((dfd, routeId)=>{\n            if (!predicate || predicate(routeId)) {\n                // Cancel the deferred - but do not remove from activeDeferreds here -\n                // we rely on the subscribers to do that so our tests can assert proper\n                // cleanup via _internalActiveDeferreds\n                dfd.cancel();\n                cancelledRouteIds.push(routeId);\n                activeDeferreds.delete(routeId);\n            }\n        });\n        return cancelledRouteIds;\n    }\n    // Opt in to capturing and reporting scroll positions during navigations,\n    // used by the <ScrollRestoration> component\n    function enableScrollRestoration(positions, getPosition, getKey) {\n        savedScrollPositions = positions;\n        getScrollPosition = getPosition;\n        getScrollRestorationKey = getKey || null;\n        // Perform initial hydration scroll restoration, since we miss the boat on\n        // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n        // and therefore have no savedScrollPositions available\n        if (!initialScrollRestored && state.navigation === $8b9727f4386a7666$export$ed3e14b2f9e105d0) {\n            initialScrollRestored = true;\n            let y = getSavedScrollPosition(state.location, state.matches);\n            if (y != null) updateState({\n                restoreScrollPosition: y\n            });\n        }\n        return ()=>{\n            savedScrollPositions = null;\n            getScrollPosition = null;\n            getScrollRestorationKey = null;\n        };\n    }\n    function getScrollKey(location, matches) {\n        if (getScrollRestorationKey) {\n            let key = getScrollRestorationKey(location, matches.map((m)=>$8b9727f4386a7666$var$createUseMatchesMatch(m, state.loaderData)));\n            return key || location.key;\n        }\n        return location.key;\n    }\n    function saveScrollPosition(location, matches) {\n        if (savedScrollPositions && getScrollPosition) {\n            let key = getScrollKey(location, matches);\n            savedScrollPositions[key] = getScrollPosition();\n        }\n    }\n    function getSavedScrollPosition(location, matches) {\n        if (savedScrollPositions) {\n            let key = getScrollKey(location, matches);\n            let y = savedScrollPositions[key];\n            if (typeof y === \"number\") return y;\n        }\n        return null;\n    }\n    function _internalSetRoutes(newRoutes) {\n        manifest = {};\n        inFlightDataRoutes = $8b9727f4386a7666$export$4a6d22b32134ea5d(newRoutes, mapRouteProperties, undefined, manifest);\n    }\n    router = {\n        get basename () {\n            return basename;\n        },\n        get state () {\n            return state;\n        },\n        get routes () {\n            return dataRoutes;\n        },\n        initialize: initialize,\n        subscribe: subscribe,\n        enableScrollRestoration: enableScrollRestoration,\n        navigate: navigate,\n        fetch: fetch,\n        revalidate: revalidate,\n        // Passthrough to history-aware createHref used by useHref so we get proper\n        // hash-aware URLs in DOM paths\n        createHref: (to)=>init.history.createHref(to),\n        encodeLocation: (to)=>init.history.encodeLocation(to),\n        getFetcher: getFetcher,\n        deleteFetcher: deleteFetcher,\n        dispose: dispose,\n        getBlocker: getBlocker,\n        deleteBlocker: deleteBlocker,\n        _internalFetchControllers: fetchControllers,\n        _internalActiveDeferreds: activeDeferreds,\n        _internalSetRoutes: // TODO: Remove setRoutes, it's temporary to avoid dealing with\n        // updating the tree while validating the update algorithm.\n        _internalSetRoutes\n    };\n    return router;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nconst $8b9727f4386a7666$export$4d0306f8f6a4585b = Symbol(\"deferred\");\nfunction $8b9727f4386a7666$export$3336b097a6fbc59a(routes, opts) {\n    $8b9727f4386a7666$export$3e9cee6b33872309(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\n    let manifest = {};\n    let basename = (opts ? opts.basename : null) || \"/\";\n    let mapRouteProperties;\n    if (opts != null && opts.mapRouteProperties) mapRouteProperties = opts.mapRouteProperties;\n    else if (opts != null && opts.detectErrorBoundary) {\n        // If they are still using the deprecated version, wrap it with the new API\n        let detectErrorBoundary = opts.detectErrorBoundary;\n        mapRouteProperties = (route)=>({\n                hasErrorBoundary: detectErrorBoundary(route)\n            });\n    } else mapRouteProperties = $8b9727f4386a7666$var$defaultMapRouteProperties;\n    let dataRoutes = $8b9727f4386a7666$export$4a6d22b32134ea5d(routes, mapRouteProperties, undefined, manifest);\n    /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */ async function query(request, _temp2) {\n        let { requestContext: requestContext } = _temp2 === void 0 ? {} : _temp2;\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = $8b9727f4386a7666$var$createLocation(\"\", $8b9727f4386a7666$export$fe53371bee54353d(url), null, \"default\");\n        let matches = $8b9727f4386a7666$export$2708184779ceb39d(dataRoutes, location, basename);\n        // SSR supports HEAD requests while SPA doesn't\n        if (!$8b9727f4386a7666$var$isValidMethod(method) && method !== \"HEAD\") {\n            let error = $8b9727f4386a7666$var$getInternalRouterError(405, {\n                method: method\n            });\n            let { matches: methodNotAllowedMatches, route: route } = $8b9727f4386a7666$var$getShortCircuitMatches(dataRoutes);\n            return {\n                basename: basename,\n                location: location,\n                matches: methodNotAllowedMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        } else if (!matches) {\n            let error = $8b9727f4386a7666$var$getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n            let { matches: notFoundMatches, route: route } = $8b9727f4386a7666$var$getShortCircuitMatches(dataRoutes);\n            return {\n                basename: basename,\n                location: location,\n                matches: notFoundMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        }\n        let result = await queryImpl(request, location, matches, requestContext);\n        if ($8b9727f4386a7666$var$isResponse(result)) return result;\n        // When returning StaticHandlerContext, we patch back in the location here\n        // since we need it for React Context.  But this helps keep our submit and\n        // loadRouteData operating on a Request instead of a Location\n        return $8b9727f4386a7666$var$_extends({\n            location: location,\n            basename: basename\n        }, result);\n    }\n    /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */ async function queryRoute(request, _temp3) {\n        let { routeId: routeId, requestContext: requestContext } = _temp3 === void 0 ? {} : _temp3;\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = $8b9727f4386a7666$var$createLocation(\"\", $8b9727f4386a7666$export$fe53371bee54353d(url), null, \"default\");\n        let matches = $8b9727f4386a7666$export$2708184779ceb39d(dataRoutes, location, basename);\n        // SSR supports HEAD requests while SPA doesn't\n        if (!$8b9727f4386a7666$var$isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") throw $8b9727f4386a7666$var$getInternalRouterError(405, {\n            method: method\n        });\n        else if (!matches) throw $8b9727f4386a7666$var$getInternalRouterError(404, {\n            pathname: location.pathname\n        });\n        let match = routeId ? matches.find((m)=>m.route.id === routeId) : $8b9727f4386a7666$var$getTargetMatch(matches, location);\n        if (routeId && !match) throw $8b9727f4386a7666$var$getInternalRouterError(403, {\n            pathname: location.pathname,\n            routeId: routeId\n        });\n        else if (!match) // This should never hit I don't think?\n        throw $8b9727f4386a7666$var$getInternalRouterError(404, {\n            pathname: location.pathname\n        });\n        let result = await queryImpl(request, location, matches, requestContext, match);\n        if ($8b9727f4386a7666$var$isResponse(result)) return result;\n        let error = result.errors ? Object.values(result.errors)[0] : undefined;\n        if (error !== undefined) // If we got back result.errors, that means the loader/action threw\n        // _something_ that wasn't a Response, but it's not guaranteed/required\n        // to be an `instanceof Error` either, so we have to use throw here to\n        // preserve the \"error\" state outside of queryImpl.\n        throw error;\n        // Pick off the right state value to return\n        if (result.actionData) return Object.values(result.actionData)[0];\n        if (result.loaderData) {\n            var _result$activeDeferre;\n            let data = Object.values(result.loaderData)[0];\n            if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) data[$8b9727f4386a7666$export$4d0306f8f6a4585b] = result.activeDeferreds[match.route.id];\n            return data;\n        }\n        return undefined;\n    }\n    async function queryImpl(request, location, matches, requestContext, routeMatch) {\n        $8b9727f4386a7666$export$3e9cee6b33872309(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n        try {\n            if ($8b9727f4386a7666$var$isMutationMethod(request.method.toLowerCase())) {\n                let result = await submit(request, matches, routeMatch || $8b9727f4386a7666$var$getTargetMatch(matches, location), requestContext, routeMatch != null);\n                return result;\n            }\n            let result = await loadRouteData(request, matches, requestContext, routeMatch);\n            return $8b9727f4386a7666$var$isResponse(result) ? result : $8b9727f4386a7666$var$_extends({}, result, {\n                actionData: null,\n                actionHeaders: {}\n            });\n        } catch (e) {\n            // If the user threw/returned a Response in callLoaderOrAction, we throw\n            // it to bail out and then return or throw here based on whether the user\n            // returned or threw\n            if ($8b9727f4386a7666$var$isQueryRouteResponse(e)) {\n                if (e.type === $8b9727f4386a7666$var$ResultType.error && !$8b9727f4386a7666$var$isRedirectResponse(e.response)) throw e.response;\n                return e.response;\n            }\n            // Redirects are always returned since they don't propagate to catch\n            // boundaries\n            if ($8b9727f4386a7666$var$isRedirectResponse(e)) return e;\n            throw e;\n        }\n    }\n    async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {\n        let result;\n        if (!actionMatch.route.action && !actionMatch.route.lazy) {\n            let error = $8b9727f4386a7666$var$getInternalRouterError(405, {\n                method: request.method,\n                pathname: new URL(request.url).pathname,\n                routeId: actionMatch.route.id\n            });\n            if (isRouteRequest) throw error;\n            result = {\n                type: $8b9727f4386a7666$var$ResultType.error,\n                error: error\n            };\n        } else {\n            result = await $8b9727f4386a7666$var$callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename, {\n                isStaticRequest: true,\n                isRouteRequest: isRouteRequest,\n                requestContext: requestContext\n            });\n            if (request.signal.aborted) {\n                let method = isRouteRequest ? \"queryRoute\" : \"query\";\n                throw new Error(method + \"() call aborted\");\n            }\n        }\n        if ($8b9727f4386a7666$var$isRedirectResult(result)) // Uhhhh - this should never happen, we should always throw these from\n        // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n        // can get back on the \"throw all redirect responses\" train here should\n        // this ever happen :/\n        throw new Response(null, {\n            status: result.status,\n            headers: {\n                Location: result.location\n            }\n        });\n        if ($8b9727f4386a7666$var$isDeferredResult(result)) {\n            let error = $8b9727f4386a7666$var$getInternalRouterError(400, {\n                type: \"defer-action\"\n            });\n            if (isRouteRequest) throw error;\n            result = {\n                type: $8b9727f4386a7666$var$ResultType.error,\n                error: error\n            };\n        }\n        if (isRouteRequest) {\n            // Note: This should only be non-Response values if we get here, since\n            // isRouteRequest should throw any Response received in callLoaderOrAction\n            if ($8b9727f4386a7666$var$isErrorResult(result)) throw result.error;\n            return {\n                matches: [\n                    actionMatch\n                ],\n                loaderData: {},\n                actionData: {\n                    [actionMatch.route.id]: result.data\n                },\n                errors: null,\n                // Note: statusCode + headers are unused here since queryRoute will\n                // return the raw Response or value\n                statusCode: 200,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        }\n        if ($8b9727f4386a7666$var$isErrorResult(result)) {\n            // Store off the pending error - we use it to determine which loaders\n            // to call and will commit it when we complete the navigation\n            let boundaryMatch = $8b9727f4386a7666$var$findNearestBoundary(matches, actionMatch.route.id);\n            let context = await loadRouteData(request, matches, requestContext, undefined, {\n                [boundaryMatch.route.id]: result.error\n            });\n            // action status codes take precedence over loader status codes\n            return $8b9727f4386a7666$var$_extends({}, context, {\n                statusCode: $8b9727f4386a7666$export$972111febbeef05b(result.error) ? result.error.status : 500,\n                actionData: null,\n                actionHeaders: $8b9727f4386a7666$var$_extends({}, result.headers ? {\n                    [actionMatch.route.id]: result.headers\n                } : {})\n            });\n        }\n        // Create a GET request for the loaders\n        let loaderRequest = new Request(request.url, {\n            headers: request.headers,\n            redirect: request.redirect,\n            signal: request.signal\n        });\n        let context = await loadRouteData(loaderRequest, matches, requestContext);\n        return $8b9727f4386a7666$var$_extends({}, context, result.statusCode ? {\n            statusCode: result.statusCode\n        } : {}, {\n            actionData: {\n                [actionMatch.route.id]: result.data\n            },\n            actionHeaders: $8b9727f4386a7666$var$_extends({}, result.headers ? {\n                [actionMatch.route.id]: result.headers\n            } : {})\n        });\n    }\n    async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {\n        let isRouteRequest = routeMatch != null;\n        // Short circuit if we have no loaders to run (queryRoute())\n        if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) throw $8b9727f4386a7666$var$getInternalRouterError(400, {\n            method: request.method,\n            pathname: new URL(request.url).pathname,\n            routeId: routeMatch == null ? void 0 : routeMatch.route.id\n        });\n        let requestMatches = routeMatch ? [\n            routeMatch\n        ] : $8b9727f4386a7666$var$getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);\n        let matchesToLoad = requestMatches.filter((m)=>m.route.loader || m.route.lazy);\n        // Short circuit if we have no loaders to run (query())\n        if (matchesToLoad.length === 0) return {\n            matches: matches,\n            // Add a null for all matched routes for proper revalidation on the client\n            loaderData: matches.reduce((acc, m)=>Object.assign(acc, {\n                    [m.route.id]: null\n                }), {}),\n            errors: pendingActionError || null,\n            statusCode: 200,\n            loaderHeaders: {},\n            activeDeferreds: null\n        };\n        let results = await Promise.all([\n            ...matchesToLoad.map((match)=>$8b9727f4386a7666$var$callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename, {\n                    isStaticRequest: true,\n                    isRouteRequest: isRouteRequest,\n                    requestContext: requestContext\n                }))\n        ]);\n        if (request.signal.aborted) {\n            let method = isRouteRequest ? \"queryRoute\" : \"query\";\n            throw new Error(method + \"() call aborted\");\n        }\n        // Process and commit output from loaders\n        let activeDeferreds = new Map();\n        let context = $8b9727f4386a7666$var$processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds);\n        // Add a null for any non-loader matches for proper revalidation on the client\n        let executedLoaders = new Set(matchesToLoad.map((match)=>match.route.id));\n        matches.forEach((match)=>{\n            if (!executedLoaders.has(match.route.id)) context.loaderData[match.route.id] = null;\n        });\n        return $8b9727f4386a7666$var$_extends({}, context, {\n            matches: matches,\n            activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\n        });\n    }\n    return {\n        dataRoutes: dataRoutes,\n        query: query,\n        queryRoute: queryRoute\n    };\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */ function $8b9727f4386a7666$export$fec11da027c70692(routes, context, error) {\n    let newContext = $8b9727f4386a7666$var$_extends({}, context, {\n        statusCode: 500,\n        errors: {\n            [context._deepestRenderedBoundaryId || routes[0].id]: error\n        }\n    });\n    return newContext;\n}\nfunction $8b9727f4386a7666$var$isSubmissionNavigation(opts) {\n    return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== undefined);\n}\nfunction $8b9727f4386a7666$var$normalizeTo(location, matches, basename, prependBasename, to, fromRouteId, relative) {\n    let contextualMatches;\n    let activeRouteMatch;\n    if (fromRouteId != null && relative !== \"path\") {\n        // Grab matches up to the calling route so our route-relative logic is\n        // relative to the correct source route.  When using relative:path,\n        // fromRouteId is ignored since that is always relative to the current\n        // location path\n        contextualMatches = [];\n        for (let match of matches){\n            contextualMatches.push(match);\n            if (match.route.id === fromRouteId) {\n                activeRouteMatch = match;\n                break;\n            }\n        }\n    } else {\n        contextualMatches = matches;\n        activeRouteMatch = matches[matches.length - 1];\n    }\n    // Resolve the relative path\n    let path = $8b9727f4386a7666$export$cae722b0cc860f13(to ? to : \".\", $8b9727f4386a7666$export$90ba53ce1c7fdff2(contextualMatches).map((m)=>m.pathnameBase), $8b9727f4386a7666$export$b69e3301ce081aa3(location.pathname, basename) || location.pathname, relative === \"path\");\n    // When `to` is not specified we inherit search/hash from the current\n    // location, unlike when to=\".\" and we just inherit the path.\n    // See https://github.com/remix-run/remix/issues/927\n    if (to == null) {\n        path.search = location.search;\n        path.hash = location.hash;\n    }\n    // Add an ?index param for matched index routes if we don't already have one\n    if ((to == null || to === \"\" || to === \".\") && activeRouteMatch && activeRouteMatch.route.index && !$8b9727f4386a7666$var$hasNakedIndexQuery(path.search)) path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    // If we're operating within a basename, prepend it to the pathname.  If\n    // this is a root navigation, then just use the raw basename which allows\n    // the basename to have full control over the presence of a trailing slash\n    // on root actions\n    if (prependBasename && basename !== \"/\") path.pathname = path.pathname === \"/\" ? basename : $8b9727f4386a7666$export$86d9a7913e44197e([\n        basename,\n        path.pathname\n    ]);\n    return $8b9727f4386a7666$export$fe53371bee54353d(path);\n}\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction $8b9727f4386a7666$var$normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n    // Return location verbatim on non-submission navigations\n    if (!opts || !$8b9727f4386a7666$var$isSubmissionNavigation(opts)) return {\n        path: path\n    };\n    if (opts.formMethod && !$8b9727f4386a7666$var$isValidMethod(opts.formMethod)) return {\n        path: path,\n        error: $8b9727f4386a7666$var$getInternalRouterError(405, {\n            method: opts.formMethod\n        })\n    };\n    let getInvalidBodyError = ()=>({\n            path: path,\n            error: $8b9727f4386a7666$var$getInternalRouterError(400, {\n                type: \"invalid-body\"\n            })\n        });\n    // Create a Submission on non-GET navigations\n    let rawFormMethod = opts.formMethod || \"get\";\n    let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n    let formAction = $8b9727f4386a7666$var$stripHashFromPath(path);\n    if (opts.body !== undefined) {\n        if (opts.formEncType === \"text/plain\") {\n            // text only support POST/PUT/PATCH/DELETE submissions\n            if (!$8b9727f4386a7666$var$isMutationMethod(formMethod)) return getInvalidBodyError();\n            let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n            Array.from(opts.body.entries()).reduce((acc, _ref3)=>{\n                let [name, value] = _ref3;\n                return \"\" + acc + name + \"=\" + value + \"\\n\";\n            }, \"\") : String(opts.body);\n            return {\n                path: path,\n                submission: {\n                    formMethod: formMethod,\n                    formAction: formAction,\n                    formEncType: opts.formEncType,\n                    formData: undefined,\n                    json: undefined,\n                    text: text\n                }\n            };\n        } else if (opts.formEncType === \"application/json\") {\n            // json only supports POST/PUT/PATCH/DELETE submissions\n            if (!$8b9727f4386a7666$var$isMutationMethod(formMethod)) return getInvalidBodyError();\n            try {\n                let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n                return {\n                    path: path,\n                    submission: {\n                        formMethod: formMethod,\n                        formAction: formAction,\n                        formEncType: opts.formEncType,\n                        formData: undefined,\n                        json: json,\n                        text: undefined\n                    }\n                };\n            } catch (e) {\n                return getInvalidBodyError();\n            }\n        }\n    }\n    $8b9727f4386a7666$export$3e9cee6b33872309(typeof FormData === \"function\", \"FormData is not available in this environment\");\n    let searchParams;\n    let formData;\n    if (opts.formData) {\n        searchParams = $8b9727f4386a7666$var$convertFormDataToSearchParams(opts.formData);\n        formData = opts.formData;\n    } else if (opts.body instanceof FormData) {\n        searchParams = $8b9727f4386a7666$var$convertFormDataToSearchParams(opts.body);\n        formData = opts.body;\n    } else if (opts.body instanceof URLSearchParams) {\n        searchParams = opts.body;\n        formData = $8b9727f4386a7666$var$convertSearchParamsToFormData(searchParams);\n    } else if (opts.body == null) {\n        searchParams = new URLSearchParams();\n        formData = new FormData();\n    } else try {\n        searchParams = new URLSearchParams(opts.body);\n        formData = $8b9727f4386a7666$var$convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n        return getInvalidBodyError();\n    }\n    let submission = {\n        formMethod: formMethod,\n        formAction: formAction,\n        formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n        formData: formData,\n        json: undefined,\n        text: undefined\n    };\n    if ($8b9727f4386a7666$var$isMutationMethod(submission.formMethod)) return {\n        path: path,\n        submission: submission\n    };\n    // Flatten submission onto URLSearchParams for GET submissions\n    let parsedPath = $8b9727f4386a7666$export$8ccf933b0513f8d0(path);\n    // On GET navigation submissions we can drop the ?index param from the\n    // resulting location since all loaders will run.  But fetcher GET submissions\n    // only run a single loader so we need to preserve any incoming ?index params\n    if (isFetcher && parsedPath.search && $8b9727f4386a7666$var$hasNakedIndexQuery(parsedPath.search)) searchParams.append(\"index\", \"\");\n    parsedPath.search = \"?\" + searchParams;\n    return {\n        path: $8b9727f4386a7666$export$fe53371bee54353d(parsedPath),\n        submission: submission\n    };\n}\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction $8b9727f4386a7666$var$getLoaderMatchesUntilBoundary(matches, boundaryId) {\n    let boundaryMatches = matches;\n    if (boundaryId) {\n        let index = matches.findIndex((m)=>m.route.id === boundaryId);\n        if (index >= 0) boundaryMatches = matches.slice(0, index);\n    }\n    return boundaryMatches;\n}\nfunction $8b9727f4386a7666$var$getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\n    let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;\n    let currentUrl = history.createURL(state.location);\n    let nextUrl = history.createURL(location);\n    // Pick navigation matches that are net-new or qualify for revalidation\n    let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n    let boundaryMatches = $8b9727f4386a7666$var$getLoaderMatchesUntilBoundary(matches, boundaryId);\n    let navigationMatches = boundaryMatches.filter((match, index)=>{\n        if (match.route.lazy) // We haven't loaded this route yet so we don't know if it's got a loader!\n        return true;\n        if (match.route.loader == null) return false;\n        // Always call the loader on new route instances and pending defer cancellations\n        if ($8b9727f4386a7666$var$isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some((id)=>id === match.route.id)) return true;\n        // This is the default implementation for when we revalidate.  If the route\n        // provides it's own implementation, then we give them full control but\n        // provide this value so they can leverage it if needed after they check\n        // their own specific use cases\n        let currentRouteMatch = state.matches[index];\n        let nextRouteMatch = match;\n        return $8b9727f4386a7666$var$shouldRevalidateLoader(match, $8b9727f4386a7666$var$_extends({\n            currentUrl: currentUrl,\n            currentParams: currentRouteMatch.params,\n            nextUrl: nextUrl,\n            nextParams: nextRouteMatch.params\n        }, submission, {\n            actionResult: actionResult,\n            defaultShouldRevalidate: // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n            isRevalidationRequired || // Clicked the same link, resubmitted a GET form\n            currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders\n            currentUrl.search !== nextUrl.search || $8b9727f4386a7666$var$isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n        }));\n    });\n    // Pick fetcher.loads that need to be revalidated\n    let revalidatingFetchers = [];\n    fetchLoadMatches.forEach((f, key)=>{\n        // Don't revalidate if fetcher won't be present in the subsequent render\n        if (!matches.some((m)=>m.route.id === f.routeId)) return;\n        let fetcherMatches = $8b9727f4386a7666$export$2708184779ceb39d(routesToUse, f.path, basename);\n        // If the fetcher path no longer matches, push it in with null matches so\n        // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n        // currently only a use-case for Remix HMR where the route tree can change\n        // at runtime and remove a route previously loaded via a fetcher\n        if (!fetcherMatches) {\n            revalidatingFetchers.push({\n                key: key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: null,\n                match: null,\n                controller: null\n            });\n            return;\n        }\n        // Revalidating fetchers are decoupled from the route matches since they\n        // load from a static href.  They revalidate based on explicit revalidation\n        // (submission, useRevalidator, or X-Remix-Revalidate)\n        let fetcher = state.fetchers.get(key);\n        let fetcherMatch = $8b9727f4386a7666$var$getTargetMatch(fetcherMatches, f.path);\n        let shouldRevalidate = false;\n        if (fetchRedirectIds.has(key)) // Never trigger a revalidation of an actively redirecting fetcher\n        shouldRevalidate = false;\n        else if (cancelledFetcherLoads.includes(key)) // Always revalidate if the fetcher was cancelled\n        shouldRevalidate = true;\n        else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === undefined) // If the fetcher hasn't ever completed loading yet, then this isn't a\n        // revalidation, it would just be a brand new load if an explicit\n        // revalidation is required\n        shouldRevalidate = isRevalidationRequired;\n        else // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n        // to explicit revalidations only\n        shouldRevalidate = $8b9727f4386a7666$var$shouldRevalidateLoader(fetcherMatch, $8b9727f4386a7666$var$_extends({\n            currentUrl: currentUrl,\n            currentParams: state.matches[state.matches.length - 1].params,\n            nextUrl: nextUrl,\n            nextParams: matches[matches.length - 1].params\n        }, submission, {\n            actionResult: actionResult,\n            defaultShouldRevalidate: isRevalidationRequired\n        }));\n        if (shouldRevalidate) revalidatingFetchers.push({\n            key: key,\n            routeId: f.routeId,\n            path: f.path,\n            matches: fetcherMatches,\n            match: fetcherMatch,\n            controller: new AbortController()\n        });\n    });\n    return [\n        navigationMatches,\n        revalidatingFetchers\n    ];\n}\nfunction $8b9727f4386a7666$var$isNewLoader(currentLoaderData, currentMatch, match) {\n    let isNew = // [a] -> [a, b]\n    !currentMatch || // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id;\n    // Handle the case that we don't have data for a re-used route, potentially\n    // from a prior error or from a cancelled pending deferred\n    let isMissingData = currentLoaderData[match.route.id] === undefined;\n    // Always load if this is a net-new route or we don't yet have data\n    return isNew || isMissingData;\n}\nfunction $8b9727f4386a7666$var$isNewRouteInstance(currentMatch, match) {\n    let currentPath = currentMatch.route.path;\n    return(// param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]);\n}\nfunction $8b9727f4386a7666$var$shouldRevalidateLoader(loaderMatch, arg) {\n    if (loaderMatch.route.shouldRevalidate) {\n        let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n        if (typeof routeChoice === \"boolean\") return routeChoice;\n    }\n    return arg.defaultShouldRevalidate;\n}\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */ async function $8b9727f4386a7666$var$loadLazyRouteModule(route, mapRouteProperties, manifest) {\n    if (!route.lazy) return;\n    let lazyRoute = await route.lazy();\n    // If the lazy route function was executed and removed by another parallel\n    // call then we can return - first lazy() to finish wins because the return\n    // value of lazy is expected to be static\n    if (!route.lazy) return;\n    let routeToUpdate = manifest[route.id];\n    $8b9727f4386a7666$export$3e9cee6b33872309(routeToUpdate, \"No route found in manifest\");\n    // Update the route in place.  This should be safe because there's no way\n    // we could yet be sitting on this route as we can't get there without\n    // resolving lazy() first.\n    //\n    // This is different than the HMR \"update\" use-case where we may actively be\n    // on the route being updated.  The main concern boils down to \"does this\n    // mutation affect any ongoing navigations or any current state.matches\n    // values?\".  If not, it should be safe to update in place.\n    let routeUpdates = {};\n    for(let lazyRouteProperty in lazyRoute){\n        let staticRouteValue = routeToUpdate[lazyRouteProperty];\n        let isPropertyStaticallyDefined = staticRouteValue !== undefined && // This property isn't static since it should always be updated based\n        // on the route updates\n        lazyRouteProperty !== \"hasErrorBoundary\";\n        $8b9727f4386a7666$export$c0e02632e14916fd(!isPropertyStaticallyDefined, 'Route \"' + routeToUpdate.id + '\" has a static property \"' + lazyRouteProperty + '\" ' + \"defined but its lazy function is also returning a value for this property. \" + ('The lazy route property \"' + lazyRouteProperty + '\" will be ignored.'));\n        if (!isPropertyStaticallyDefined && !$8b9727f4386a7666$var$immutableRouteKeys.has(lazyRouteProperty)) routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n    }\n    // Mutate the route with the provided updates.  Do this first so we pass\n    // the updated version to mapRouteProperties\n    Object.assign(routeToUpdate, routeUpdates);\n    // Mutate the `hasErrorBoundary` property on the route based on the route\n    // updates and remove the `lazy` function so we don't resolve the lazy\n    // route again.\n    Object.assign(routeToUpdate, $8b9727f4386a7666$var$_extends({}, mapRouteProperties(routeToUpdate), {\n        lazy: undefined\n    }));\n}\nasync function $8b9727f4386a7666$var$callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, opts) {\n    if (opts === void 0) opts = {};\n    let resultType;\n    let result;\n    let onReject;\n    let runHandler = (handler)=>{\n        // Setup a promise we can race against so that abort signals short circuit\n        let reject;\n        let abortPromise = new Promise((_, r)=>reject = r);\n        onReject = ()=>reject();\n        request.signal.addEventListener(\"abort\", onReject);\n        return Promise.race([\n            handler({\n                request: request,\n                params: match.params,\n                context: opts.requestContext\n            }),\n            abortPromise\n        ]);\n    };\n    try {\n        let handler = match.route[type];\n        if (match.route.lazy) {\n            if (handler) {\n                // Run statically defined handler in parallel with lazy()\n                let values = await Promise.all([\n                    runHandler(handler),\n                    $8b9727f4386a7666$var$loadLazyRouteModule(match.route, mapRouteProperties, manifest)\n                ]);\n                result = values[0];\n            } else {\n                // Load lazy route module, then run any returned handler\n                await $8b9727f4386a7666$var$loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n                handler = match.route[type];\n                if (handler) // Handler still run even if we got interrupted to maintain consistency\n                // with un-abortable behavior of handler execution on non-lazy or\n                // previously-lazy-loaded routes\n                result = await runHandler(handler);\n                else if (type === \"action\") {\n                    let url = new URL(request.url);\n                    let pathname = url.pathname + url.search;\n                    throw $8b9727f4386a7666$var$getInternalRouterError(405, {\n                        method: request.method,\n                        pathname: pathname,\n                        routeId: match.route.id\n                    });\n                } else // lazy() route has no loader to run.  Short circuit here so we don't\n                // hit the invariant below that errors on returning undefined.\n                return {\n                    type: $8b9727f4386a7666$var$ResultType.data,\n                    data: undefined\n                };\n            }\n        } else if (!handler) {\n            let url = new URL(request.url);\n            let pathname = url.pathname + url.search;\n            throw $8b9727f4386a7666$var$getInternalRouterError(404, {\n                pathname: pathname\n            });\n        } else result = await runHandler(handler);\n        $8b9727f4386a7666$export$3e9cee6b33872309(result !== undefined, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + ('\"' + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\n    } catch (e) {\n        resultType = $8b9727f4386a7666$var$ResultType.error;\n        result = e;\n    } finally{\n        if (onReject) request.signal.removeEventListener(\"abort\", onReject);\n    }\n    if ($8b9727f4386a7666$var$isResponse(result)) {\n        let status = result.status;\n        // Process redirects\n        if ($8b9727f4386a7666$var$redirectStatusCodes.has(status)) {\n            let location = result.headers.get(\"Location\");\n            $8b9727f4386a7666$export$3e9cee6b33872309(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n            // Support relative routing in internal redirects\n            if (!$8b9727f4386a7666$var$ABSOLUTE_URL_REGEX.test(location)) location = $8b9727f4386a7666$var$normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location);\n            else if (!opts.isStaticRequest) {\n                // Strip off the protocol+origin for same-origin + same-basename absolute\n                // redirects. If this is a static request, we can let it go back to the\n                // browser as-is\n                let currentUrl = new URL(request.url);\n                let url = location.startsWith(\"//\") ? new URL(currentUrl.protocol + location) : new URL(location);\n                let isSameBasename = $8b9727f4386a7666$export$b69e3301ce081aa3(url.pathname, basename) != null;\n                if (url.origin === currentUrl.origin && isSameBasename) location = url.pathname + url.search + url.hash;\n            }\n            // Don't process redirects in the router during static requests requests.\n            // Instead, throw the Response and let the server handle it with an HTTP\n            // redirect.  We also update the Location header in place in this flow so\n            // basename and relative routing is taken into account\n            if (opts.isStaticRequest) {\n                result.headers.set(\"Location\", location);\n                throw result;\n            }\n            return {\n                type: $8b9727f4386a7666$var$ResultType.redirect,\n                status: status,\n                location: location,\n                revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null\n            };\n        }\n        // For SSR single-route requests, we want to hand Responses back directly\n        // without unwrapping.  We do this with the QueryRouteResponse wrapper\n        // interface so we can know whether it was returned or thrown\n        if (opts.isRouteRequest) // eslint-disable-next-line no-throw-literal\n        throw {\n            type: resultType || $8b9727f4386a7666$var$ResultType.data,\n            response: result\n        };\n        let data;\n        let contentType = result.headers.get(\"Content-Type\");\n        // Check between word boundaries instead of startsWith() due to the last\n        // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n        if (contentType && /\\bapplication\\/json\\b/.test(contentType)) data = await result.json();\n        else data = await result.text();\n        if (resultType === $8b9727f4386a7666$var$ResultType.error) return {\n            type: resultType,\n            error: new $8b9727f4386a7666$export$acf1a680051f5031(status, result.statusText, data),\n            headers: result.headers\n        };\n        return {\n            type: $8b9727f4386a7666$var$ResultType.data,\n            data: data,\n            statusCode: result.status,\n            headers: result.headers\n        };\n    }\n    if (resultType === $8b9727f4386a7666$var$ResultType.error) return {\n        type: resultType,\n        error: result\n    };\n    if ($8b9727f4386a7666$export$fbcedacb60443473(result)) {\n        var _result$init, _result$init2;\n        return {\n            type: $8b9727f4386a7666$var$ResultType.deferred,\n            deferredData: result,\n            statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n            headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n        };\n    }\n    return {\n        type: $8b9727f4386a7666$var$ResultType.data,\n        data: result\n    };\n}\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction $8b9727f4386a7666$var$createClientSideRequest(history, location, signal, submission) {\n    let url = history.createURL($8b9727f4386a7666$var$stripHashFromPath(location)).toString();\n    let init = {\n        signal: signal\n    };\n    if (submission && $8b9727f4386a7666$var$isMutationMethod(submission.formMethod)) {\n        let { formMethod: formMethod, formEncType: formEncType } = submission;\n        // Didn't think we needed this but it turns out unlike other methods, patch\n        // won't be properly normalized to uppercase and results in a 405 error.\n        // See: https://fetch.spec.whatwg.org/#concept-method\n        init.method = formMethod.toUpperCase();\n        if (formEncType === \"application/json\") {\n            init.headers = new Headers({\n                \"Content-Type\": formEncType\n            });\n            init.body = JSON.stringify(submission.json);\n        } else if (formEncType === \"text/plain\") // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n        init.body = submission.text;\n        else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n        init.body = $8b9727f4386a7666$var$convertFormDataToSearchParams(submission.formData);\n        else // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n        init.body = submission.formData;\n    }\n    return new Request(url, init);\n}\nfunction $8b9727f4386a7666$var$convertFormDataToSearchParams(formData) {\n    let searchParams = new URLSearchParams();\n    for (let [key, value] of formData.entries())// https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n    return searchParams;\n}\nfunction $8b9727f4386a7666$var$convertSearchParamsToFormData(searchParams) {\n    let formData = new FormData();\n    for (let [key, value] of searchParams.entries())formData.append(key, value);\n    return formData;\n}\nfunction $8b9727f4386a7666$var$processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n    // Fill in loaderData/errors from our loaders\n    let loaderData = {};\n    let errors = null;\n    let statusCode;\n    let foundError = false;\n    let loaderHeaders = {};\n    // Process loader results into state.loaderData/state.errors\n    results.forEach((result, index)=>{\n        let id = matchesToLoad[index].route.id;\n        $8b9727f4386a7666$export$3e9cee6b33872309(!$8b9727f4386a7666$var$isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n        if ($8b9727f4386a7666$var$isErrorResult(result)) {\n            // Look upwards from the matched route for the closest ancestor\n            // error boundary, defaulting to the root match\n            let boundaryMatch = $8b9727f4386a7666$var$findNearestBoundary(matches, id);\n            let error = result.error;\n            // If we have a pending action error, we report it at the highest-route\n            // that throws a loader error, and then clear it out to indicate that\n            // it was consumed\n            if (pendingError) {\n                error = Object.values(pendingError)[0];\n                pendingError = undefined;\n            }\n            errors = errors || {};\n            // Prefer higher error values if lower errors bubble to the same boundary\n            if (errors[boundaryMatch.route.id] == null) errors[boundaryMatch.route.id] = error;\n            // Clear our any prior loaderData for the throwing route\n            loaderData[id] = undefined;\n            // Once we find our first (highest) error, we set the status code and\n            // prevent deeper status codes from overriding\n            if (!foundError) {\n                foundError = true;\n                statusCode = $8b9727f4386a7666$export$972111febbeef05b(result.error) ? result.error.status : 500;\n            }\n            if (result.headers) loaderHeaders[id] = result.headers;\n        } else {\n            if ($8b9727f4386a7666$var$isDeferredResult(result)) {\n                activeDeferreds.set(id, result.deferredData);\n                loaderData[id] = result.deferredData.data;\n            } else loaderData[id] = result.data;\n            // Error status codes always override success status codes, but if all\n            // loaders are successful we take the deepest status code.\n            if (result.statusCode != null && result.statusCode !== 200 && !foundError) statusCode = result.statusCode;\n            if (result.headers) loaderHeaders[id] = result.headers;\n        }\n    });\n    // If we didn't consume the pending action error (i.e., all loaders\n    // resolved), then consume it here.  Also clear out any loaderData for the\n    // throwing route\n    if (pendingError) {\n        errors = pendingError;\n        loaderData[Object.keys(pendingError)[0]] = undefined;\n    }\n    return {\n        loaderData: loaderData,\n        errors: errors,\n        statusCode: statusCode || 200,\n        loaderHeaders: loaderHeaders\n    };\n}\nfunction $8b9727f4386a7666$var$processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n    let { loaderData: loaderData, errors: errors } = $8b9727f4386a7666$var$processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);\n    // Process results from our revalidating fetchers\n    for(let index = 0; index < revalidatingFetchers.length; index++){\n        let { key: key, match: match, controller: controller } = revalidatingFetchers[index];\n        $8b9727f4386a7666$export$3e9cee6b33872309(fetcherResults !== undefined && fetcherResults[index] !== undefined, \"Did not find corresponding fetcher result\");\n        let result = fetcherResults[index];\n        // Process fetcher non-redirect errors\n        if (controller && controller.signal.aborted) continue;\n        else if ($8b9727f4386a7666$var$isErrorResult(result)) {\n            let boundaryMatch = $8b9727f4386a7666$var$findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n            if (!(errors && errors[boundaryMatch.route.id])) errors = $8b9727f4386a7666$var$_extends({}, errors, {\n                [boundaryMatch.route.id]: result.error\n            });\n            state.fetchers.delete(key);\n        } else if ($8b9727f4386a7666$var$isRedirectResult(result)) // Should never get here, redirects should get processed above, but we\n        // keep this to type narrow to a success result in the else\n        $8b9727f4386a7666$export$3e9cee6b33872309(false, \"Unhandled fetcher revalidation redirect\");\n        else if ($8b9727f4386a7666$var$isDeferredResult(result)) // Should never get here, deferred data should be awaited for fetchers\n        // in resolveDeferredResults\n        $8b9727f4386a7666$export$3e9cee6b33872309(false, \"Unhandled fetcher deferred data\");\n        else {\n            let doneFetcher = $8b9727f4386a7666$var$getDoneFetcher(result.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    return {\n        loaderData: loaderData,\n        errors: errors\n    };\n}\nfunction $8b9727f4386a7666$var$mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n    let mergedLoaderData = $8b9727f4386a7666$var$_extends({}, newLoaderData);\n    for (let match of matches){\n        let id = match.route.id;\n        if (newLoaderData.hasOwnProperty(id)) {\n            if (newLoaderData[id] !== undefined) mergedLoaderData[id] = newLoaderData[id];\n        } else if (loaderData[id] !== undefined && match.route.loader) // Preserve existing keys not included in newLoaderData and where a loader\n        // wasn't removed by HMR\n        mergedLoaderData[id] = loaderData[id];\n        if (errors && errors.hasOwnProperty(id)) break;\n    }\n    return mergedLoaderData;\n}\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction $8b9727f4386a7666$var$findNearestBoundary(matches, routeId) {\n    let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m)=>m.route.id === routeId) + 1) : [\n        ...matches\n    ];\n    return eligibleMatches.reverse().find((m)=>m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction $8b9727f4386a7666$var$getShortCircuitMatches(routes) {\n    // Prefer a root layout route if present, otherwise shim in a route object\n    let route = routes.find((r)=>r.index || !r.path || r.path === \"/\") || {\n        id: \"__shim-error-route__\"\n    };\n    return {\n        matches: [\n            {\n                params: {},\n                pathname: \"\",\n                pathnameBase: \"\",\n                route: route\n            }\n        ],\n        route: route\n    };\n}\nfunction $8b9727f4386a7666$var$getInternalRouterError(status, _temp4) {\n    let { pathname: pathname, routeId: routeId, method: method, type: type } = _temp4 === void 0 ? {} : _temp4;\n    let statusText = \"Unknown Server Error\";\n    let errorMessage = \"Unknown @remix-run/router error\";\n    if (status === 400) {\n        statusText = \"Bad Request\";\n        if (method && pathname && routeId) errorMessage = \"You made a \" + method + ' request to \"' + pathname + '\" but ' + ('did not provide a `loader` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n        else if (type === \"defer-action\") errorMessage = \"defer() is not supported in actions\";\n        else if (type === \"invalid-body\") errorMessage = \"Unable to encode submission body\";\n    } else if (status === 403) {\n        statusText = \"Forbidden\";\n        errorMessage = 'Route \"' + routeId + '\" does not match URL \"' + pathname + '\"';\n    } else if (status === 404) {\n        statusText = \"Not Found\";\n        errorMessage = 'No route matches URL \"' + pathname + '\"';\n    } else if (status === 405) {\n        statusText = \"Method Not Allowed\";\n        if (method && pathname && routeId) errorMessage = \"You made a \" + method.toUpperCase() + ' request to \"' + pathname + '\" but ' + ('did not provide an `action` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n        else if (method) errorMessage = 'Invalid request method \"' + method.toUpperCase() + '\"';\n    }\n    return new $8b9727f4386a7666$export$acf1a680051f5031(status || 500, statusText, new Error(errorMessage), true);\n}\n// Find any returned redirect errors, starting from the lowest match\nfunction $8b9727f4386a7666$var$findRedirect(results) {\n    for(let i = results.length - 1; i >= 0; i--){\n        let result = results[i];\n        if ($8b9727f4386a7666$var$isRedirectResult(result)) return {\n            result: result,\n            idx: i\n        };\n    }\n}\nfunction $8b9727f4386a7666$var$stripHashFromPath(path) {\n    let parsedPath = typeof path === \"string\" ? $8b9727f4386a7666$export$8ccf933b0513f8d0(path) : path;\n    return $8b9727f4386a7666$export$fe53371bee54353d($8b9727f4386a7666$var$_extends({}, parsedPath, {\n        hash: \"\"\n    }));\n}\nfunction $8b9727f4386a7666$var$isHashChangeOnly(a, b) {\n    if (a.pathname !== b.pathname || a.search !== b.search) return false;\n    if (a.hash === \"\") // /page -> /page#hash\n    return b.hash !== \"\";\n    else if (a.hash === b.hash) // /page#hash -> /page#hash\n    return true;\n    else if (b.hash !== \"\") // /page#hash -> /page#other\n    return true;\n    // If the hash is removed the browser will re-perform a request to the server\n    // /page#hash -> /page\n    return false;\n}\nfunction $8b9727f4386a7666$var$isDeferredResult(result) {\n    return result.type === $8b9727f4386a7666$var$ResultType.deferred;\n}\nfunction $8b9727f4386a7666$var$isErrorResult(result) {\n    return result.type === $8b9727f4386a7666$var$ResultType.error;\n}\nfunction $8b9727f4386a7666$var$isRedirectResult(result) {\n    return (result && result.type) === $8b9727f4386a7666$var$ResultType.redirect;\n}\nfunction $8b9727f4386a7666$export$fbcedacb60443473(value) {\n    let deferred = value;\n    return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction $8b9727f4386a7666$var$isResponse(value) {\n    return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction $8b9727f4386a7666$var$isRedirectResponse(result) {\n    if (!$8b9727f4386a7666$var$isResponse(result)) return false;\n    let status = result.status;\n    let location = result.headers.get(\"Location\");\n    return status >= 300 && status <= 399 && location != null;\n}\nfunction $8b9727f4386a7666$var$isQueryRouteResponse(obj) {\n    return obj && $8b9727f4386a7666$var$isResponse(obj.response) && (obj.type === $8b9727f4386a7666$var$ResultType.data || $8b9727f4386a7666$var$ResultType.error);\n}\nfunction $8b9727f4386a7666$var$isValidMethod(method) {\n    return $8b9727f4386a7666$var$validRequestMethods.has(method.toLowerCase());\n}\nfunction $8b9727f4386a7666$var$isMutationMethod(method) {\n    return $8b9727f4386a7666$var$validMutationMethods.has(method.toLowerCase());\n}\nasync function $8b9727f4386a7666$var$resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n    for(let index = 0; index < results.length; index++){\n        let result = results[index];\n        let match = matchesToLoad[index];\n        // If we don't have a match, then we can have a deferred result to do\n        // anything with.  This is for revalidating fetchers where the route was\n        // removed during HMR\n        if (!match) continue;\n        let currentMatch = currentMatches.find((m)=>m.route.id === match.route.id);\n        let isRevalidatingLoader = currentMatch != null && !$8b9727f4386a7666$var$isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n        if ($8b9727f4386a7666$var$isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n            // Note: we do not have to touch activeDeferreds here since we race them\n            // against the signal in resolveDeferredData and they'll get aborted\n            // there if needed\n            let signal = signals[index];\n            $8b9727f4386a7666$export$3e9cee6b33872309(signal, \"Expected an AbortSignal for revalidating fetcher deferred result\");\n            await $8b9727f4386a7666$var$resolveDeferredData(result, signal, isFetcher).then((result)=>{\n                if (result) results[index] = result || results[index];\n            });\n        }\n    }\n}\nasync function $8b9727f4386a7666$var$resolveDeferredData(result, signal, unwrap) {\n    if (unwrap === void 0) unwrap = false;\n    let aborted = await result.deferredData.resolveData(signal);\n    if (aborted) return;\n    if (unwrap) try {\n        return {\n            type: $8b9727f4386a7666$var$ResultType.data,\n            data: result.deferredData.unwrappedData\n        };\n    } catch (e) {\n        // Handle any TrackedPromise._error values encountered while unwrapping\n        return {\n            type: $8b9727f4386a7666$var$ResultType.error,\n            error: e\n        };\n    }\n    return {\n        type: $8b9727f4386a7666$var$ResultType.data,\n        data: result.deferredData.data\n    };\n}\nfunction $8b9727f4386a7666$var$hasNakedIndexQuery(search) {\n    return new URLSearchParams(search).getAll(\"index\").some((v)=>v === \"\");\n}\n// Note: This should match the format exported by useMatches, so if you change\n// this please also change that :)  Eventually we'll DRY this up\nfunction $8b9727f4386a7666$var$createUseMatchesMatch(match, loaderData) {\n    let { route: route, pathname: pathname, params: params } = match;\n    return {\n        id: route.id,\n        pathname: pathname,\n        params: params,\n        data: loaderData[route.id],\n        handle: route.handle\n    };\n}\nfunction $8b9727f4386a7666$var$getTargetMatch(matches, location) {\n    let search = typeof location === \"string\" ? $8b9727f4386a7666$export$8ccf933b0513f8d0(location).search : location.search;\n    if (matches[matches.length - 1].route.index && $8b9727f4386a7666$var$hasNakedIndexQuery(search || \"\")) // Return the leaf index route when index is present\n    return matches[matches.length - 1];\n    // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n    // pathless layout routes)\n    let pathMatches = $8b9727f4386a7666$export$90ba53ce1c7fdff2(matches);\n    return pathMatches[pathMatches.length - 1];\n}\nfunction $8b9727f4386a7666$var$getSubmissionFromNavigation(navigation) {\n    let { formMethod: formMethod, formAction: formAction, formEncType: formEncType, text: text, formData: formData, json: json } = navigation;\n    if (!formMethod || !formAction || !formEncType) return;\n    if (text != null) return {\n        formMethod: formMethod,\n        formAction: formAction,\n        formEncType: formEncType,\n        formData: undefined,\n        json: undefined,\n        text: text\n    };\n    else if (formData != null) return {\n        formMethod: formMethod,\n        formAction: formAction,\n        formEncType: formEncType,\n        formData: formData,\n        json: undefined,\n        text: undefined\n    };\n    else if (json !== undefined) return {\n        formMethod: formMethod,\n        formAction: formAction,\n        formEncType: formEncType,\n        formData: undefined,\n        json: json,\n        text: undefined\n    };\n}\nfunction $8b9727f4386a7666$var$getLoadingNavigation(location, submission) {\n    if (submission) {\n        let navigation = {\n            state: \"loading\",\n            location: location,\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text\n        };\n        return navigation;\n    } else {\n        let navigation = {\n            state: \"loading\",\n            location: location,\n            formMethod: undefined,\n            formAction: undefined,\n            formEncType: undefined,\n            formData: undefined,\n            json: undefined,\n            text: undefined\n        };\n        return navigation;\n    }\n}\nfunction $8b9727f4386a7666$var$getSubmittingNavigation(location, submission) {\n    let navigation = {\n        state: \"submitting\",\n        location: location,\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text\n    };\n    return navigation;\n}\nfunction $8b9727f4386a7666$var$getLoadingFetcher(submission, data) {\n    if (submission) {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text,\n            data: data,\n            \" _hasFetcherDoneAnything \": true\n        };\n        return fetcher;\n    } else {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: undefined,\n            formAction: undefined,\n            formEncType: undefined,\n            formData: undefined,\n            json: undefined,\n            text: undefined,\n            data: data,\n            \" _hasFetcherDoneAnything \": true\n        };\n        return fetcher;\n    }\n}\nfunction $8b9727f4386a7666$var$getSubmittingFetcher(submission, existingFetcher) {\n    let fetcher = {\n        state: \"submitting\",\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text,\n        data: existingFetcher ? existingFetcher.data : undefined,\n        \" _hasFetcherDoneAnything \": true\n    };\n    return fetcher;\n}\nfunction $8b9727f4386a7666$var$getDoneFetcher(data) {\n    let fetcher = {\n        state: \"idle\",\n        formMethod: undefined,\n        formAction: undefined,\n        formEncType: undefined,\n        formData: undefined,\n        json: undefined,\n        text: undefined,\n        data: data,\n        \" _hasFetcherDoneAnything \": true\n    };\n    return fetcher;\n}\n\n});\n\n\n\n\n//# sourceMappingURL=dist.62604c19.js.map\n","/**\n * React Router DOM v6.14.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { UNSAFE_mapRouteProperties, Router, UNSAFE_NavigationContext, useHref, useResolvedPath, useLocation, UNSAFE_DataRouterStateContext, useNavigate, createPath, UNSAFE_useRouteId, UNSAFE_RouteContext, useMatches, useNavigation, unstable_useBlocker, UNSAFE_DataRouterContext } from 'react-router';\nexport { AbortedDeferredError, Await, MemoryRouter, Navigate, NavigationType, Outlet, Route, Router, RouterProvider, Routes, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, UNSAFE_LocationContext, UNSAFE_NavigationContext, UNSAFE_RouteContext, UNSAFE_useRouteId, createMemoryRouter, createPath, createRoutesFromChildren, createRoutesFromElements, defer, generatePath, isRouteErrorResponse, json, matchPath, matchRoutes, parsePath, redirect, renderMatches, resolvePath, unstable_useBlocker, useActionData, useAsyncError, useAsyncValue, useHref, useInRouterContext, useLoaderData, useLocation, useMatch, useMatches, useNavigate, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRevalidator, useRouteError, useRouteLoaderData, useRoutes } from 'react-router';\nimport { stripBasename, UNSAFE_warning, createRouter, createBrowserHistory, createHashHistory, ErrorResponse, UNSAFE_invariant, joinPaths } from '@remix-run/router';\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nconst defaultMethod = \"get\";\nconst defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n  return event.button === 0 && (\n  // Ignore everything but left clicks\n  !target || target === \"_self\") &&\n  // Let browser handle \"target=_blank\" etc.\n  !isModifiedEvent(event) // Ignore clicks with modifier keys\n  ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */\nfunction createSearchParams(init) {\n  if (init === void 0) {\n    init = \"\";\n  }\n  return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\n    let value = init[key];\n    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);\n  }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n  let searchParams = createSearchParams(locationSearch);\n  if (defaultSearchParams) {\n    for (let key of defaultSearchParams.keys()) {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach(value => {\n          searchParams.append(key, value);\n        });\n      }\n    }\n  }\n  return searchParams;\n}\n// One-time check for submitter support\nlet _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n  if (_formDataSupportsSubmitter === null) {\n    try {\n      new FormData(document.createElement(\"form\"),\n      // @ts-expect-error if FormData supports the submitter parameter, this will throw\n      0);\n      _formDataSupportsSubmitter = false;\n    } catch (e) {\n      _formDataSupportsSubmitter = true;\n    }\n  }\n  return _formDataSupportsSubmitter;\n}\nconst supportedFormEncTypes = new Set([\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"]);\nfunction getFormEncType(encType) {\n  if (encType != null && !supportedFormEncTypes.has(encType)) {\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"\\\"\" + encType + \"\\\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` \" + (\"and will default to \\\"\" + defaultEncType + \"\\\"\")) : void 0;\n    return null;\n  }\n  return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n  let method;\n  let action;\n  let encType;\n  let formData;\n  let body;\n  if (isFormElement(target)) {\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we'll\n    // re-prefix in the router\n    let attr = target.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(target);\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n    let form = target.form;\n    if (form == null) {\n      throw new Error(\"Cannot submit a <button> or <input type=\\\"submit\\\"> without a <form>\");\n    }\n    // <button>/<input type=\"submit\"> may override attributes of <form>\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we'll\n    // re-prefix in the router\n    let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n    // Build a FormData object populated from a form and submitter\n    formData = new FormData(form, target);\n    // If this browser doesn't support the `FormData(el, submitter)` format,\n    // then tack on the submitter value at the end.  This is a lightweight\n    // solution that is not 100% spec compliant.  For complete support in older\n    // browsers, consider using the `formdata-submitter-polyfill` package\n    if (!isFormDataSubmitterSupported()) {\n      let {\n        name,\n        type,\n        value\n      } = target;\n      if (type === \"image\") {\n        let prefix = name ? name + \".\" : \"\";\n        formData.append(prefix + \"x\", \"0\");\n        formData.append(prefix + \"y\", \"0\");\n      } else if (name) {\n        formData.append(name, value);\n      }\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + \"<input type=\\\"submit|image\\\">\");\n  } else {\n    method = defaultMethod;\n    action = null;\n    encType = defaultEncType;\n    body = target;\n  }\n  // Send body for <Form encType=\"text/plain\" so we encode it into text\n  if (formData && encType === \"text/plain\") {\n    body = formData;\n    formData = undefined;\n  }\n  return {\n    action,\n    method: method.toLowerCase(),\n    encType,\n    formData,\n    body\n  };\n}\n\nconst _excluded = [\"onClick\", \"relative\", \"reloadDocument\", \"replace\", \"state\", \"target\", \"to\", \"preventScrollReset\"],\n  _excluded2 = [\"aria-current\", \"caseSensitive\", \"className\", \"end\", \"style\", \"to\", \"children\"],\n  _excluded3 = [\"reloadDocument\", \"replace\", \"state\", \"method\", \"action\", \"onSubmit\", \"submit\", \"relative\", \"preventScrollReset\"];\nfunction createBrowserRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createBrowserHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties: UNSAFE_mapRouteProperties\n  }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createHashHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties: UNSAFE_mapRouteProperties\n  }).initialize();\n}\nfunction parseHydrationData() {\n  var _window;\n  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n  if (state && state.errors) {\n    state = _extends({}, state, {\n      errors: deserializeErrors(state.errors)\n    });\n  }\n  return state;\n}\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // serializeErrors in react-router-dom/server.tsx :)\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new ErrorResponse(val.status, val.statusText, val.data, val.internal === true);\n    } else if (val && val.__type === \"Error\") {\n      // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            // @ts-expect-error\n            let error = new ErrorConstructor(val.message);\n            // Wipe away the client-side stack trace.  Nothing to fill it in with\n            // because we don't serialize SSR stack traces for security reasons\n            error.stack = \"\";\n            serialized[key] = error;\n          } catch (e) {\n            // no-op - fall through and create a normal Error\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        // Wipe away the client-side stack trace.  Nothing to fill it in with\n        // because we don't serialize SSR stack traces for security reasons\n        error.stack = \"\";\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nconst START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = React[START_TRANSITION];\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */\nfunction BrowserRouter(_ref) {\n  let {\n    basename,\n    children,\n    future,\n    window\n  } = _ref;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({\n      window,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */\nfunction HashRouter(_ref2) {\n  let {\n    basename,\n    children,\n    future,\n    window\n  } = _ref2;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({\n      window,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */\nfunction HistoryRouter(_ref3) {\n  let {\n    basename,\n    children,\n    future,\n    history\n  } = _ref3;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\nif (process.env.NODE_ENV !== \"production\") {\n  HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\nconst isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n/**\n * The public API for rendering a history-aware <a>.\n */\nconst Link = /*#__PURE__*/React.forwardRef(function LinkWithRef(_ref4, ref) {\n  let {\n      onClick,\n      relative,\n      reloadDocument,\n      replace,\n      state,\n      target,\n      to,\n      preventScrollReset\n    } = _ref4,\n    rest = _objectWithoutPropertiesLoose(_ref4, _excluded);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  // Rendered into <a href> for absolute URLs\n  let absoluteHref;\n  let isExternal = false;\n  if (typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to)) {\n    // Render the absolute href server- and client-side\n    absoluteHref = to;\n    // Only check for external origins client-side\n    if (isBrowser) {\n      try {\n        let currentUrl = new URL(window.location.href);\n        let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n        let path = stripBasename(targetUrl.pathname, basename);\n        if (targetUrl.origin === currentUrl.origin && path != null) {\n          // Strip the protocol/origin/basename for same-origin absolute URLs\n          to = path + targetUrl.search + targetUrl.hash;\n        } else {\n          isExternal = true;\n        }\n      } catch (e) {\n        // We can't do external URL detection without a valid URL\n        process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"<Link to=\\\"\" + to + \"\\\"> contains an invalid URL which will probably break \" + \"when clicked - please update to a valid URL path.\") : void 0;\n      }\n    }\n  }\n  // Rendered into <a href> for relative URLs\n  let href = useHref(to, {\n    relative\n  });\n  let internalOnClick = useLinkClickHandler(to, {\n    replace,\n    state,\n    target,\n    preventScrollReset,\n    relative\n  });\n  function handleClick(event) {\n    if (onClick) onClick(event);\n    if (!event.defaultPrevented) {\n      internalOnClick(event);\n    }\n  }\n  return (\n    /*#__PURE__*/\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\n    React.createElement(\"a\", _extends({}, rest, {\n      href: absoluteHref || href,\n      onClick: isExternal || reloadDocument ? onClick : handleClick,\n      ref: ref,\n      target: target\n    }))\n  );\n});\nif (process.env.NODE_ENV !== \"production\") {\n  Link.displayName = \"Link\";\n}\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */\nconst NavLink = /*#__PURE__*/React.forwardRef(function NavLinkWithRef(_ref5, ref) {\n  let {\n      \"aria-current\": ariaCurrentProp = \"page\",\n      caseSensitive = false,\n      className: classNameProp = \"\",\n      end = false,\n      style: styleProp,\n      to,\n      children\n    } = _ref5,\n    rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);\n  let path = useResolvedPath(to, {\n    relative: rest.relative\n  });\n  let location = useLocation();\n  let routerState = React.useContext(UNSAFE_DataRouterStateContext);\n  let {\n    navigator\n  } = React.useContext(UNSAFE_NavigationContext);\n  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n  let locationPathname = location.pathname;\n  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n  if (!caseSensitive) {\n    locationPathname = locationPathname.toLowerCase();\n    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n    toPathname = toPathname.toLowerCase();\n  }\n  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === \"/\";\n  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n  let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n  let className;\n  if (typeof classNameProp === \"function\") {\n    className = classNameProp({\n      isActive,\n      isPending\n    });\n  } else {\n    // If the className prop is not a function, we use a default `active`\n    // class for <NavLink />s that are active. In v5 `active` was the default\n    // value for `activeClassName`, but we are removing that API and can still\n    // use the old default behavior for a cleaner upgrade path and keep the\n    // simple styling rules working as they currently do.\n    className = [classNameProp, isActive ? \"active\" : null, isPending ? \"pending\" : null].filter(Boolean).join(\" \");\n  }\n  let style = typeof styleProp === \"function\" ? styleProp({\n    isActive,\n    isPending\n  }) : styleProp;\n  return /*#__PURE__*/React.createElement(Link, _extends({}, rest, {\n    \"aria-current\": ariaCurrent,\n    className: className,\n    ref: ref,\n    style: style,\n    to: to\n  }), typeof children === \"function\" ? children({\n    isActive,\n    isPending\n  }) : children);\n});\nif (process.env.NODE_ENV !== \"production\") {\n  NavLink.displayName = \"NavLink\";\n}\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\nconst Form = /*#__PURE__*/React.forwardRef((props, ref) => {\n  let submit = useSubmit();\n  return /*#__PURE__*/React.createElement(FormImpl, _extends({}, props, {\n    submit: submit,\n    ref: ref\n  }));\n});\nif (process.env.NODE_ENV !== \"production\") {\n  Form.displayName = \"Form\";\n}\nconst FormImpl = /*#__PURE__*/React.forwardRef((_ref6, forwardedRef) => {\n  let {\n      reloadDocument,\n      replace,\n      state,\n      method = defaultMethod,\n      action,\n      onSubmit,\n      submit,\n      relative,\n      preventScrollReset\n    } = _ref6,\n    props = _objectWithoutPropertiesLoose(_ref6, _excluded3);\n  let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  let formAction = useFormAction(action, {\n    relative\n  });\n  let submitHandler = event => {\n    onSubmit && onSubmit(event);\n    if (event.defaultPrevented) return;\n    event.preventDefault();\n    let submitter = event.nativeEvent.submitter;\n    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n    submit(submitter || event.currentTarget, {\n      method: submitMethod,\n      replace,\n      state,\n      relative,\n      preventScrollReset\n    });\n  };\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: forwardedRef,\n    method: formMethod,\n    action: formAction,\n    onSubmit: reloadDocument ? onSubmit : submitHandler\n  }, props));\n});\nif (process.env.NODE_ENV !== \"production\") {\n  FormImpl.displayName = \"FormImpl\";\n}\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */\nfunction ScrollRestoration(_ref7) {\n  let {\n    getKey,\n    storageKey\n  } = _ref7;\n  useScrollRestoration({\n    getKey,\n    storageKey\n  });\n  return null;\n}\nif (process.env.NODE_ENV !== \"production\") {\n  ScrollRestoration.displayName = \"ScrollRestoration\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;\n(function (DataRouterHook) {\n  DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n  DataRouterHook[\"UseSubmit\"] = \"useSubmit\";\n  DataRouterHook[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\n  DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function (DataRouterStateHook) {\n  DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n  DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = React.useContext(UNSAFE_DataRouterContext);\n  !ctx ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = React.useContext(UNSAFE_DataRouterStateContext);\n  !state ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return state;\n}\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */\nfunction useLinkClickHandler(to, _temp) {\n  let {\n    target,\n    replace: replaceProp,\n    state,\n    preventScrollReset,\n    relative\n  } = _temp === void 0 ? {} : _temp;\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to, {\n    relative\n  });\n  return React.useCallback(event => {\n    if (shouldProcessLinkClick(event, target)) {\n      event.preventDefault();\n      // If the URL hasn't changed, a regular <a> will do a replace instead of\n      // a push, so do the same here unless the replace prop is explicitly set\n      let replace = replaceProp !== undefined ? replaceProp : createPath(location) === createPath(path);\n      navigate(to, {\n        replace,\n        state,\n        preventScrollReset,\n        relative\n      });\n    }\n  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);\n}\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */\nfunction useSearchParams(defaultInit) {\n  process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") : void 0;\n  let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n  let hasSetSearchParamsRef = React.useRef(false);\n  let location = useLocation();\n  let searchParams = React.useMemo(() =>\n  // Only merge in the defaults if we haven't yet called setSearchParams.\n  // Once we call that we want those to take precedence, otherwise you can't\n  // remove a param with setSearchParams({}) if it has an initial value\n  getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);\n  let navigate = useNavigate();\n  let setSearchParams = React.useCallback((nextInit, navigateOptions) => {\n    const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n    hasSetSearchParamsRef.current = true;\n    navigate(\"?\" + newSearchParams, navigateOptions);\n  }, [navigate, searchParams]);\n  return [searchParams, setSearchParams];\n}\nfunction validateClientSideSubmission() {\n  if (typeof document === \"undefined\") {\n    throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n  }\n}\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */\nfunction useSubmit() {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseSubmit);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let currentRouteId = UNSAFE_useRouteId();\n  return React.useCallback(function (target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    validateClientSideSubmission();\n    let {\n      action,\n      method,\n      encType,\n      formData,\n      body\n    } = getFormSubmissionInfo(target, basename);\n    router.navigate(options.action || action, {\n      preventScrollReset: options.preventScrollReset,\n      formData,\n      body,\n      formMethod: options.method || method,\n      formEncType: options.encType || encType,\n      replace: options.replace,\n      state: options.state,\n      fromRouteId: currentRouteId\n    });\n  }, [router, basename, currentRouteId]);\n}\n/**\n * Returns the implementation for fetcher.submit\n */\nfunction useSubmitFetcher(fetcherKey, fetcherRouteId) {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseSubmitFetcher);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  return React.useCallback(function (target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    validateClientSideSubmission();\n    let {\n      action,\n      method,\n      encType,\n      formData,\n      body\n    } = getFormSubmissionInfo(target, basename);\n    !(fetcherRouteId != null) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"No routeId available for useFetcher()\") : UNSAFE_invariant(false) : void 0;\n    router.fetch(fetcherKey, fetcherRouteId, options.action || action, {\n      preventScrollReset: options.preventScrollReset,\n      formData,\n      body,\n      formMethod: options.method || method,\n      formEncType: options.encType || encType\n    });\n  }, [router, basename, fetcherKey, fetcherRouteId]);\n}\n// v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction useFormAction(action, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let routeContext = React.useContext(UNSAFE_RouteContext);\n  !routeContext ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFormAction must be used inside a RouteContext\") : UNSAFE_invariant(false) : void 0;\n  let [match] = routeContext.matches.slice(-1);\n  // Shallow clone path so we can modify it below, otherwise we modify the\n  // object referenced by useMemo inside useResolvedPath\n  let path = _extends({}, useResolvedPath(action ? action : \".\", {\n    relative\n  }));\n  // Previously we set the default action to \".\". The problem with this is that\n  // `useResolvedPath(\".\")` excludes search params and the hash of the resolved\n  // URL. This is the intended behavior of when \".\" is specifically provided as\n  // the form action, but inconsistent w/ browsers when the action is omitted.\n  // https://github.com/remix-run/remix/issues/927\n  let location = useLocation();\n  if (action == null) {\n    // Safe to write to these directly here since if action was undefined, we\n    // would have called useResolvedPath(\".\") which will never include a search\n    // or hash\n    path.search = location.search;\n    path.hash = location.hash;\n    // When grabbing search params from the URL, remove the automatically\n    // inserted ?index param so we match the useResolvedPath search behavior\n    // which would not include ?index\n    if (match.route.index) {\n      let params = new URLSearchParams(path.search);\n      params.delete(\"index\");\n      path.search = params.toString() ? \"?\" + params.toString() : \"\";\n    }\n  }\n  if ((!action || action === \".\") && match.route.index) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the form action.  If this is a root navigation, then just use\n  // the raw basename which allows the basename to have full control over the\n  // presence of a trailing slash on root actions\n  if (basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\nfunction createFetcherForm(fetcherKey, routeId) {\n  let FetcherForm = /*#__PURE__*/React.forwardRef((props, ref) => {\n    let submit = useSubmitFetcher(fetcherKey, routeId);\n    return /*#__PURE__*/React.createElement(FormImpl, _extends({}, props, {\n      ref: ref,\n      submit: submit\n    }));\n  });\n  if (process.env.NODE_ENV !== \"production\") {\n    FetcherForm.displayName = \"fetcher.Form\";\n  }\n  return FetcherForm;\n}\nlet fetcherId = 0;\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */\nfunction useFetcher() {\n  var _route$matches;\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseFetcher);\n  let route = React.useContext(UNSAFE_RouteContext);\n  !route ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFetcher must be used inside a RouteContext\") : UNSAFE_invariant(false) : void 0;\n  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n  !(routeId != null) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFetcher can only be used on routes that contain a unique \\\"id\\\"\") : UNSAFE_invariant(false) : void 0;\n  let [fetcherKey] = React.useState(() => String(++fetcherId));\n  let [Form] = React.useState(() => {\n    !routeId ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"No routeId available for fetcher.Form()\") : UNSAFE_invariant(false) : void 0;\n    return createFetcherForm(fetcherKey, routeId);\n  });\n  let [load] = React.useState(() => href => {\n    !router ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"No router available for fetcher.load()\") : UNSAFE_invariant(false) : void 0;\n    !routeId ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"No routeId available for fetcher.load()\") : UNSAFE_invariant(false) : void 0;\n    router.fetch(fetcherKey, routeId, href);\n  });\n  let submit = useSubmitFetcher(fetcherKey, routeId);\n  let fetcher = router.getFetcher(fetcherKey);\n  let fetcherWithComponents = React.useMemo(() => _extends({\n    Form,\n    submit,\n    load\n  }, fetcher), [fetcher, Form, submit, load]);\n  React.useEffect(() => {\n    // Is this busted when the React team gets real weird and calls effects\n    // twice on mount?  We really just need to garbage collect here when this\n    // fetcher is no longer around.\n    return () => {\n      if (!router) {\n        console.warn(\"No router available to clean up from useFetcher()\");\n        return;\n      }\n      router.deleteFetcher(fetcherKey);\n    };\n  }, [router, fetcherKey]);\n  return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */\nfunction useFetchers() {\n  let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n  return [...state.fetchers.values()];\n}\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nlet savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */\nfunction useScrollRestoration(_temp3) {\n  let {\n    getKey,\n    storageKey\n  } = _temp3 === void 0 ? {} : _temp3;\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n  let {\n    restoreScrollPosition,\n    preventScrollReset\n  } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let location = useLocation();\n  let matches = useMatches();\n  let navigation = useNavigation();\n  // Trigger manual scroll restoration while we're active\n  React.useEffect(() => {\n    window.history.scrollRestoration = \"manual\";\n    return () => {\n      window.history.scrollRestoration = \"auto\";\n    };\n  }, []);\n  // Save positions on pagehide\n  usePageHide(React.useCallback(() => {\n    if (navigation.state === \"idle\") {\n      let key = (getKey ? getKey(location, matches) : null) || location.key;\n      savedScrollPositions[key] = window.scrollY;\n    }\n    sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n    window.history.scrollRestoration = \"auto\";\n  }, [storageKey, getKey, navigation.state, location, matches]));\n  // Read in any saved scroll locations\n  if (typeof document !== \"undefined\") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      try {\n        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n        if (sessionPositions) {\n          savedScrollPositions = JSON.parse(sessionPositions);\n        }\n      } catch (e) {\n        // no-op, use default empty object\n      }\n    }, [storageKey]);\n    // Enable scroll restoration in the router\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      let getKeyWithoutBasename = getKey && basename !== \"/\" ? (location, matches) => getKey( // Strip the basename to match useLocation()\n      _extends({}, location, {\n        pathname: stripBasename(location.pathname, basename) || location.pathname\n      }), matches) : getKey;\n      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);\n      return () => disableScrollRestoration && disableScrollRestoration();\n    }, [router, basename, getKey]);\n    // Restore scrolling when state.restoreScrollPosition changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      // Explicit false means don't do anything (used for submissions)\n      if (restoreScrollPosition === false) {\n        return;\n      }\n      // been here before, scroll to it\n      if (typeof restoreScrollPosition === \"number\") {\n        window.scrollTo(0, restoreScrollPosition);\n        return;\n      }\n      // try to scroll to the hash\n      if (location.hash) {\n        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n        if (el) {\n          el.scrollIntoView();\n          return;\n        }\n      }\n      // Don't reset if this navigation opted out\n      if (preventScrollReset === true) {\n        return;\n      }\n      // otherwise go to the top on new locations\n      window.scrollTo(0, 0);\n    }, [location, restoreScrollPosition, preventScrollReset]);\n  }\n}\n/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction useBeforeUnload(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : undefined;\n    window.addEventListener(\"beforeunload\", callback, opts);\n    return () => {\n      window.removeEventListener(\"beforeunload\", callback, opts);\n    };\n  }, [callback, capture]);\n}\n/**\n * Setup a callback to be fired on the window's `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction usePageHide(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : undefined;\n    window.addEventListener(\"pagehide\", callback, opts);\n    return () => {\n      window.removeEventListener(\"pagehide\", callback, opts);\n    };\n  }, [callback, capture]);\n}\n/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */\nfunction usePrompt(_ref8) {\n  let {\n    when,\n    message\n  } = _ref8;\n  let blocker = unstable_useBlocker(when);\n  React.useEffect(() => {\n    if (blocker.state === \"blocked\" && !when) {\n      blocker.reset();\n    }\n  }, [blocker, when]);\n  React.useEffect(() => {\n    if (blocker.state === \"blocked\") {\n      let proceed = window.confirm(message);\n      if (proceed) {\n        setTimeout(blocker.proceed, 0);\n      } else {\n        blocker.reset();\n      }\n    }\n  }, [blocker, message]);\n}\n//#endregion\n\nexport { BrowserRouter, Form, HashRouter, Link, NavLink, ScrollRestoration, useScrollRestoration as UNSAFE_useScrollRestoration, createBrowserRouter, createHashRouter, createSearchParams, HistoryRouter as unstable_HistoryRouter, usePrompt as unstable_usePrompt, useBeforeUnload, useFetcher, useFetchers, useFormAction, useLinkClickHandler, useSearchParams, useSubmit };\n//# sourceMappingURL=index.js.map\n","import type {\n  FormEncType,\n  HTMLFormMethod,\n  RelativeRoutingType,\n} from \"@remix-run/router\";\nimport { stripBasename, UNSAFE_warning as warning } from \"@remix-run/router\";\n\nexport const defaultMethod: HTMLFormMethod = \"get\";\nconst defaultEncType: FormEncType = \"application/x-www-form-urlencoded\";\n\nexport function isHtmlElement(object: any): object is HTMLElement {\n  return object != null && typeof object.tagName === \"string\";\n}\n\nexport function isButtonElement(object: any): object is HTMLButtonElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\n\nexport function isFormElement(object: any): object is HTMLFormElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\n\nexport function isInputElement(object: any): object is HTMLInputElement {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\n\ntype LimitedMouseEvent = Pick<\n  MouseEvent,\n  \"button\" | \"metaKey\" | \"altKey\" | \"ctrlKey\" | \"shiftKey\"\n>;\n\nfunction isModifiedEvent(event: LimitedMouseEvent) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\n\nexport function shouldProcessLinkClick(\n  event: LimitedMouseEvent,\n  target?: string\n) {\n  return (\n    event.button === 0 && // Ignore everything but left clicks\n    (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n    !isModifiedEvent(event) // Ignore clicks with modifier keys\n  );\n}\n\nexport type ParamKeyValuePair = [string, string];\n\nexport type URLSearchParamsInit =\n  | string\n  | ParamKeyValuePair[]\n  | Record<string, string | string[]>\n  | URLSearchParams;\n\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */\nexport function createSearchParams(\n  init: URLSearchParamsInit = \"\"\n): URLSearchParams {\n  return new URLSearchParams(\n    typeof init === \"string\" ||\n    Array.isArray(init) ||\n    init instanceof URLSearchParams\n      ? init\n      : Object.keys(init).reduce((memo, key) => {\n          let value = init[key];\n          return memo.concat(\n            Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]\n          );\n        }, [] as ParamKeyValuePair[])\n  );\n}\n\nexport function getSearchParamsForLocation(\n  locationSearch: string,\n  defaultSearchParams: URLSearchParams | null\n) {\n  let searchParams = createSearchParams(locationSearch);\n\n  if (defaultSearchParams) {\n    for (let key of defaultSearchParams.keys()) {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach((value) => {\n          searchParams.append(key, value);\n        });\n      }\n    }\n  }\n\n  return searchParams;\n}\n\n// Thanks https://github.com/sindresorhus/type-fest!\ntype JsonObject = { [Key in string]: JsonValue } & {\n  [Key in string]?: JsonValue | undefined;\n};\ntype JsonArray = JsonValue[] | readonly JsonValue[];\ntype JsonPrimitive = string | number | boolean | null;\ntype JsonValue = JsonPrimitive | JsonObject | JsonArray;\n\nexport type SubmitTarget =\n  | HTMLFormElement\n  | HTMLButtonElement\n  | HTMLInputElement\n  | FormData\n  | URLSearchParams\n  | JsonValue\n  | null;\n\n// One-time check for submitter support\nlet _formDataSupportsSubmitter: boolean | null = null;\n\nfunction isFormDataSubmitterSupported() {\n  if (_formDataSupportsSubmitter === null) {\n    try {\n      new FormData(\n        document.createElement(\"form\"),\n        // @ts-expect-error if FormData supports the submitter parameter, this will throw\n        0\n      );\n      _formDataSupportsSubmitter = false;\n    } catch (e) {\n      _formDataSupportsSubmitter = true;\n    }\n  }\n  return _formDataSupportsSubmitter;\n}\n\nexport interface SubmitOptions {\n  /**\n   * The HTTP method used to submit the form. Overrides `<form method>`.\n   * Defaults to \"GET\".\n   */\n  method?: HTMLFormMethod;\n\n  /**\n   * The action URL path used to submit the form. Overrides `<form action>`.\n   * Defaults to the path of the current route.\n   */\n  action?: string;\n\n  /**\n   * The encoding used to submit the form. Overrides `<form encType>`.\n   * Defaults to \"application/x-www-form-urlencoded\".\n   */\n  encType?: FormEncType;\n\n  /**\n   * Set `true` to replace the current entry in the browser's history stack\n   * instead of creating a new one (i.e. stay on \"the same page\"). Defaults\n   * to `false`.\n   */\n  replace?: boolean;\n\n  /**\n   * State object to add to the history stack entry for this navigation\n   */\n  state?: any;\n\n  /**\n   * Determines whether the form action is relative to the route hierarchy or\n   * the pathname.  Use this if you want to opt out of navigating the route\n   * hierarchy and want to instead route based on /-delimited URL segments\n   */\n  relative?: RelativeRoutingType;\n\n  /**\n   * In browser-based environments, prevent resetting scroll after this\n   * navigation when using the <ScrollRestoration> component\n   */\n  preventScrollReset?: boolean;\n}\n\nconst supportedFormEncTypes: Set<FormEncType> = new Set([\n  \"application/x-www-form-urlencoded\",\n  \"multipart/form-data\",\n  \"text/plain\",\n]);\n\nfunction getFormEncType(encType: string | null) {\n  if (encType != null && !supportedFormEncTypes.has(encType as FormEncType)) {\n    warning(\n      false,\n      `\"${encType}\" is not a valid \\`encType\\` for \\`<Form>\\`/\\`<fetcher.Form>\\` ` +\n        `and will default to \"${defaultEncType}\"`\n    );\n\n    return null;\n  }\n  return encType;\n}\n\nexport function getFormSubmissionInfo(\n  target: SubmitTarget,\n  basename: string\n): {\n  action: string | null;\n  method: string;\n  encType: string;\n  formData: FormData | undefined;\n  body: any;\n} {\n  let method: string;\n  let action: string | null;\n  let encType: string;\n  let formData: FormData | undefined;\n  let body: any;\n\n  if (isFormElement(target)) {\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we'll\n    // re-prefix in the router\n    let attr = target.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n\n    formData = new FormData(target);\n  } else if (\n    isButtonElement(target) ||\n    (isInputElement(target) &&\n      (target.type === \"submit\" || target.type === \"image\"))\n  ) {\n    let form = target.form;\n\n    if (form == null) {\n      throw new Error(\n        `Cannot submit a <button> or <input type=\"submit\"> without a <form>`\n      );\n    }\n\n    // <button>/<input type=\"submit\"> may override attributes of <form>\n\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we'll\n    // re-prefix in the router\n    let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n\n    method =\n      target.getAttribute(\"formmethod\") ||\n      form.getAttribute(\"method\") ||\n      defaultMethod;\n    encType =\n      getFormEncType(target.getAttribute(\"formenctype\")) ||\n      getFormEncType(form.getAttribute(\"enctype\")) ||\n      defaultEncType;\n\n    // Build a FormData object populated from a form and submitter\n    formData = new FormData(form, target);\n\n    // If this browser doesn't support the `FormData(el, submitter)` format,\n    // then tack on the submitter value at the end.  This is a lightweight\n    // solution that is not 100% spec compliant.  For complete support in older\n    // browsers, consider using the `formdata-submitter-polyfill` package\n    if (!isFormDataSubmitterSupported()) {\n      let { name, type, value } = target;\n      if (type === \"image\") {\n        let prefix = name ? `${name}.` : \"\";\n        formData.append(`${prefix}x`, \"0\");\n        formData.append(`${prefix}y`, \"0\");\n      } else if (name) {\n        formData.append(name, value);\n      }\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error(\n      `Cannot submit element that is not <form>, <button>, or ` +\n        `<input type=\"submit|image\">`\n    );\n  } else {\n    method = defaultMethod;\n    action = null;\n    encType = defaultEncType;\n    body = target;\n  }\n\n  // Send body for <Form encType=\"text/plain\" so we encode it into text\n  if (formData && encType === \"text/plain\") {\n    body = formData;\n    formData = undefined;\n  }\n\n  return { action, method: method.toLowerCase(), encType, formData, body };\n}\n","/**\n * NOTE: If you refactor this to split up the modules into separate files,\n * you'll need to update the rollup config for react-router-dom-v5-compat.\n */\nimport * as React from \"react\";\nimport type {\n  FutureConfig,\n  Location,\n  NavigateOptions,\n  NavigationType,\n  RelativeRoutingType,\n  RouteObject,\n  To,\n} from \"react-router\";\nimport {\n  Router,\n  createPath,\n  useHref,\n  useLocation,\n  useMatches,\n  useNavigate,\n  useNavigation,\n  useResolvedPath,\n  unstable_useBlocker as useBlocker,\n  UNSAFE_DataRouterContext as DataRouterContext,\n  UNSAFE_DataRouterStateContext as DataRouterStateContext,\n  UNSAFE_NavigationContext as NavigationContext,\n  UNSAFE_RouteContext as RouteContext,\n  UNSAFE_mapRouteProperties as mapRouteProperties,\n  UNSAFE_useRouteId as useRouteId,\n} from \"react-router\";\nimport type {\n  BrowserHistory,\n  Fetcher,\n  FormEncType,\n  FormMethod,\n  FutureConfig as RouterFutureConfig,\n  GetScrollRestorationKeyFunction,\n  HashHistory,\n  History,\n  HTMLFormMethod,\n  HydrationState,\n  Router as RemixRouter,\n  V7_FormMethod,\n} from \"@remix-run/router\";\nimport {\n  createRouter,\n  createBrowserHistory,\n  createHashHistory,\n  joinPaths,\n  stripBasename,\n  ErrorResponse,\n  UNSAFE_invariant as invariant,\n  UNSAFE_warning as warning,\n} from \"@remix-run/router\";\n\nimport type {\n  SubmitOptions,\n  ParamKeyValuePair,\n  URLSearchParamsInit,\n  SubmitTarget,\n} from \"./dom\";\nimport {\n  createSearchParams,\n  defaultMethod,\n  getFormSubmissionInfo,\n  getSearchParamsForLocation,\n  shouldProcessLinkClick,\n} from \"./dom\";\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Re-exports\n////////////////////////////////////////////////////////////////////////////////\n\nexport type {\n  FormEncType,\n  FormMethod,\n  GetScrollRestorationKeyFunction,\n  ParamKeyValuePair,\n  SubmitOptions,\n  URLSearchParamsInit,\n  V7_FormMethod,\n};\nexport { createSearchParams };\n\n// Note: Keep in sync with react-router exports!\nexport type {\n  ActionFunction,\n  ActionFunctionArgs,\n  AwaitProps,\n  unstable_Blocker,\n  unstable_BlockerFunction,\n  DataRouteMatch,\n  DataRouteObject,\n  Fetcher,\n  Hash,\n  IndexRouteObject,\n  IndexRouteProps,\n  JsonFunction,\n  LazyRouteFunction,\n  LayoutRouteProps,\n  LoaderFunction,\n  LoaderFunctionArgs,\n  Location,\n  MemoryRouterProps,\n  NavigateFunction,\n  NavigateOptions,\n  NavigateProps,\n  Navigation,\n  Navigator,\n  NonIndexRouteObject,\n  OutletProps,\n  Params,\n  ParamParseKey,\n  Path,\n  PathMatch,\n  Pathname,\n  PathPattern,\n  PathRouteProps,\n  RedirectFunction,\n  RelativeRoutingType,\n  RouteMatch,\n  RouteObject,\n  RouteProps,\n  RouterProps,\n  RouterProviderProps,\n  RoutesProps,\n  Search,\n  ShouldRevalidateFunction,\n  To,\n} from \"react-router\";\nexport {\n  AbortedDeferredError,\n  Await,\n  MemoryRouter,\n  Navigate,\n  NavigationType,\n  Outlet,\n  Route,\n  Router,\n  RouterProvider,\n  Routes,\n  createMemoryRouter,\n  createPath,\n  createRoutesFromChildren,\n  createRoutesFromElements,\n  defer,\n  isRouteErrorResponse,\n  generatePath,\n  json,\n  matchPath,\n  matchRoutes,\n  parsePath,\n  redirect,\n  renderMatches,\n  resolvePath,\n  useActionData,\n  useAsyncError,\n  useAsyncValue,\n  unstable_useBlocker,\n  useHref,\n  useInRouterContext,\n  useLoaderData,\n  useLocation,\n  useMatch,\n  useMatches,\n  useNavigate,\n  useNavigation,\n  useNavigationType,\n  useOutlet,\n  useOutletContext,\n  useParams,\n  useResolvedPath,\n  useRevalidator,\n  useRouteError,\n  useRouteLoaderData,\n  useRoutes,\n} from \"react-router\";\n\n///////////////////////////////////////////////////////////////////////////////\n// DANGER! PLEASE READ ME!\n// We provide these exports as an escape hatch in the event that you need any\n// routing data that we don't provide an explicit API for. With that said, we\n// want to cover your use case if we can, so if you feel the need to use these\n// we want to hear from you. Let us know what you're building and we'll do our\n// best to make sure we can support you!\n//\n// We consider these exports an implementation detail and do not guarantee\n// against any breaking changes, regardless of the semver release. Use with\n// extreme caution and only if you understand the consequences. Godspeed.\n///////////////////////////////////////////////////////////////////////////////\n\n/** @internal */\nexport {\n  UNSAFE_DataRouterContext,\n  UNSAFE_DataRouterStateContext,\n  UNSAFE_NavigationContext,\n  UNSAFE_LocationContext,\n  UNSAFE_RouteContext,\n  UNSAFE_useRouteId,\n} from \"react-router\";\n//#endregion\n\ndeclare global {\n  var __staticRouterHydrationData: HydrationState | undefined;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Routers\n////////////////////////////////////////////////////////////////////////////////\n\ninterface DOMRouterOpts {\n  basename?: string;\n  future?: Partial<Omit<RouterFutureConfig, \"v7_prependBasename\">>;\n  hydrationData?: HydrationState;\n  window?: Window;\n}\n\nexport function createBrowserRouter(\n  routes: RouteObject[],\n  opts?: DOMRouterOpts\n): RemixRouter {\n  return createRouter({\n    basename: opts?.basename,\n    future: {\n      ...opts?.future,\n      v7_prependBasename: true,\n    },\n    history: createBrowserHistory({ window: opts?.window }),\n    hydrationData: opts?.hydrationData || parseHydrationData(),\n    routes,\n    mapRouteProperties,\n  }).initialize();\n}\n\nexport function createHashRouter(\n  routes: RouteObject[],\n  opts?: DOMRouterOpts\n): RemixRouter {\n  return createRouter({\n    basename: opts?.basename,\n    future: {\n      ...opts?.future,\n      v7_prependBasename: true,\n    },\n    history: createHashHistory({ window: opts?.window }),\n    hydrationData: opts?.hydrationData || parseHydrationData(),\n    routes,\n    mapRouteProperties,\n  }).initialize();\n}\n\nfunction parseHydrationData(): HydrationState | undefined {\n  let state = window?.__staticRouterHydrationData;\n  if (state && state.errors) {\n    state = {\n      ...state,\n      errors: deserializeErrors(state.errors),\n    };\n  }\n  return state;\n}\n\nfunction deserializeErrors(\n  errors: RemixRouter[\"state\"][\"errors\"]\n): RemixRouter[\"state\"][\"errors\"] {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized: RemixRouter[\"state\"][\"errors\"] = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // serializeErrors in react-router-dom/server.tsx :)\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new ErrorResponse(\n        val.status,\n        val.statusText,\n        val.data,\n        val.internal === true\n      );\n    } else if (val && val.__type === \"Error\") {\n      // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            // @ts-expect-error\n            let error = new ErrorConstructor(val.message);\n            // Wipe away the client-side stack trace.  Nothing to fill it in with\n            // because we don't serialize SSR stack traces for security reasons\n            error.stack = \"\";\n            serialized[key] = error;\n          } catch (e) {\n            // no-op - fall through and create a normal Error\n          }\n        }\n      }\n\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        // Wipe away the client-side stack trace.  Nothing to fill it in with\n        // because we don't serialize SSR stack traces for security reasons\n        error.stack = \"\";\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\n\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nconst START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = React[START_TRANSITION];\n\nexport interface BrowserRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  future?: FutureConfig;\n  window?: Window;\n}\n\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */\nexport function BrowserRouter({\n  basename,\n  children,\n  future,\n  window,\n}: BrowserRouterProps) {\n  let historyRef = React.useRef<BrowserHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({ window, v5Compat: true });\n  }\n\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n  let { v7_startTransition } = future || {};\n  let setState = React.useCallback(\n    (newState: { action: NavigationType; location: Location }) => {\n      v7_startTransition && startTransitionImpl\n        ? startTransitionImpl(() => setStateImpl(newState))\n        : setStateImpl(newState);\n    },\n    [setStateImpl, v7_startTransition]\n  );\n\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface HashRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  future?: FutureConfig;\n  window?: Window;\n}\n\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */\nexport function HashRouter({\n  basename,\n  children,\n  future,\n  window,\n}: HashRouterProps) {\n  let historyRef = React.useRef<HashHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({ window, v5Compat: true });\n  }\n\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n  let { v7_startTransition } = future || {};\n  let setState = React.useCallback(\n    (newState: { action: NavigationType; location: Location }) => {\n      v7_startTransition && startTransitionImpl\n        ? startTransitionImpl(() => setStateImpl(newState))\n        : setStateImpl(newState);\n    },\n    [setStateImpl, v7_startTransition]\n  );\n\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface HistoryRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  future?: FutureConfig;\n  history: History;\n}\n\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */\nfunction HistoryRouter({\n  basename,\n  children,\n  future,\n  history,\n}: HistoryRouterProps) {\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n  let { v7_startTransition } = future || {};\n  let setState = React.useCallback(\n    (newState: { action: NavigationType; location: Location }) => {\n      v7_startTransition && startTransitionImpl\n        ? startTransitionImpl(() => setStateImpl(newState))\n        : setStateImpl(newState);\n    },\n    [setStateImpl, v7_startTransition]\n  );\n\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nif (__DEV__) {\n  HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\n\nexport { HistoryRouter as unstable_HistoryRouter };\n\nexport interface LinkProps\n  extends Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, \"href\"> {\n  reloadDocument?: boolean;\n  replace?: boolean;\n  state?: any;\n  preventScrollReset?: boolean;\n  relative?: RelativeRoutingType;\n  to: To;\n}\n\nconst isBrowser =\n  typeof window !== \"undefined\" &&\n  typeof window.document !== \"undefined\" &&\n  typeof window.document.createElement !== \"undefined\";\n\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n\n/**\n * The public API for rendering a history-aware <a>.\n */\nexport const Link = React.forwardRef<HTMLAnchorElement, LinkProps>(\n  function LinkWithRef(\n    {\n      onClick,\n      relative,\n      reloadDocument,\n      replace,\n      state,\n      target,\n      to,\n      preventScrollReset,\n      ...rest\n    },\n    ref\n  ) {\n    let { basename } = React.useContext(NavigationContext);\n\n    // Rendered into <a href> for absolute URLs\n    let absoluteHref;\n    let isExternal = false;\n\n    if (typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to)) {\n      // Render the absolute href server- and client-side\n      absoluteHref = to;\n\n      // Only check for external origins client-side\n      if (isBrowser) {\n        try {\n          let currentUrl = new URL(window.location.href);\n          let targetUrl = to.startsWith(\"//\")\n            ? new URL(currentUrl.protocol + to)\n            : new URL(to);\n          let path = stripBasename(targetUrl.pathname, basename);\n\n          if (targetUrl.origin === currentUrl.origin && path != null) {\n            // Strip the protocol/origin/basename for same-origin absolute URLs\n            to = path + targetUrl.search + targetUrl.hash;\n          } else {\n            isExternal = true;\n          }\n        } catch (e) {\n          // We can't do external URL detection without a valid URL\n          warning(\n            false,\n            `<Link to=\"${to}\"> contains an invalid URL which will probably break ` +\n              `when clicked - please update to a valid URL path.`\n          );\n        }\n      }\n    }\n\n    // Rendered into <a href> for relative URLs\n    let href = useHref(to, { relative });\n\n    let internalOnClick = useLinkClickHandler(to, {\n      replace,\n      state,\n      target,\n      preventScrollReset,\n      relative,\n    });\n    function handleClick(\n      event: React.MouseEvent<HTMLAnchorElement, MouseEvent>\n    ) {\n      if (onClick) onClick(event);\n      if (!event.defaultPrevented) {\n        internalOnClick(event);\n      }\n    }\n\n    return (\n      // eslint-disable-next-line jsx-a11y/anchor-has-content\n      <a\n        {...rest}\n        href={absoluteHref || href}\n        onClick={isExternal || reloadDocument ? onClick : handleClick}\n        ref={ref}\n        target={target}\n      />\n    );\n  }\n);\n\nif (__DEV__) {\n  Link.displayName = \"Link\";\n}\n\nexport interface NavLinkProps\n  extends Omit<LinkProps, \"className\" | \"style\" | \"children\"> {\n  children?:\n    | React.ReactNode\n    | ((props: { isActive: boolean; isPending: boolean }) => React.ReactNode);\n  caseSensitive?: boolean;\n  className?:\n    | string\n    | ((props: {\n        isActive: boolean;\n        isPending: boolean;\n      }) => string | undefined);\n  end?: boolean;\n  style?:\n    | React.CSSProperties\n    | ((props: {\n        isActive: boolean;\n        isPending: boolean;\n      }) => React.CSSProperties | undefined);\n}\n\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */\nexport const NavLink = React.forwardRef<HTMLAnchorElement, NavLinkProps>(\n  function NavLinkWithRef(\n    {\n      \"aria-current\": ariaCurrentProp = \"page\",\n      caseSensitive = false,\n      className: classNameProp = \"\",\n      end = false,\n      style: styleProp,\n      to,\n      children,\n      ...rest\n    },\n    ref\n  ) {\n    let path = useResolvedPath(to, { relative: rest.relative });\n    let location = useLocation();\n    let routerState = React.useContext(DataRouterStateContext);\n    let { navigator } = React.useContext(NavigationContext);\n\n    let toPathname = navigator.encodeLocation\n      ? navigator.encodeLocation(path).pathname\n      : path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname =\n      routerState && routerState.navigation && routerState.navigation.location\n        ? routerState.navigation.location.pathname\n        : null;\n\n    if (!caseSensitive) {\n      locationPathname = locationPathname.toLowerCase();\n      nextLocationPathname = nextLocationPathname\n        ? nextLocationPathname.toLowerCase()\n        : null;\n      toPathname = toPathname.toLowerCase();\n    }\n\n    let isActive =\n      locationPathname === toPathname ||\n      (!end &&\n        locationPathname.startsWith(toPathname) &&\n        locationPathname.charAt(toPathname.length) === \"/\");\n\n    let isPending =\n      nextLocationPathname != null &&\n      (nextLocationPathname === toPathname ||\n        (!end &&\n          nextLocationPathname.startsWith(toPathname) &&\n          nextLocationPathname.charAt(toPathname.length) === \"/\"));\n\n    let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n\n    let className: string | undefined;\n    if (typeof classNameProp === \"function\") {\n      className = classNameProp({ isActive, isPending });\n    } else {\n      // If the className prop is not a function, we use a default `active`\n      // class for <NavLink />s that are active. In v5 `active` was the default\n      // value for `activeClassName`, but we are removing that API and can still\n      // use the old default behavior for a cleaner upgrade path and keep the\n      // simple styling rules working as they currently do.\n      className = [\n        classNameProp,\n        isActive ? \"active\" : null,\n        isPending ? \"pending\" : null,\n      ]\n        .filter(Boolean)\n        .join(\" \");\n    }\n\n    let style =\n      typeof styleProp === \"function\"\n        ? styleProp({ isActive, isPending })\n        : styleProp;\n\n    return (\n      <Link\n        {...rest}\n        aria-current={ariaCurrent}\n        className={className}\n        ref={ref}\n        style={style}\n        to={to}\n      >\n        {typeof children === \"function\"\n          ? children({ isActive, isPending })\n          : children}\n      </Link>\n    );\n  }\n);\n\nif (__DEV__) {\n  NavLink.displayName = \"NavLink\";\n}\n\nexport interface FetcherFormProps\n  extends React.FormHTMLAttributes<HTMLFormElement> {\n  /**\n   * The HTTP verb to use when the form is submit. Supports \"get\", \"post\",\n   * \"put\", \"delete\", \"patch\".\n   */\n  method?: HTMLFormMethod;\n\n  /**\n   * `<form encType>` - enhancing beyond the normal string type and limiting\n   * to the built-in browser supported values\n   */\n  encType?:\n    | \"application/x-www-form-urlencoded\"\n    | \"multipart/form-data\"\n    | \"text/plain\";\n\n  /**\n   * Normal `<form action>` but supports React Router's relative paths.\n   */\n  action?: string;\n\n  /**\n   * Determines whether the form action is relative to the route hierarchy or\n   * the pathname.  Use this if you want to opt out of navigating the route\n   * hierarchy and want to instead route based on /-delimited URL segments\n   */\n  relative?: RelativeRoutingType;\n\n  /**\n   * Prevent the scroll position from resetting to the top of the viewport on\n   * completion of the navigation when using the <ScrollRestoration> component\n   */\n  preventScrollReset?: boolean;\n\n  /**\n   * A function to call when the form is submitted. If you call\n   * `event.preventDefault()` then this form will not do anything.\n   */\n  onSubmit?: React.FormEventHandler<HTMLFormElement>;\n}\n\nexport interface FormProps extends FetcherFormProps {\n  /**\n   * Forces a full document navigation instead of a fetch.\n   */\n  reloadDocument?: boolean;\n\n  /**\n   * Replaces the current entry in the browser history stack when the form\n   * navigates. Use this if you don't want the user to be able to click \"back\"\n   * to the page with the form on it.\n   */\n  replace?: boolean;\n\n  /**\n   * State object to add to the history stack entry for this navigation\n   */\n  state?: any;\n}\n\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\nexport const Form = React.forwardRef<HTMLFormElement, FormProps>(\n  (props, ref) => {\n    let submit = useSubmit();\n    return <FormImpl {...props} submit={submit} ref={ref} />;\n  }\n);\n\nif (__DEV__) {\n  Form.displayName = \"Form\";\n}\n\ntype HTMLSubmitEvent = React.BaseSyntheticEvent<\n  SubmitEvent,\n  Event,\n  HTMLFormElement\n>;\n\ntype HTMLFormSubmitter = HTMLButtonElement | HTMLInputElement;\n\ninterface FormImplProps extends FormProps {\n  submit: SubmitFunction | FetcherSubmitFunction;\n}\n\nconst FormImpl = React.forwardRef<HTMLFormElement, FormImplProps>(\n  (\n    {\n      reloadDocument,\n      replace,\n      state,\n      method = defaultMethod,\n      action,\n      onSubmit,\n      submit,\n      relative,\n      preventScrollReset,\n      ...props\n    },\n    forwardedRef\n  ) => {\n    let formMethod: HTMLFormMethod =\n      method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let formAction = useFormAction(action, { relative });\n    let submitHandler: React.FormEventHandler<HTMLFormElement> = (event) => {\n      onSubmit && onSubmit(event);\n      if (event.defaultPrevented) return;\n      event.preventDefault();\n\n      let submitter = (event as unknown as HTMLSubmitEvent).nativeEvent\n        .submitter as HTMLFormSubmitter | null;\n\n      let submitMethod =\n        (submitter?.getAttribute(\"formmethod\") as HTMLFormMethod | undefined) ||\n        method;\n\n      submit(submitter || event.currentTarget, {\n        method: submitMethod,\n        replace,\n        state,\n        relative,\n        preventScrollReset,\n      });\n    };\n\n    return (\n      <form\n        ref={forwardedRef}\n        method={formMethod}\n        action={formAction}\n        onSubmit={reloadDocument ? onSubmit : submitHandler}\n        {...props}\n      />\n    );\n  }\n);\n\nif (__DEV__) {\n  FormImpl.displayName = \"FormImpl\";\n}\n\nexport interface ScrollRestorationProps {\n  getKey?: GetScrollRestorationKeyFunction;\n  storageKey?: string;\n}\n\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */\nexport function ScrollRestoration({\n  getKey,\n  storageKey,\n}: ScrollRestorationProps) {\n  useScrollRestoration({ getKey, storageKey });\n  return null;\n}\n\nif (__DEV__) {\n  ScrollRestoration.displayName = \"ScrollRestoration\";\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\n\nenum DataRouterHook {\n  UseScrollRestoration = \"useScrollRestoration\",\n  UseSubmit = \"useSubmit\",\n  UseSubmitFetcher = \"useSubmitFetcher\",\n  UseFetcher = \"useFetcher\",\n}\n\nenum DataRouterStateHook {\n  UseFetchers = \"useFetchers\",\n  UseScrollRestoration = \"useScrollRestoration\",\n}\n\nfunction getDataRouterConsoleError(\n  hookName: DataRouterHook | DataRouterStateHook\n) {\n  return `${hookName} must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.`;\n}\n\nfunction useDataRouterContext(hookName: DataRouterHook) {\n  let ctx = React.useContext(DataRouterContext);\n  invariant(ctx, getDataRouterConsoleError(hookName));\n  return ctx;\n}\n\nfunction useDataRouterState(hookName: DataRouterStateHook) {\n  let state = React.useContext(DataRouterStateContext);\n  invariant(state, getDataRouterConsoleError(hookName));\n  return state;\n}\n\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */\nexport function useLinkClickHandler<E extends Element = HTMLAnchorElement>(\n  to: To,\n  {\n    target,\n    replace: replaceProp,\n    state,\n    preventScrollReset,\n    relative,\n  }: {\n    target?: React.HTMLAttributeAnchorTarget;\n    replace?: boolean;\n    state?: any;\n    preventScrollReset?: boolean;\n    relative?: RelativeRoutingType;\n  } = {}\n): (event: React.MouseEvent<E, MouseEvent>) => void {\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to, { relative });\n\n  return React.useCallback(\n    (event: React.MouseEvent<E, MouseEvent>) => {\n      if (shouldProcessLinkClick(event, target)) {\n        event.preventDefault();\n\n        // If the URL hasn't changed, a regular <a> will do a replace instead of\n        // a push, so do the same here unless the replace prop is explicitly set\n        let replace =\n          replaceProp !== undefined\n            ? replaceProp\n            : createPath(location) === createPath(path);\n\n        navigate(to, { replace, state, preventScrollReset, relative });\n      }\n    },\n    [\n      location,\n      navigate,\n      path,\n      replaceProp,\n      state,\n      target,\n      to,\n      preventScrollReset,\n      relative,\n    ]\n  );\n}\n\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */\nexport function useSearchParams(\n  defaultInit?: URLSearchParamsInit\n): [URLSearchParams, SetURLSearchParams] {\n  warning(\n    typeof URLSearchParams !== \"undefined\",\n    `You cannot use the \\`useSearchParams\\` hook in a browser that does not ` +\n      `support the URLSearchParams API. If you need to support Internet ` +\n      `Explorer 11, we recommend you load a polyfill such as ` +\n      `https://github.com/ungap/url-search-params\\n\\n` +\n      `If you're unsure how to load polyfills, we recommend you check out ` +\n      `https://polyfill.io/v3/ which provides some recommendations about how ` +\n      `to load polyfills only for users that need them, instead of for every ` +\n      `user.`\n  );\n\n  let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n  let hasSetSearchParamsRef = React.useRef(false);\n\n  let location = useLocation();\n  let searchParams = React.useMemo(\n    () =>\n      // Only merge in the defaults if we haven't yet called setSearchParams.\n      // Once we call that we want those to take precedence, otherwise you can't\n      // remove a param with setSearchParams({}) if it has an initial value\n      getSearchParamsForLocation(\n        location.search,\n        hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current\n      ),\n    [location.search]\n  );\n\n  let navigate = useNavigate();\n  let setSearchParams = React.useCallback<SetURLSearchParams>(\n    (nextInit, navigateOptions) => {\n      const newSearchParams = createSearchParams(\n        typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit\n      );\n      hasSetSearchParamsRef.current = true;\n      navigate(\"?\" + newSearchParams, navigateOptions);\n    },\n    [navigate, searchParams]\n  );\n\n  return [searchParams, setSearchParams];\n}\n\nexport type SetURLSearchParams = (\n  nextInit?:\n    | URLSearchParamsInit\n    | ((prev: URLSearchParams) => URLSearchParamsInit),\n  navigateOpts?: NavigateOptions\n) => void;\n\n/**\n * Submits a HTML `<form>` to the server without reloading the page.\n */\nexport interface SubmitFunction {\n  (\n    /**\n     * Specifies the `<form>` to be submitted to the server, a specific\n     * `<button>` or `<input type=\"submit\">` to use to submit the form, or some\n     * arbitrary data to submit.\n     *\n     * Note: When using a `<button>` its `name` and `value` will also be\n     * included in the form data that is submitted.\n     */\n    target: SubmitTarget,\n\n    /**\n     * Options that override the `<form>`'s own attributes. Required when\n     * submitting arbitrary data without a backing `<form>`.\n     */\n    options?: SubmitOptions\n  ): void;\n}\n\n/**\n * Submits a fetcher `<form>` to the server without reloading the page.\n */\nexport interface FetcherSubmitFunction {\n  (\n    target: SubmitTarget,\n    // Fetchers cannot replace or set state because they are not navigation events\n    options?: Omit<SubmitOptions, \"replace\" | \"state\">\n  ): void;\n}\n\nfunction validateClientSideSubmission() {\n  if (typeof document === \"undefined\") {\n    throw new Error(\n      \"You are calling submit during the server render. \" +\n        \"Try calling submit within a `useEffect` or callback instead.\"\n    );\n  }\n}\n\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */\nexport function useSubmit(): SubmitFunction {\n  let { router } = useDataRouterContext(DataRouterHook.UseSubmit);\n  let { basename } = React.useContext(NavigationContext);\n  let currentRouteId = useRouteId();\n\n  return React.useCallback<SubmitFunction>(\n    (target, options = {}) => {\n      validateClientSideSubmission();\n\n      let { action, method, encType, formData, body } = getFormSubmissionInfo(\n        target,\n        basename\n      );\n\n      router.navigate(options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || (method as HTMLFormMethod),\n        formEncType: options.encType || (encType as FormEncType),\n        replace: options.replace,\n        state: options.state,\n        fromRouteId: currentRouteId,\n      });\n    },\n    [router, basename, currentRouteId]\n  );\n}\n\n/**\n * Returns the implementation for fetcher.submit\n */\nfunction useSubmitFetcher(\n  fetcherKey: string,\n  fetcherRouteId: string\n): FetcherSubmitFunction {\n  let { router } = useDataRouterContext(DataRouterHook.UseSubmitFetcher);\n  let { basename } = React.useContext(NavigationContext);\n\n  return React.useCallback<FetcherSubmitFunction>(\n    (target, options = {}) => {\n      validateClientSideSubmission();\n\n      let { action, method, encType, formData, body } = getFormSubmissionInfo(\n        target,\n        basename\n      );\n\n      invariant(\n        fetcherRouteId != null,\n        \"No routeId available for useFetcher()\"\n      );\n      router.fetch(fetcherKey, fetcherRouteId, options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || (method as HTMLFormMethod),\n        formEncType: options.encType || (encType as FormEncType),\n      });\n    },\n    [router, basename, fetcherKey, fetcherRouteId]\n  );\n}\n\n// v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nexport function useFormAction(\n  action?: string,\n  { relative }: { relative?: RelativeRoutingType } = {}\n): string {\n  let { basename } = React.useContext(NavigationContext);\n  let routeContext = React.useContext(RouteContext);\n  invariant(routeContext, \"useFormAction must be used inside a RouteContext\");\n\n  let [match] = routeContext.matches.slice(-1);\n  // Shallow clone path so we can modify it below, otherwise we modify the\n  // object referenced by useMemo inside useResolvedPath\n  let path = { ...useResolvedPath(action ? action : \".\", { relative }) };\n\n  // Previously we set the default action to \".\". The problem with this is that\n  // `useResolvedPath(\".\")` excludes search params and the hash of the resolved\n  // URL. This is the intended behavior of when \".\" is specifically provided as\n  // the form action, but inconsistent w/ browsers when the action is omitted.\n  // https://github.com/remix-run/remix/issues/927\n  let location = useLocation();\n  if (action == null) {\n    // Safe to write to these directly here since if action was undefined, we\n    // would have called useResolvedPath(\".\") which will never include a search\n    // or hash\n    path.search = location.search;\n    path.hash = location.hash;\n\n    // When grabbing search params from the URL, remove the automatically\n    // inserted ?index param so we match the useResolvedPath search behavior\n    // which would not include ?index\n    if (match.route.index) {\n      let params = new URLSearchParams(path.search);\n      params.delete(\"index\");\n      path.search = params.toString() ? `?${params.toString()}` : \"\";\n    }\n  }\n\n  if ((!action || action === \".\") && match.route.index) {\n    path.search = path.search\n      ? path.search.replace(/^\\?/, \"?index&\")\n      : \"?index\";\n  }\n\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the form action.  If this is a root navigation, then just use\n  // the raw basename which allows the basename to have full control over the\n  // presence of a trailing slash on root actions\n  if (basename !== \"/\") {\n    path.pathname =\n      path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n\n  return createPath(path);\n}\n\nfunction createFetcherForm(fetcherKey: string, routeId: string) {\n  let FetcherForm = React.forwardRef<HTMLFormElement, FetcherFormProps>(\n    (props, ref) => {\n      let submit = useSubmitFetcher(fetcherKey, routeId);\n      return <FormImpl {...props} ref={ref} submit={submit} />;\n    }\n  );\n  if (__DEV__) {\n    FetcherForm.displayName = \"fetcher.Form\";\n  }\n  return FetcherForm;\n}\n\nlet fetcherId = 0;\n\nexport type FetcherWithComponents<TData> = Fetcher<TData> & {\n  Form: ReturnType<typeof createFetcherForm>;\n  submit: FetcherSubmitFunction;\n  load: (href: string) => void;\n};\n\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */\nexport function useFetcher<TData = any>(): FetcherWithComponents<TData> {\n  let { router } = useDataRouterContext(DataRouterHook.UseFetcher);\n\n  let route = React.useContext(RouteContext);\n  invariant(route, `useFetcher must be used inside a RouteContext`);\n\n  let routeId = route.matches[route.matches.length - 1]?.route.id;\n  invariant(\n    routeId != null,\n    `useFetcher can only be used on routes that contain a unique \"id\"`\n  );\n\n  let [fetcherKey] = React.useState(() => String(++fetcherId));\n  let [Form] = React.useState(() => {\n    invariant(routeId, `No routeId available for fetcher.Form()`);\n    return createFetcherForm(fetcherKey, routeId);\n  });\n  let [load] = React.useState(() => (href: string) => {\n    invariant(router, \"No router available for fetcher.load()\");\n    invariant(routeId, \"No routeId available for fetcher.load()\");\n    router.fetch(fetcherKey, routeId, href);\n  });\n  let submit = useSubmitFetcher(fetcherKey, routeId);\n\n  let fetcher = router.getFetcher<TData>(fetcherKey);\n\n  let fetcherWithComponents = React.useMemo(\n    () => ({\n      Form,\n      submit,\n      load,\n      ...fetcher,\n    }),\n    [fetcher, Form, submit, load]\n  );\n\n  React.useEffect(() => {\n    // Is this busted when the React team gets real weird and calls effects\n    // twice on mount?  We really just need to garbage collect here when this\n    // fetcher is no longer around.\n    return () => {\n      if (!router) {\n        console.warn(`No router available to clean up from useFetcher()`);\n        return;\n      }\n      router.deleteFetcher(fetcherKey);\n    };\n  }, [router, fetcherKey]);\n\n  return fetcherWithComponents;\n}\n\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */\nexport function useFetchers(): Fetcher[] {\n  let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n  return [...state.fetchers.values()];\n}\n\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nlet savedScrollPositions: Record<string, number> = {};\n\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */\nfunction useScrollRestoration({\n  getKey,\n  storageKey,\n}: {\n  getKey?: GetScrollRestorationKeyFunction;\n  storageKey?: string;\n} = {}) {\n  let { router } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n  let { restoreScrollPosition, preventScrollReset } = useDataRouterState(\n    DataRouterStateHook.UseScrollRestoration\n  );\n  let { basename } = React.useContext(NavigationContext);\n  let location = useLocation();\n  let matches = useMatches();\n  let navigation = useNavigation();\n\n  // Trigger manual scroll restoration while we're active\n  React.useEffect(() => {\n    window.history.scrollRestoration = \"manual\";\n    return () => {\n      window.history.scrollRestoration = \"auto\";\n    };\n  }, []);\n\n  // Save positions on pagehide\n  usePageHide(\n    React.useCallback(() => {\n      if (navigation.state === \"idle\") {\n        let key = (getKey ? getKey(location, matches) : null) || location.key;\n        savedScrollPositions[key] = window.scrollY;\n      }\n      sessionStorage.setItem(\n        storageKey || SCROLL_RESTORATION_STORAGE_KEY,\n        JSON.stringify(savedScrollPositions)\n      );\n      window.history.scrollRestoration = \"auto\";\n    }, [storageKey, getKey, navigation.state, location, matches])\n  );\n\n  // Read in any saved scroll locations\n  if (typeof document !== \"undefined\") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      try {\n        let sessionPositions = sessionStorage.getItem(\n          storageKey || SCROLL_RESTORATION_STORAGE_KEY\n        );\n        if (sessionPositions) {\n          savedScrollPositions = JSON.parse(sessionPositions);\n        }\n      } catch (e) {\n        // no-op, use default empty object\n      }\n    }, [storageKey]);\n\n    // Enable scroll restoration in the router\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      let getKeyWithoutBasename: GetScrollRestorationKeyFunction | undefined =\n        getKey && basename !== \"/\"\n          ? (location, matches) =>\n              getKey(\n                // Strip the basename to match useLocation()\n                {\n                  ...location,\n                  pathname:\n                    stripBasename(location.pathname, basename) ||\n                    location.pathname,\n                },\n                matches\n              )\n          : getKey;\n      let disableScrollRestoration = router?.enableScrollRestoration(\n        savedScrollPositions,\n        () => window.scrollY,\n        getKeyWithoutBasename\n      );\n      return () => disableScrollRestoration && disableScrollRestoration();\n    }, [router, basename, getKey]);\n\n    // Restore scrolling when state.restoreScrollPosition changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      // Explicit false means don't do anything (used for submissions)\n      if (restoreScrollPosition === false) {\n        return;\n      }\n\n      // been here before, scroll to it\n      if (typeof restoreScrollPosition === \"number\") {\n        window.scrollTo(0, restoreScrollPosition);\n        return;\n      }\n\n      // try to scroll to the hash\n      if (location.hash) {\n        let el = document.getElementById(\n          decodeURIComponent(location.hash.slice(1))\n        );\n        if (el) {\n          el.scrollIntoView();\n          return;\n        }\n      }\n\n      // Don't reset if this navigation opted out\n      if (preventScrollReset === true) {\n        return;\n      }\n\n      // otherwise go to the top on new locations\n      window.scrollTo(0, 0);\n    }, [location, restoreScrollPosition, preventScrollReset]);\n  }\n}\n\nexport { useScrollRestoration as UNSAFE_useScrollRestoration };\n\n/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nexport function useBeforeUnload(\n  callback: (event: BeforeUnloadEvent) => any,\n  options?: { capture?: boolean }\n): void {\n  let { capture } = options || {};\n  React.useEffect(() => {\n    let opts = capture != null ? { capture } : undefined;\n    window.addEventListener(\"beforeunload\", callback, opts);\n    return () => {\n      window.removeEventListener(\"beforeunload\", callback, opts);\n    };\n  }, [callback, capture]);\n}\n\n/**\n * Setup a callback to be fired on the window's `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction usePageHide(\n  callback: (event: PageTransitionEvent) => any,\n  options?: { capture?: boolean }\n): void {\n  let { capture } = options || {};\n  React.useEffect(() => {\n    let opts = capture != null ? { capture } : undefined;\n    window.addEventListener(\"pagehide\", callback, opts);\n    return () => {\n      window.removeEventListener(\"pagehide\", callback, opts);\n    };\n  }, [callback, capture]);\n}\n\n/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */\nfunction usePrompt({ when, message }: { when: boolean; message: string }) {\n  let blocker = useBlocker(when);\n\n  React.useEffect(() => {\n    if (blocker.state === \"blocked\" && !when) {\n      blocker.reset();\n    }\n  }, [blocker, when]);\n\n  React.useEffect(() => {\n    if (blocker.state === \"blocked\") {\n      let proceed = window.confirm(message);\n      if (proceed) {\n        setTimeout(blocker.proceed, 0);\n      } else {\n        blocker.reset();\n      }\n    }\n  }, [blocker, message]);\n}\n\nexport { usePrompt as unstable_usePrompt };\n\n//#endregion\n","/**\n * React Router v6.14.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { UNSAFE_invariant, joinPaths, matchPath, UNSAFE_getPathContributingMatches, UNSAFE_warning, resolveTo, parsePath, matchRoutes, Action, stripBasename, IDLE_BLOCKER, isRouteErrorResponse, createMemoryHistory, AbortedDeferredError, createRouter } from '@remix-run/router';\nexport { AbortedDeferredError, Action as NavigationType, createPath, defer, generatePath, isRouteErrorResponse, json, matchPath, matchRoutes, parsePath, redirect, resolvePath } from '@remix-run/router';\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nconst DataRouterContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  DataRouterContext.displayName = \"DataRouter\";\n}\nconst DataRouterStateContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  DataRouterStateContext.displayName = \"DataRouterState\";\n}\nconst AwaitContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  AwaitContext.displayName = \"Await\";\n}\n\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level <Router> API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\n\nconst NavigationContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  NavigationContext.displayName = \"Navigation\";\n}\nconst LocationContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  LocationContext.displayName = \"Location\";\n}\nconst RouteContext = /*#__PURE__*/React.createContext({\n  outlet: null,\n  matches: [],\n  isDataRoute: false\n});\nif (process.env.NODE_ENV !== \"production\") {\n  RouteContext.displayName = \"Route\";\n}\nconst RouteErrorContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  RouteErrorContext.displayName = \"RouteError\";\n}\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/hooks/use-href\n */\nfunction useHref(to, _temp) {\n  let {\n    relative\n  } = _temp === void 0 ? {} : _temp;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useHref() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  let {\n    basename,\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    hash,\n    pathname,\n    search\n  } = useResolvedPath(to, {\n    relative\n  });\n  let joinedPathname = pathname;\n\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the href.  If this is a root navigation, then just use the raw\n  // basename which allows the basename to have full control over the presence\n  // of a trailing slash on root links\n  if (basename !== \"/\") {\n    joinedPathname = pathname === \"/\" ? basename : joinPaths([basename, pathname]);\n  }\n  return navigator.createHref({\n    pathname: joinedPathname,\n    search,\n    hash\n  });\n}\n\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/hooks/use-in-router-context\n */\nfunction useInRouterContext() {\n  return React.useContext(LocationContext) != null;\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/hooks/use-location\n */\nfunction useLocation() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useLocation() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  return React.useContext(LocationContext).location;\n}\n\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/hooks/use-navigation-type\n */\nfunction useNavigationType() {\n  return React.useContext(LocationContext).navigationType;\n}\n\n/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/hooks/use-match\n */\nfunction useMatch(pattern) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useMatch() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  let {\n    pathname\n  } = useLocation();\n  return React.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);\n}\n\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\n\nconst navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\";\n\n// Mute warnings for calls to useNavigate in SSR environments\nfunction useIsomorphicLayoutEffect(cb) {\n  let isStatic = React.useContext(NavigationContext).static;\n  if (!isStatic) {\n    // We should be able to get rid of this once react 18.3 is released\n    // See: https://github.com/facebook/react/pull/26395\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(cb);\n  }\n}\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/hooks/use-navigate\n */\nfunction useNavigate() {\n  let {\n    isDataRoute\n  } = React.useContext(RouteContext);\n  // Conditional usage is OK here because the usage of a data router is static\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useNavigate() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  let dataRouterContext = React.useContext(DataRouterContext);\n  let {\n    basename,\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(UNSAFE_getPathContributingMatches(matches).map(match => match.pathnameBase));\n  let activeRef = React.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React.useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(activeRef.current, navigateEffectWarning) : void 0;\n\n    // Short circuit here since if this happens on first render the navigate\n    // is useless because we haven't wired up our history listener yet\n    if (!activeRef.current) return;\n    if (typeof to === \"number\") {\n      navigator.go(to);\n      return;\n    }\n    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to handing off to history (but only if we're not in a data router,\n    // otherwise it'll prepend the basename inside of the router).\n    // If this is a root navigation, then we navigate to the raw basename\n    // which allows the basename to have full control over the presence of a\n    // trailing slash on root links\n    if (dataRouterContext == null && basename !== \"/\") {\n      path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n    }\n    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n  }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\n  return navigate;\n}\nconst OutletContext = /*#__PURE__*/React.createContext(null);\n\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/hooks/use-outlet-context\n */\nfunction useOutletContext() {\n  return React.useContext(OutletContext);\n}\n\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/hooks/use-outlet\n */\nfunction useOutlet(context) {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return /*#__PURE__*/React.createElement(OutletContext.Provider, {\n      value: context\n    }, outlet);\n  }\n  return outlet;\n}\n\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/hooks/use-params\n */\nfunction useParams() {\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? routeMatch.params : {};\n}\n\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/hooks/use-resolved-path\n */\nfunction useResolvedPath(to, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(UNSAFE_getPathContributingMatches(matches).map(match => match.pathnameBase));\n  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [to, routePathnamesJson, locationPathname, relative]);\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/hooks/use-routes\n */\nfunction useRoutes(routes, locationArg) {\n  return useRoutesImpl(routes, locationArg);\n}\n\n// Internal implementation with accept optional param for RouterProvider usage\nfunction useRoutesImpl(routes, locationArg, dataRouterState) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useRoutes() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  let {\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    matches: parentMatches\n  } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n  if (process.env.NODE_ENV !== \"production\") {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = parentRoute && parentRoute.path || \"\";\n    warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + \"\\\">.\"));\n  }\n  let locationFromContext = useLocation();\n  let location;\n  if (locationArg) {\n    var _parsedLocationArg$pa;\n    let parsedLocationArg = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + (\"matched by all parent routes. The current pathname base is \\\"\" + parentPathnameBase + \"\\\" \") + (\"but pathname \\\"\" + parsedLocationArg.pathname + \"\\\" was given in the `location` prop.\")) : UNSAFE_invariant(false) : void 0;\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n  let pathname = location.pathname || \"/\";\n  let remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n  let matches = matchRoutes(routes, {\n    pathname: remainingPathname\n  });\n  if (process.env.NODE_ENV !== \"production\") {\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(parentRoute || matches != null, \"No routes matched location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \") : void 0;\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined, \"Matched leaf route at location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \" + \"does not have an element or Component. This means it will render an <Outlet /> with a \" + \"null value by default resulting in an \\\"empty\\\" page.\") : void 0;\n  }\n  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {\n    params: Object.assign({}, parentParams, match.params),\n    pathname: joinPaths([parentPathnameBase,\n    // Re-encode pathnames that were decoded inside matchRoutes\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),\n    pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : joinPaths([parentPathnameBase,\n    // Re-encode pathnames that were decoded inside matchRoutes\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])\n  })), parentMatches, dataRouterState);\n\n  // When a user passes in a `locationArg`, the associated routes need to\n  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n  // to use the scoped location instead of the global location.\n  if (locationArg && renderedMatches) {\n    return /*#__PURE__*/React.createElement(LocationContext.Provider, {\n      value: {\n        location: _extends({\n          pathname: \"/\",\n          search: \"\",\n          hash: \"\",\n          state: null,\n          key: \"default\"\n        }, location),\n        navigationType: Action.Pop\n      }\n    }, renderedMatches);\n  }\n  return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n  let error = useRouteError();\n  let message = isRouteErrorResponse(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n  let stack = error instanceof Error ? error.stack : null;\n  let lightgrey = \"rgba(200,200,200, 0.5)\";\n  let preStyles = {\n    padding: \"0.5rem\",\n    backgroundColor: lightgrey\n  };\n  let codeStyles = {\n    padding: \"2px 4px\",\n    backgroundColor: lightgrey\n  };\n  let devInfo = null;\n  if (process.env.NODE_ENV !== \"production\") {\n    console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n    devInfo = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/React.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /*#__PURE__*/React.createElement(\"code\", {\n      style: codeStyles\n    }, \"ErrorBoundary\"), \" or\", \" \", /*#__PURE__*/React.createElement(\"code\", {\n      style: codeStyles\n    }, \"errorElement\"), \" prop on your route.\"));\n  }\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/React.createElement(\"h3\", {\n    style: {\n      fontStyle: \"italic\"\n    }\n  }, message), stack ? /*#__PURE__*/React.createElement(\"pre\", {\n    style: preStyles\n  }, stack) : null, devInfo);\n}\nconst defaultErrorElement = /*#__PURE__*/React.createElement(DefaultErrorComponent, null);\nclass RenderErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.location,\n      revalidation: props.revalidation,\n      error: props.error\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  }\n  static getDerivedStateFromProps(props, state) {\n    // When we get into an error state, the user will likely click \"back\" to the\n    // previous page that didn't have an error. Because this wraps the entire\n    // application, that will have no effect--the error page continues to display.\n    // This gives us a mechanism to recover from the error when the location changes.\n    //\n    // Whether we're in an error state or not, we update the location in state\n    // so that when we are in an error state, it gets reset when a new location\n    // comes in and the user recovers from the error.\n    if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n      return {\n        error: props.error,\n        location: props.location,\n        revalidation: props.revalidation\n      };\n    }\n\n    // If we're not changing locations, preserve the location but still surface\n    // any new errors that may come through. We retain the existing error, we do\n    // this because the error provided from the app state may be cleared without\n    // the location changing.\n    return {\n      error: props.error || state.error,\n      location: state.location,\n      revalidation: props.revalidation || state.revalidation\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\"React Router caught the following error during render\", error, errorInfo);\n  }\n  render() {\n    return this.state.error ? /*#__PURE__*/React.createElement(RouteContext.Provider, {\n      value: this.props.routeContext\n    }, /*#__PURE__*/React.createElement(RouteErrorContext.Provider, {\n      value: this.state.error,\n      children: this.props.component\n    })) : this.props.children;\n  }\n}\nfunction RenderedRoute(_ref) {\n  let {\n    routeContext,\n    match,\n    children\n  } = _ref;\n  let dataRouterContext = React.useContext(DataRouterContext);\n\n  // Track how deep we got in our render pass to emulate SSR componentDidCatch\n  // in a DataStaticRouter\n  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n  }\n  return /*#__PURE__*/React.createElement(RouteContext.Provider, {\n    value: routeContext\n  }, children);\n}\nfunction _renderMatches(matches, parentMatches, dataRouterState) {\n  var _dataRouterState2;\n  if (parentMatches === void 0) {\n    parentMatches = [];\n  }\n  if (dataRouterState === void 0) {\n    dataRouterState = null;\n  }\n  if (matches == null) {\n    var _dataRouterState;\n    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\n      // Don't bail if we have data router errors so we can render them in the\n      // boundary.  Use the pre-matched (or shimmed) matches\n      matches = dataRouterState.matches;\n    } else {\n      return null;\n    }\n  }\n  let renderedMatches = matches;\n\n  // If we have data errors, trim matches to the highest error boundary\n  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n  if (errors != null) {\n    let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]));\n    !(errorIndex >= 0) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\")) : UNSAFE_invariant(false) : void 0;\n    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n  }\n  return renderedMatches.reduceRight((outlet, match, index) => {\n    let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null;\n    // Only data routers handle errors\n    let errorElement = null;\n    if (dataRouterState) {\n      errorElement = match.route.errorElement || defaultErrorElement;\n    }\n    let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n    let getChildren = () => {\n      let children;\n      if (error) {\n        children = errorElement;\n      } else if (match.route.Component) {\n        // Note: This is a de-optimized path since React won't re-use the\n        // ReactElement since it's identity changes with each new\n        // React.createElement call.  We keep this so folks can use\n        // `<Route Component={...}>` in `<Routes>` but generally `Component`\n        // usage is only advised in `RouterProvider` when we can convert it to\n        // `element` ahead of time.\n        children = /*#__PURE__*/React.createElement(match.route.Component, null);\n      } else if (match.route.element) {\n        children = match.route.element;\n      } else {\n        children = outlet;\n      }\n      return /*#__PURE__*/React.createElement(RenderedRoute, {\n        match: match,\n        routeContext: {\n          outlet,\n          matches,\n          isDataRoute: dataRouterState != null\n        },\n        children: children\n      });\n    };\n    // Only wrap in an error boundary within data router usages when we have an\n    // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n    // an ancestor ErrorBoundary/errorElement\n    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/React.createElement(RenderErrorBoundary, {\n      location: dataRouterState.location,\n      revalidation: dataRouterState.revalidation,\n      component: errorElement,\n      error: error,\n      children: getChildren(),\n      routeContext: {\n        outlet: null,\n        matches,\n        isDataRoute: true\n      }\n    }) : getChildren();\n  }, null);\n}\nvar DataRouterHook;\n(function (DataRouterHook) {\n  DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterHook[\"UseNavigateStable\"] = \"useNavigate\";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function (DataRouterStateHook) {\n  DataRouterStateHook[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n  DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n  DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n  DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n  DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n  DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n  DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterStateHook[\"UseNavigateStable\"] = \"useNavigate\";\n  DataRouterStateHook[\"UseRouteId\"] = \"useRouteId\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = React.useContext(DataRouterContext);\n  !ctx ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = React.useContext(DataRouterStateContext);\n  !state ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return state;\n}\nfunction useRouteContext(hookName) {\n  let route = React.useContext(RouteContext);\n  !route ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return route;\n}\n\n// Internal version with hookName-aware debugging\nfunction useCurrentRouteId(hookName) {\n  let route = useRouteContext(hookName);\n  let thisRoute = route.matches[route.matches.length - 1];\n  !thisRoute.route.id ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, hookName + \" can only be used on routes that contain a unique \\\"id\\\"\") : UNSAFE_invariant(false) : void 0;\n  return thisRoute.route.id;\n}\n\n/**\n * Returns the ID for the nearest contextual route\n */\nfunction useRouteId() {\n  return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n}\n\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */\nfunction useNavigation() {\n  let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n  return state.navigation;\n}\n\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */\nfunction useRevalidator() {\n  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n  return {\n    revalidate: dataRouterContext.router.revalidate,\n    state: state.revalidation\n  };\n}\n\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */\nfunction useMatches() {\n  let {\n    matches,\n    loaderData\n  } = useDataRouterState(DataRouterStateHook.UseMatches);\n  return React.useMemo(() => matches.map(match => {\n    let {\n      pathname,\n      params\n    } = match;\n    // Note: This structure matches that created by createUseMatchesMatch\n    // in the @remix-run/router , so if you change this please also change\n    // that :)  Eventually we'll DRY this up\n    return {\n      id: match.route.id,\n      pathname,\n      params,\n      data: loaderData[match.route.id],\n      handle: match.route.handle\n    };\n  }), [matches, loaderData]);\n}\n\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */\nfunction useLoaderData() {\n  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  if (state.errors && state.errors[routeId] != null) {\n    console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n    return undefined;\n  }\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the loaderData for the given routeId\n */\nfunction useRouteLoaderData(routeId) {\n  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the action data for the nearest ancestor Route action\n */\nfunction useActionData() {\n  let state = useDataRouterState(DataRouterStateHook.UseActionData);\n  let route = React.useContext(RouteContext);\n  !route ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useActionData must be used inside a RouteContext\") : UNSAFE_invariant(false) : void 0;\n  return Object.values((state == null ? void 0 : state.actionData) || {})[0];\n}\n\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * ErrorBoundary/errorElement to display a proper error message.\n */\nfunction useRouteError() {\n  var _state$errors;\n  let error = React.useContext(RouteErrorContext);\n  let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n\n  // If this was a render error, we put it in a RouteError context inside\n  // of RenderErrorBoundary\n  if (error) {\n    return error;\n  }\n\n  // Otherwise look for errors from our data router state\n  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n}\n\n/**\n * Returns the happy-path data from the nearest ancestor <Await /> value\n */\nfunction useAsyncValue() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._data;\n}\n\n/**\n * Returns the error from the nearest ancestor <Await /> value\n */\nfunction useAsyncError() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._error;\n}\nlet blockerId = 0;\n\n/**\n * Allow the application to block navigations within the SPA and present the\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n * using half-filled form data.  This does not handle hard-reloads or\n * cross-origin navigations.\n */\nfunction useBlocker(shouldBlock) {\n  let {\n    router,\n    basename\n  } = useDataRouterContext(DataRouterHook.UseBlocker);\n  let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n  let [blockerKey, setBlockerKey] = React.useState(\"\");\n  let blockerFunction = React.useCallback(arg => {\n    if (typeof shouldBlock !== \"function\") {\n      return !!shouldBlock;\n    }\n    if (basename === \"/\") {\n      return shouldBlock(arg);\n    }\n\n    // If they provided us a function and we've got an active basename, strip\n    // it from the locations we expose to the user to match the behavior of\n    // useLocation\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = arg;\n    return shouldBlock({\n      currentLocation: _extends({}, currentLocation, {\n        pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\n      }),\n      nextLocation: _extends({}, nextLocation, {\n        pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\n      }),\n      historyAction\n    });\n  }, [basename, shouldBlock]);\n\n  // This effect is in charge of blocker key assignment and deletion (which is\n  // tightly coupled to the key)\n  React.useEffect(() => {\n    let key = String(++blockerId);\n    setBlockerKey(key);\n    return () => router.deleteBlocker(key);\n  }, [router]);\n\n  // This effect handles assigning the blockerFunction.  This is to handle\n  // unstable blocker function identities, and happens only after the prior\n  // effect so we don't get an orphaned blockerFunction in the router with a\n  // key of \"\".  Until then we just have the IDLE_BLOCKER.\n  React.useEffect(() => {\n    if (blockerKey !== \"\") {\n      router.getBlocker(blockerKey, blockerFunction);\n    }\n  }, [router, blockerKey, blockerFunction]);\n\n  // Prefer the blocker from `state` not `router.state` since DataRouterContext\n  // is memoized so this ensures we update on blocker state updates\n  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;\n}\n\n/**\n * Stable version of useNavigate that is used when we are in the context of\n * a RouterProvider.\n */\nfunction useNavigateStable() {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n  let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n  let activeRef = React.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React.useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(activeRef.current, navigateEffectWarning) : void 0;\n\n    // Short circuit here since if this happens on first render the navigate\n    // is useless because we haven't wired up our router subscriber yet\n    if (!activeRef.current) return;\n    if (typeof to === \"number\") {\n      router.navigate(to);\n    } else {\n      router.navigate(to, _extends({\n        fromRouteId: id\n      }, options));\n    }\n  }, [router, id]);\n  return navigate;\n}\nconst alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, message) : void 0;\n  }\n}\n\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nconst START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = React[START_TRANSITION];\n\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nfunction RouterProvider(_ref) {\n  let {\n    fallbackElement,\n    router,\n    future\n  } = _ref;\n  // Need to use a layout effect here so we are subscribed early enough to\n  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n  let [state, setStateImpl] = React.useState(router.state);\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n  let navigator = React.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: n => router.navigate(n),\n      push: (to, state, opts) => router.navigate(to, {\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      }),\n      replace: (to, state, opts) => router.navigate(to, {\n        replace: true,\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  let dataRouterContext = React.useMemo(() => ({\n    router,\n    navigator,\n    static: false,\n    basename\n  }), [router, navigator, basename]);\n\n  // The fragment and {null} here are important!  We need them to keep React 18's\n  // useId happy when we are server-rendering since we may have a <script> here\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\n  // useId relies on the component tree structure to generate deterministic id's\n  // so we need to ensure it remains the same on the client even though\n  // we don't need the <script> tag\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/React.createElement(DataRouterStateContext.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator: navigator\n  }, state.initialized ? /*#__PURE__*/React.createElement(DataRoutes, {\n    routes: router.routes,\n    state: state\n  }) : fallbackElement))), null);\n}\nfunction DataRoutes(_ref2) {\n  let {\n    routes,\n    state\n  } = _ref2;\n  return useRoutesImpl(routes, undefined, state);\n}\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/router-components/memory-router\n */\nfunction MemoryRouter(_ref3) {\n  let {\n    basename,\n    children,\n    initialEntries,\n    initialIndex,\n    future\n  } = _ref3;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries,\n      initialIndex,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/components/navigate\n */\nfunction Navigate(_ref4) {\n  let {\n    to,\n    replace,\n    state,\n    relative\n  } = _ref4;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of\n  // the router loaded. We can help them understand how to avoid that.\n  \"<Navigate> may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(!React.useContext(NavigationContext).static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : void 0;\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let navigate = useNavigate();\n\n  // Resolve the path outside of the effect so that when effects run twice in\n  // StrictMode they navigate to the same place\n  let path = resolveTo(to, UNSAFE_getPathContributingMatches(matches).map(match => match.pathnameBase), locationPathname, relative === \"path\");\n  let jsonPath = JSON.stringify(path);\n  React.useEffect(() => navigate(JSON.parse(jsonPath), {\n    replace,\n    state,\n    relative\n  }), [navigate, jsonPath, relative, replace, state]);\n  return null;\n}\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/components/outlet\n */\nfunction Outlet(props) {\n  return useOutlet(props.context);\n}\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/components/route\n */\nfunction Route(_props) {\n  process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : UNSAFE_invariant(false) ;\n}\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/router-components/router\n */\nfunction Router(_ref5) {\n  let {\n    basename: basenameProp = \"/\",\n    children = null,\n    location: locationProp,\n    navigationType = Action.Pop,\n    navigator,\n    static: staticProp = false\n  } = _ref5;\n  !!useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : UNSAFE_invariant(false) : void 0;\n\n  // Preserve trailing slashes on basename, so we can let the user control\n  // the enforcement of trailing slashes throughout the app\n  let basename = basenameProp.replace(/^\\/*/, \"/\");\n  let navigationContext = React.useMemo(() => ({\n    basename,\n    navigator,\n    static: staticProp\n  }), [basename, navigator, staticProp]);\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\"\n  } = locationProp;\n  let locationContext = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n    if (trailingPathname == null) {\n      return null;\n    }\n    return {\n      location: {\n        pathname: trailingPathname,\n        search,\n        hash,\n        state,\n        key\n      },\n      navigationType\n    };\n  }, [basename, pathname, search, hash, state, key, navigationType]);\n  process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(locationContext != null, \"<Router basename=\\\"\" + basename + \"\\\"> is not able to match the URL \" + (\"\\\"\" + pathname + search + hash + \"\\\" because it does not start with the \") + \"basename, so the <Router> won't render anything.\") : void 0;\n  if (locationContext == null) {\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(NavigationContext.Provider, {\n    value: navigationContext\n  }, /*#__PURE__*/React.createElement(LocationContext.Provider, {\n    children: children,\n    value: locationContext\n  }));\n}\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/components/routes\n */\nfunction Routes(_ref6) {\n  let {\n    children,\n    location\n  } = _ref6;\n  return useRoutes(createRoutesFromChildren(children), location);\n}\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */\nfunction Await(_ref7) {\n  let {\n    children,\n    errorElement,\n    resolve\n  } = _ref7;\n  return /*#__PURE__*/React.createElement(AwaitErrorBoundary, {\n    resolve: resolve,\n    errorElement: errorElement\n  }, /*#__PURE__*/React.createElement(ResolveAwait, null, children));\n}\nvar AwaitRenderStatus;\n(function (AwaitRenderStatus) {\n  AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n  AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n  AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n})(AwaitRenderStatus || (AwaitRenderStatus = {}));\nconst neverSettledPromise = new Promise(() => {});\nclass AwaitErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: null\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\"<Await> caught the following error during render\", error, errorInfo);\n  }\n  render() {\n    let {\n      children,\n      errorElement,\n      resolve\n    } = this.props;\n    let promise = null;\n    let status = AwaitRenderStatus.pending;\n    if (!(resolve instanceof Promise)) {\n      // Didn't get a promise - provide as a resolved promise\n      status = AwaitRenderStatus.success;\n      promise = Promise.resolve();\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_data\", {\n        get: () => resolve\n      });\n    } else if (this.state.error) {\n      // Caught a render error, provide it as a rejected promise\n      status = AwaitRenderStatus.error;\n      let renderError = this.state.error;\n      promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_error\", {\n        get: () => renderError\n      });\n    } else if (resolve._tracked) {\n      // Already tracked promise - check contents\n      promise = resolve;\n      status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n    } else {\n      // Raw (untracked) promise - track it\n      status = AwaitRenderStatus.pending;\n      Object.defineProperty(resolve, \"_tracked\", {\n        get: () => true\n      });\n      promise = resolve.then(data => Object.defineProperty(resolve, \"_data\", {\n        get: () => data\n      }), error => Object.defineProperty(resolve, \"_error\", {\n        get: () => error\n      }));\n    }\n    if (status === AwaitRenderStatus.error && promise._error instanceof AbortedDeferredError) {\n      // Freeze the UI by throwing a never resolved promise\n      throw neverSettledPromise;\n    }\n    if (status === AwaitRenderStatus.error && !errorElement) {\n      // No errorElement, throw to the nearest route-level error boundary\n      throw promise._error;\n    }\n    if (status === AwaitRenderStatus.error) {\n      // Render via our errorElement\n      return /*#__PURE__*/React.createElement(AwaitContext.Provider, {\n        value: promise,\n        children: errorElement\n      });\n    }\n    if (status === AwaitRenderStatus.success) {\n      // Render children with resolved value\n      return /*#__PURE__*/React.createElement(AwaitContext.Provider, {\n        value: promise,\n        children: children\n      });\n    }\n\n    // Throw to the suspense boundary\n    throw promise;\n  }\n}\n\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on <Await>\n */\nfunction ResolveAwait(_ref8) {\n  let {\n    children\n  } = _ref8;\n  let data = useAsyncValue();\n  let toRender = typeof children === \"function\" ? children(data) : children;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, toRender);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/utils/create-routes-from-children\n */\nfunction createRoutesFromChildren(children, parentPath) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  let routes = [];\n  React.Children.forEach(children, (element, index) => {\n    if (! /*#__PURE__*/React.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n    let treePath = [...parentPath, index];\n    if (element.type === React.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n      return;\n    }\n    !(element.type === Route) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : UNSAFE_invariant(false) : void 0;\n    !(!element.props.index || !element.props.children) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"An index route cannot have child routes.\") : UNSAFE_invariant(false) : void 0;\n    let route = {\n      id: element.props.id || treePath.join(\"-\"),\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      Component: element.props.Component,\n      index: element.props.index,\n      path: element.props.path,\n      loader: element.props.loader,\n      action: element.props.action,\n      errorElement: element.props.errorElement,\n      ErrorBoundary: element.props.ErrorBoundary,\n      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n      shouldRevalidate: element.props.shouldRevalidate,\n      handle: element.props.handle,\n      lazy: element.props.lazy\n    };\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children, treePath);\n    }\n    routes.push(route);\n  });\n  return routes;\n}\n\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nfunction renderMatches(matches) {\n  return _renderMatches(matches);\n}\n\nfunction mapRouteProperties(route) {\n  let updates = {\n    // Note: this check also occurs in createRoutesFromChildren so update\n    // there if you change this -- please and thank you!\n    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n  };\n  if (route.Component) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (route.element) {\n        process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"You should not include both `Component` and `element` on your route - \" + \"`Component` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      element: /*#__PURE__*/React.createElement(route.Component),\n      Component: undefined\n    });\n  }\n  if (route.ErrorBoundary) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (route.errorElement) {\n        process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - \" + \"`ErrorBoundary` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      errorElement: /*#__PURE__*/React.createElement(route.ErrorBoundary),\n      ErrorBoundary: undefined\n    });\n  }\n  return updates;\n}\nfunction createMemoryRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createMemoryHistory({\n      initialEntries: opts == null ? void 0 : opts.initialEntries,\n      initialIndex: opts == null ? void 0 : opts.initialIndex\n    }),\n    hydrationData: opts == null ? void 0 : opts.hydrationData,\n    routes,\n    mapRouteProperties\n  }).initialize();\n}\n\nexport { Await, MemoryRouter, Navigate, Outlet, Route, Router, RouterProvider, Routes, DataRouterContext as UNSAFE_DataRouterContext, DataRouterStateContext as UNSAFE_DataRouterStateContext, LocationContext as UNSAFE_LocationContext, NavigationContext as UNSAFE_NavigationContext, RouteContext as UNSAFE_RouteContext, mapRouteProperties as UNSAFE_mapRouteProperties, useRouteId as UNSAFE_useRouteId, useRoutesImpl as UNSAFE_useRoutesImpl, createMemoryRouter, createRoutesFromChildren, createRoutesFromChildren as createRoutesFromElements, renderMatches, useBlocker as unstable_useBlocker, useActionData, useAsyncError, useAsyncValue, useHref, useInRouterContext, useLoaderData, useLocation, useMatch, useMatches, useNavigate, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRevalidator, useRouteError, useRouteLoaderData, useRoutes };\n//# sourceMappingURL=index.js.map\n","import * as React from \"react\";\nimport type {\n  AgnosticRouteMatch,\n  AgnosticIndexRouteObject,\n  AgnosticNonIndexRouteObject,\n  History,\n  Location,\n  RelativeRoutingType,\n  Router,\n  StaticHandlerContext,\n  To,\n  TrackedPromise,\n  LazyRouteFunction,\n} from \"@remix-run/router\";\nimport type { Action as NavigationType } from \"@remix-run/router\";\n\n// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nexport interface IndexRouteObject {\n  caseSensitive?: AgnosticIndexRouteObject[\"caseSensitive\"];\n  path?: AgnosticIndexRouteObject[\"path\"];\n  id?: AgnosticIndexRouteObject[\"id\"];\n  loader?: AgnosticIndexRouteObject[\"loader\"];\n  action?: AgnosticIndexRouteObject[\"action\"];\n  hasErrorBoundary?: AgnosticIndexRouteObject[\"hasErrorBoundary\"];\n  shouldRevalidate?: AgnosticIndexRouteObject[\"shouldRevalidate\"];\n  handle?: AgnosticIndexRouteObject[\"handle\"];\n  index: true;\n  children?: undefined;\n  element?: React.ReactNode | null;\n  errorElement?: React.ReactNode | null;\n  Component?: React.ComponentType | null;\n  ErrorBoundary?: React.ComponentType | null;\n  lazy?: LazyRouteFunction<RouteObject>;\n}\n\nexport interface NonIndexRouteObject {\n  caseSensitive?: AgnosticNonIndexRouteObject[\"caseSensitive\"];\n  path?: AgnosticNonIndexRouteObject[\"path\"];\n  id?: AgnosticNonIndexRouteObject[\"id\"];\n  loader?: AgnosticNonIndexRouteObject[\"loader\"];\n  action?: AgnosticNonIndexRouteObject[\"action\"];\n  hasErrorBoundary?: AgnosticNonIndexRouteObject[\"hasErrorBoundary\"];\n  shouldRevalidate?: AgnosticNonIndexRouteObject[\"shouldRevalidate\"];\n  handle?: AgnosticNonIndexRouteObject[\"handle\"];\n  index?: false;\n  children?: RouteObject[];\n  element?: React.ReactNode | null;\n  errorElement?: React.ReactNode | null;\n  Component?: React.ComponentType | null;\n  ErrorBoundary?: React.ComponentType | null;\n  lazy?: LazyRouteFunction<RouteObject>;\n}\n\nexport type RouteObject = IndexRouteObject | NonIndexRouteObject;\n\nexport type DataRouteObject = RouteObject & {\n  children?: DataRouteObject[];\n  id: string;\n};\n\nexport interface RouteMatch<\n  ParamKey extends string = string,\n  RouteObjectType extends RouteObject = RouteObject\n> extends AgnosticRouteMatch<ParamKey, RouteObjectType> {}\n\nexport interface DataRouteMatch extends RouteMatch<string, DataRouteObject> {}\n\nexport interface DataRouterContextObject extends NavigationContextObject {\n  router: Router;\n  staticContext?: StaticHandlerContext;\n}\n\nexport const DataRouterContext =\n  React.createContext<DataRouterContextObject | null>(null);\nif (__DEV__) {\n  DataRouterContext.displayName = \"DataRouter\";\n}\n\nexport const DataRouterStateContext = React.createContext<\n  Router[\"state\"] | null\n>(null);\nif (__DEV__) {\n  DataRouterStateContext.displayName = \"DataRouterState\";\n}\n\nexport const AwaitContext = React.createContext<TrackedPromise | null>(null);\nif (__DEV__) {\n  AwaitContext.displayName = \"Await\";\n}\n\nexport interface NavigateOptions {\n  replace?: boolean;\n  state?: any;\n  preventScrollReset?: boolean;\n  relative?: RelativeRoutingType;\n}\n\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level <Router> API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\nexport interface Navigator {\n  createHref: History[\"createHref\"];\n  // Optional for backwards-compat with Router/HistoryRouter usage (edge case)\n  encodeLocation?: History[\"encodeLocation\"];\n  go: History[\"go\"];\n  push(to: To, state?: any, opts?: NavigateOptions): void;\n  replace(to: To, state?: any, opts?: NavigateOptions): void;\n}\n\ninterface NavigationContextObject {\n  basename: string;\n  navigator: Navigator;\n  static: boolean;\n}\n\nexport const NavigationContext = React.createContext<NavigationContextObject>(\n  null!\n);\n\nif (__DEV__) {\n  NavigationContext.displayName = \"Navigation\";\n}\n\ninterface LocationContextObject {\n  location: Location;\n  navigationType: NavigationType;\n}\n\nexport const LocationContext = React.createContext<LocationContextObject>(\n  null!\n);\n\nif (__DEV__) {\n  LocationContext.displayName = \"Location\";\n}\n\nexport interface RouteContextObject {\n  outlet: React.ReactElement | null;\n  matches: RouteMatch[];\n  isDataRoute: boolean;\n}\n\nexport const RouteContext = React.createContext<RouteContextObject>({\n  outlet: null,\n  matches: [],\n  isDataRoute: false,\n});\n\nif (__DEV__) {\n  RouteContext.displayName = \"Route\";\n}\n\nexport const RouteErrorContext = React.createContext<any>(null);\n\nif (__DEV__) {\n  RouteErrorContext.displayName = \"RouteError\";\n}\n","import * as React from \"react\";\nimport type {\n  Blocker,\n  BlockerFunction,\n  Location,\n  ParamParseKey,\n  Params,\n  Path,\n  PathMatch,\n  PathPattern,\n  RelativeRoutingType,\n  Router as RemixRouter,\n  RevalidationState,\n  To,\n} from \"@remix-run/router\";\nimport {\n  Action as NavigationType,\n  UNSAFE_invariant as invariant,\n  isRouteErrorResponse,\n  joinPaths,\n  matchPath,\n  matchRoutes,\n  parsePath,\n  resolveTo,\n  stripBasename,\n  IDLE_BLOCKER,\n  UNSAFE_getPathContributingMatches as getPathContributingMatches,\n  UNSAFE_warning as warning,\n} from \"@remix-run/router\";\n\nimport type {\n  NavigateOptions,\n  RouteContextObject,\n  RouteMatch,\n  RouteObject,\n  DataRouteMatch,\n} from \"./context\";\nimport {\n  DataRouterContext,\n  DataRouterStateContext,\n  LocationContext,\n  NavigationContext,\n  RouteContext,\n  RouteErrorContext,\n  AwaitContext,\n} from \"./context\";\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/hooks/use-href\n */\nexport function useHref(\n  to: To,\n  { relative }: { relative?: RelativeRoutingType } = {}\n): string {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useHref() may be used only in the context of a <Router> component.`\n  );\n\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { hash, pathname, search } = useResolvedPath(to, { relative });\n\n  let joinedPathname = pathname;\n\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the href.  If this is a root navigation, then just use the raw\n  // basename which allows the basename to have full control over the presence\n  // of a trailing slash on root links\n  if (basename !== \"/\") {\n    joinedPathname =\n      pathname === \"/\" ? basename : joinPaths([basename, pathname]);\n  }\n\n  return navigator.createHref({ pathname: joinedPathname, search, hash });\n}\n\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/hooks/use-in-router-context\n */\nexport function useInRouterContext(): boolean {\n  return React.useContext(LocationContext) != null;\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/hooks/use-location\n */\nexport function useLocation(): Location {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useLocation() may be used only in the context of a <Router> component.`\n  );\n\n  return React.useContext(LocationContext).location;\n}\n\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/hooks/use-navigation-type\n */\nexport function useNavigationType(): NavigationType {\n  return React.useContext(LocationContext).navigationType;\n}\n\n/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/hooks/use-match\n */\nexport function useMatch<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(pattern: PathPattern<Path> | Path): PathMatch<ParamKey> | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useMatch() may be used only in the context of a <Router> component.`\n  );\n\n  let { pathname } = useLocation();\n  return React.useMemo(\n    () => matchPath<ParamKey, Path>(pattern, pathname),\n    [pathname, pattern]\n  );\n}\n\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\nexport interface NavigateFunction {\n  (to: To, options?: NavigateOptions): void;\n  (delta: number): void;\n}\n\nconst navigateEffectWarning =\n  `You should call navigate() in a React.useEffect(), not when ` +\n  `your component is first rendered.`;\n\n// Mute warnings for calls to useNavigate in SSR environments\nfunction useIsomorphicLayoutEffect(\n  cb: Parameters<typeof React.useLayoutEffect>[0]\n) {\n  let isStatic = React.useContext(NavigationContext).static;\n  if (!isStatic) {\n    // We should be able to get rid of this once react 18.3 is released\n    // See: https://github.com/facebook/react/pull/26395\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(cb);\n  }\n}\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/hooks/use-navigate\n */\nexport function useNavigate(): NavigateFunction {\n  let { isDataRoute } = React.useContext(RouteContext);\n  // Conditional usage is OK here because the usage of a data router is static\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\n\nfunction useNavigateUnstable(): NavigateFunction {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useNavigate() may be used only in the context of a <Router> component.`\n  );\n\n  let dataRouterContext = React.useContext(DataRouterContext);\n  let { basename, navigator } = React.useContext(NavigationContext);\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    getPathContributingMatches(matches).map((match) => match.pathnameBase)\n  );\n\n  let activeRef = React.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n\n  let navigate: NavigateFunction = React.useCallback(\n    (to: To | number, options: NavigateOptions = {}) => {\n      warning(activeRef.current, navigateEffectWarning);\n\n      // Short circuit here since if this happens on first render the navigate\n      // is useless because we haven't wired up our history listener yet\n      if (!activeRef.current) return;\n\n      if (typeof to === \"number\") {\n        navigator.go(to);\n        return;\n      }\n\n      let path = resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname,\n        options.relative === \"path\"\n      );\n\n      // If we're operating within a basename, prepend it to the pathname prior\n      // to handing off to history (but only if we're not in a data router,\n      // otherwise it'll prepend the basename inside of the router).\n      // If this is a root navigation, then we navigate to the raw basename\n      // which allows the basename to have full control over the presence of a\n      // trailing slash on root links\n      if (dataRouterContext == null && basename !== \"/\") {\n        path.pathname =\n          path.pathname === \"/\"\n            ? basename\n            : joinPaths([basename, path.pathname]);\n      }\n\n      (!!options.replace ? navigator.replace : navigator.push)(\n        path,\n        options.state,\n        options\n      );\n    },\n    [\n      basename,\n      navigator,\n      routePathnamesJson,\n      locationPathname,\n      dataRouterContext,\n    ]\n  );\n\n  return navigate;\n}\n\nconst OutletContext = React.createContext<unknown>(null);\n\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/hooks/use-outlet-context\n */\nexport function useOutletContext<Context = unknown>(): Context {\n  return React.useContext(OutletContext) as Context;\n}\n\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/hooks/use-outlet\n */\nexport function useOutlet(context?: unknown): React.ReactElement | null {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return (\n      <OutletContext.Provider value={context}>{outlet}</OutletContext.Provider>\n    );\n  }\n  return outlet;\n}\n\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/hooks/use-params\n */\nexport function useParams<\n  ParamsOrKey extends string | Record<string, string | undefined> = string\n>(): Readonly<\n  [ParamsOrKey] extends [string] ? Params<ParamsOrKey> : Partial<ParamsOrKey>\n> {\n  let { matches } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? (routeMatch.params as any) : {};\n}\n\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/hooks/use-resolved-path\n */\nexport function useResolvedPath(\n  to: To,\n  { relative }: { relative?: RelativeRoutingType } = {}\n): Path {\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n\n  let routePathnamesJson = JSON.stringify(\n    getPathContributingMatches(matches).map((match) => match.pathnameBase)\n  );\n\n  return React.useMemo(\n    () =>\n      resolveTo(\n        to,\n        JSON.parse(routePathnamesJson),\n        locationPathname,\n        relative === \"path\"\n      ),\n    [to, routePathnamesJson, locationPathname, relative]\n  );\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/hooks/use-routes\n */\nexport function useRoutes(\n  routes: RouteObject[],\n  locationArg?: Partial<Location> | string\n): React.ReactElement | null {\n  return useRoutesImpl(routes, locationArg);\n}\n\n// Internal implementation with accept optional param for RouterProvider usage\nexport function useRoutesImpl(\n  routes: RouteObject[],\n  locationArg?: Partial<Location> | string,\n  dataRouterState?: RemixRouter[\"state\"]\n): React.ReactElement | null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of the\n    // router loaded. We can help them understand how to avoid that.\n    `useRoutes() may be used only in the context of a <Router> component.`\n  );\n\n  let { navigator } = React.useContext(NavigationContext);\n  let { matches: parentMatches } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n\n  if (__DEV__) {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = (parentRoute && parentRoute.path) || \"\";\n    warningOnce(\n      parentPathname,\n      !parentRoute || parentPath.endsWith(\"*\"),\n      `You rendered descendant <Routes> (or called \\`useRoutes()\\`) at ` +\n        `\"${parentPathname}\" (under <Route path=\"${parentPath}\">) but the ` +\n        `parent route path has no trailing \"*\". This means if you navigate ` +\n        `deeper, the parent won't match anymore and therefore the child ` +\n        `routes will never render.\\n\\n` +\n        `Please change the parent <Route path=\"${parentPath}\"> to <Route ` +\n        `path=\"${parentPath === \"/\" ? \"*\" : `${parentPath}/*`}\">.`\n    );\n  }\n\n  let locationFromContext = useLocation();\n\n  let location;\n  if (locationArg) {\n    let parsedLocationArg =\n      typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n    invariant(\n      parentPathnameBase === \"/\" ||\n        parsedLocationArg.pathname?.startsWith(parentPathnameBase),\n      `When overriding the location using \\`<Routes location>\\` or \\`useRoutes(routes, location)\\`, ` +\n        `the location pathname must begin with the portion of the URL pathname that was ` +\n        `matched by all parent routes. The current pathname base is \"${parentPathnameBase}\" ` +\n        `but pathname \"${parsedLocationArg.pathname}\" was given in the \\`location\\` prop.`\n    );\n\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n\n  let pathname = location.pathname || \"/\";\n  let remainingPathname =\n    parentPathnameBase === \"/\"\n      ? pathname\n      : pathname.slice(parentPathnameBase.length) || \"/\";\n\n  let matches = matchRoutes(routes, { pathname: remainingPathname });\n\n  if (__DEV__) {\n    warning(\n      parentRoute || matches != null,\n      `No routes matched location \"${location.pathname}${location.search}${location.hash}\" `\n    );\n\n    warning(\n      matches == null ||\n        matches[matches.length - 1].route.element !== undefined ||\n        matches[matches.length - 1].route.Component !== undefined,\n      `Matched leaf route at location \"${location.pathname}${location.search}${location.hash}\" ` +\n        `does not have an element or Component. This means it will render an <Outlet /> with a ` +\n        `null value by default resulting in an \"empty\" page.`\n    );\n  }\n\n  let renderedMatches = _renderMatches(\n    matches &&\n      matches.map((match) =>\n        Object.assign({}, match, {\n          params: Object.assign({}, parentParams, match.params),\n          pathname: joinPaths([\n            parentPathnameBase,\n            // Re-encode pathnames that were decoded inside matchRoutes\n            navigator.encodeLocation\n              ? navigator.encodeLocation(match.pathname).pathname\n              : match.pathname,\n          ]),\n          pathnameBase:\n            match.pathnameBase === \"/\"\n              ? parentPathnameBase\n              : joinPaths([\n                  parentPathnameBase,\n                  // Re-encode pathnames that were decoded inside matchRoutes\n                  navigator.encodeLocation\n                    ? navigator.encodeLocation(match.pathnameBase).pathname\n                    : match.pathnameBase,\n                ]),\n        })\n      ),\n    parentMatches,\n    dataRouterState\n  );\n\n  // When a user passes in a `locationArg`, the associated routes need to\n  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n  // to use the scoped location instead of the global location.\n  if (locationArg && renderedMatches) {\n    return (\n      <LocationContext.Provider\n        value={{\n          location: {\n            pathname: \"/\",\n            search: \"\",\n            hash: \"\",\n            state: null,\n            key: \"default\",\n            ...location,\n          },\n          navigationType: NavigationType.Pop,\n        }}\n      >\n        {renderedMatches}\n      </LocationContext.Provider>\n    );\n  }\n\n  return renderedMatches;\n}\n\nfunction DefaultErrorComponent() {\n  let error = useRouteError();\n  let message = isRouteErrorResponse(error)\n    ? `${error.status} ${error.statusText}`\n    : error instanceof Error\n    ? error.message\n    : JSON.stringify(error);\n  let stack = error instanceof Error ? error.stack : null;\n  let lightgrey = \"rgba(200,200,200, 0.5)\";\n  let preStyles = { padding: \"0.5rem\", backgroundColor: lightgrey };\n  let codeStyles = { padding: \"2px 4px\", backgroundColor: lightgrey };\n\n  let devInfo = null;\n  if (__DEV__) {\n    console.error(\n      \"Error handled by React Router default ErrorBoundary:\",\n      error\n    );\n\n    devInfo = (\n      <>\n        <p>💿 Hey developer 👋</p>\n        <p>\n          You can provide a way better UX than this when your app throws errors\n          by providing your own <code style={codeStyles}>ErrorBoundary</code> or{\" \"}\n          <code style={codeStyles}>errorElement</code> prop on your route.\n        </p>\n      </>\n    );\n  }\n\n  return (\n    <>\n      <h2>Unexpected Application Error!</h2>\n      <h3 style={{ fontStyle: \"italic\" }}>{message}</h3>\n      {stack ? <pre style={preStyles}>{stack}</pre> : null}\n      {devInfo}\n    </>\n  );\n}\n\nconst defaultErrorElement = <DefaultErrorComponent />;\n\ntype RenderErrorBoundaryProps = React.PropsWithChildren<{\n  location: Location;\n  revalidation: RevalidationState;\n  error: any;\n  component: React.ReactNode;\n  routeContext: RouteContextObject;\n}>;\n\ntype RenderErrorBoundaryState = {\n  location: Location;\n  revalidation: RevalidationState;\n  error: any;\n};\n\nexport class RenderErrorBoundary extends React.Component<\n  RenderErrorBoundaryProps,\n  RenderErrorBoundaryState\n> {\n  constructor(props: RenderErrorBoundaryProps) {\n    super(props);\n    this.state = {\n      location: props.location,\n      revalidation: props.revalidation,\n      error: props.error,\n    };\n  }\n\n  static getDerivedStateFromError(error: any) {\n    return { error: error };\n  }\n\n  static getDerivedStateFromProps(\n    props: RenderErrorBoundaryProps,\n    state: RenderErrorBoundaryState\n  ) {\n    // When we get into an error state, the user will likely click \"back\" to the\n    // previous page that didn't have an error. Because this wraps the entire\n    // application, that will have no effect--the error page continues to display.\n    // This gives us a mechanism to recover from the error when the location changes.\n    //\n    // Whether we're in an error state or not, we update the location in state\n    // so that when we are in an error state, it gets reset when a new location\n    // comes in and the user recovers from the error.\n    if (\n      state.location !== props.location ||\n      (state.revalidation !== \"idle\" && props.revalidation === \"idle\")\n    ) {\n      return {\n        error: props.error,\n        location: props.location,\n        revalidation: props.revalidation,\n      };\n    }\n\n    // If we're not changing locations, preserve the location but still surface\n    // any new errors that may come through. We retain the existing error, we do\n    // this because the error provided from the app state may be cleared without\n    // the location changing.\n    return {\n      error: props.error || state.error,\n      location: state.location,\n      revalidation: props.revalidation || state.revalidation,\n    };\n  }\n\n  componentDidCatch(error: any, errorInfo: any) {\n    console.error(\n      \"React Router caught the following error during render\",\n      error,\n      errorInfo\n    );\n  }\n\n  render() {\n    return this.state.error ? (\n      <RouteContext.Provider value={this.props.routeContext}>\n        <RouteErrorContext.Provider\n          value={this.state.error}\n          children={this.props.component}\n        />\n      </RouteContext.Provider>\n    ) : (\n      this.props.children\n    );\n  }\n}\n\ninterface RenderedRouteProps {\n  routeContext: RouteContextObject;\n  match: RouteMatch<string, RouteObject>;\n  children: React.ReactNode | null;\n}\n\nfunction RenderedRoute({ routeContext, match, children }: RenderedRouteProps) {\n  let dataRouterContext = React.useContext(DataRouterContext);\n\n  // Track how deep we got in our render pass to emulate SSR componentDidCatch\n  // in a DataStaticRouter\n  if (\n    dataRouterContext &&\n    dataRouterContext.static &&\n    dataRouterContext.staticContext &&\n    (match.route.errorElement || match.route.ErrorBoundary)\n  ) {\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n  }\n\n  return (\n    <RouteContext.Provider value={routeContext}>\n      {children}\n    </RouteContext.Provider>\n  );\n}\n\nexport function _renderMatches(\n  matches: RouteMatch[] | null,\n  parentMatches: RouteMatch[] = [],\n  dataRouterState: RemixRouter[\"state\"] | null = null\n): React.ReactElement | null {\n  if (matches == null) {\n    if (dataRouterState?.errors) {\n      // Don't bail if we have data router errors so we can render them in the\n      // boundary.  Use the pre-matched (or shimmed) matches\n      matches = dataRouterState.matches as DataRouteMatch[];\n    } else {\n      return null;\n    }\n  }\n\n  let renderedMatches = matches;\n\n  // If we have data errors, trim matches to the highest error boundary\n  let errors = dataRouterState?.errors;\n  if (errors != null) {\n    let errorIndex = renderedMatches.findIndex(\n      (m) => m.route.id && errors?.[m.route.id]\n    );\n    invariant(\n      errorIndex >= 0,\n      `Could not find a matching route for errors on route IDs: ${Object.keys(\n        errors\n      ).join(\",\")}`\n    );\n    renderedMatches = renderedMatches.slice(\n      0,\n      Math.min(renderedMatches.length, errorIndex + 1)\n    );\n  }\n\n  return renderedMatches.reduceRight((outlet, match, index) => {\n    let error = match.route.id ? errors?.[match.route.id] : null;\n    // Only data routers handle errors\n    let errorElement: React.ReactNode | null = null;\n    if (dataRouterState) {\n      errorElement = match.route.errorElement || defaultErrorElement;\n    }\n    let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n    let getChildren = () => {\n      let children: React.ReactNode;\n      if (error) {\n        children = errorElement;\n      } else if (match.route.Component) {\n        // Note: This is a de-optimized path since React won't re-use the\n        // ReactElement since it's identity changes with each new\n        // React.createElement call.  We keep this so folks can use\n        // `<Route Component={...}>` in `<Routes>` but generally `Component`\n        // usage is only advised in `RouterProvider` when we can convert it to\n        // `element` ahead of time.\n        children = <match.route.Component />;\n      } else if (match.route.element) {\n        children = match.route.element;\n      } else {\n        children = outlet;\n      }\n      return (\n        <RenderedRoute\n          match={match}\n          routeContext={{\n            outlet,\n            matches,\n            isDataRoute: dataRouterState != null,\n          }}\n          children={children}\n        />\n      );\n    };\n    // Only wrap in an error boundary within data router usages when we have an\n    // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n    // an ancestor ErrorBoundary/errorElement\n    return dataRouterState &&\n      (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? (\n      <RenderErrorBoundary\n        location={dataRouterState.location}\n        revalidation={dataRouterState.revalidation}\n        component={errorElement}\n        error={error}\n        children={getChildren()}\n        routeContext={{ outlet: null, matches, isDataRoute: true }}\n      />\n    ) : (\n      getChildren()\n    );\n  }, null as React.ReactElement | null);\n}\n\nenum DataRouterHook {\n  UseBlocker = \"useBlocker\",\n  UseRevalidator = \"useRevalidator\",\n  UseNavigateStable = \"useNavigate\",\n}\n\nenum DataRouterStateHook {\n  UseBlocker = \"useBlocker\",\n  UseLoaderData = \"useLoaderData\",\n  UseActionData = \"useActionData\",\n  UseRouteError = \"useRouteError\",\n  UseNavigation = \"useNavigation\",\n  UseRouteLoaderData = \"useRouteLoaderData\",\n  UseMatches = \"useMatches\",\n  UseRevalidator = \"useRevalidator\",\n  UseNavigateStable = \"useNavigate\",\n  UseRouteId = \"useRouteId\",\n}\n\nfunction getDataRouterConsoleError(\n  hookName: DataRouterHook | DataRouterStateHook\n) {\n  return `${hookName} must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.`;\n}\n\nfunction useDataRouterContext(hookName: DataRouterHook) {\n  let ctx = React.useContext(DataRouterContext);\n  invariant(ctx, getDataRouterConsoleError(hookName));\n  return ctx;\n}\n\nfunction useDataRouterState(hookName: DataRouterStateHook) {\n  let state = React.useContext(DataRouterStateContext);\n  invariant(state, getDataRouterConsoleError(hookName));\n  return state;\n}\n\nfunction useRouteContext(hookName: DataRouterStateHook) {\n  let route = React.useContext(RouteContext);\n  invariant(route, getDataRouterConsoleError(hookName));\n  return route;\n}\n\n// Internal version with hookName-aware debugging\nfunction useCurrentRouteId(hookName: DataRouterStateHook) {\n  let route = useRouteContext(hookName);\n  let thisRoute = route.matches[route.matches.length - 1];\n  invariant(\n    thisRoute.route.id,\n    `${hookName} can only be used on routes that contain a unique \"id\"`\n  );\n  return thisRoute.route.id;\n}\n\n/**\n * Returns the ID for the nearest contextual route\n */\nexport function useRouteId() {\n  return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n}\n\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */\nexport function useNavigation() {\n  let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n  return state.navigation;\n}\n\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */\nexport function useRevalidator() {\n  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n  return {\n    revalidate: dataRouterContext.router.revalidate,\n    state: state.revalidation,\n  };\n}\n\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */\nexport function useMatches() {\n  let { matches, loaderData } = useDataRouterState(\n    DataRouterStateHook.UseMatches\n  );\n  return React.useMemo(\n    () =>\n      matches.map((match) => {\n        let { pathname, params } = match;\n        // Note: This structure matches that created by createUseMatchesMatch\n        // in the @remix-run/router , so if you change this please also change\n        // that :)  Eventually we'll DRY this up\n        return {\n          id: match.route.id,\n          pathname,\n          params,\n          data: loaderData[match.route.id] as unknown,\n          handle: match.route.handle as unknown,\n        };\n      }),\n    [matches, loaderData]\n  );\n}\n\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */\nexport function useLoaderData(): unknown {\n  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n\n  if (state.errors && state.errors[routeId] != null) {\n    console.error(\n      `You cannot \\`useLoaderData\\` in an errorElement (routeId: ${routeId})`\n    );\n    return undefined;\n  }\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the loaderData for the given routeId\n */\nexport function useRouteLoaderData(routeId: string): unknown {\n  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the action data for the nearest ancestor Route action\n */\nexport function useActionData(): unknown {\n  let state = useDataRouterState(DataRouterStateHook.UseActionData);\n\n  let route = React.useContext(RouteContext);\n  invariant(route, `useActionData must be used inside a RouteContext`);\n\n  return Object.values(state?.actionData || {})[0];\n}\n\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * ErrorBoundary/errorElement to display a proper error message.\n */\nexport function useRouteError(): unknown {\n  let error = React.useContext(RouteErrorContext);\n  let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n\n  // If this was a render error, we put it in a RouteError context inside\n  // of RenderErrorBoundary\n  if (error) {\n    return error;\n  }\n\n  // Otherwise look for errors from our data router state\n  return state.errors?.[routeId];\n}\n\n/**\n * Returns the happy-path data from the nearest ancestor <Await /> value\n */\nexport function useAsyncValue(): unknown {\n  let value = React.useContext(AwaitContext);\n  return value?._data;\n}\n\n/**\n * Returns the error from the nearest ancestor <Await /> value\n */\nexport function useAsyncError(): unknown {\n  let value = React.useContext(AwaitContext);\n  return value?._error;\n}\n\nlet blockerId = 0;\n\n/**\n * Allow the application to block navigations within the SPA and present the\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n * using half-filled form data.  This does not handle hard-reloads or\n * cross-origin navigations.\n */\nexport function useBlocker(shouldBlock: boolean | BlockerFunction): Blocker {\n  let { router, basename } = useDataRouterContext(DataRouterHook.UseBlocker);\n  let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n\n  let [blockerKey, setBlockerKey] = React.useState(\"\");\n  let blockerFunction = React.useCallback<BlockerFunction>(\n    (arg) => {\n      if (typeof shouldBlock !== \"function\") {\n        return !!shouldBlock;\n      }\n      if (basename === \"/\") {\n        return shouldBlock(arg);\n      }\n\n      // If they provided us a function and we've got an active basename, strip\n      // it from the locations we expose to the user to match the behavior of\n      // useLocation\n      let { currentLocation, nextLocation, historyAction } = arg;\n      return shouldBlock({\n        currentLocation: {\n          ...currentLocation,\n          pathname:\n            stripBasename(currentLocation.pathname, basename) ||\n            currentLocation.pathname,\n        },\n        nextLocation: {\n          ...nextLocation,\n          pathname:\n            stripBasename(nextLocation.pathname, basename) ||\n            nextLocation.pathname,\n        },\n        historyAction,\n      });\n    },\n    [basename, shouldBlock]\n  );\n\n  // This effect is in charge of blocker key assignment and deletion (which is\n  // tightly coupled to the key)\n  React.useEffect(() => {\n    let key = String(++blockerId);\n    setBlockerKey(key);\n    return () => router.deleteBlocker(key);\n  }, [router]);\n\n  // This effect handles assigning the blockerFunction.  This is to handle\n  // unstable blocker function identities, and happens only after the prior\n  // effect so we don't get an orphaned blockerFunction in the router with a\n  // key of \"\".  Until then we just have the IDLE_BLOCKER.\n  React.useEffect(() => {\n    if (blockerKey !== \"\") {\n      router.getBlocker(blockerKey, blockerFunction);\n    }\n  }, [router, blockerKey, blockerFunction]);\n\n  // Prefer the blocker from `state` not `router.state` since DataRouterContext\n  // is memoized so this ensures we update on blocker state updates\n  return blockerKey && state.blockers.has(blockerKey)\n    ? state.blockers.get(blockerKey)!\n    : IDLE_BLOCKER;\n}\n\n/**\n * Stable version of useNavigate that is used when we are in the context of\n * a RouterProvider.\n */\nfunction useNavigateStable(): NavigateFunction {\n  let { router } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n  let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n\n  let activeRef = React.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n\n  let navigate: NavigateFunction = React.useCallback(\n    (to: To | number, options: NavigateOptions = {}) => {\n      warning(activeRef.current, navigateEffectWarning);\n\n      // Short circuit here since if this happens on first render the navigate\n      // is useless because we haven't wired up our router subscriber yet\n      if (!activeRef.current) return;\n\n      if (typeof to === \"number\") {\n        router.navigate(to);\n      } else {\n        router.navigate(to, { fromRouteId: id, ...options });\n      }\n    },\n    [router, id]\n  );\n\n  return navigate;\n}\n\nconst alreadyWarned: Record<string, boolean> = {};\n\nfunction warningOnce(key: string, cond: boolean, message: string) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    warning(false, message);\n  }\n}\n","import * as React from \"react\";\nimport type {\n  TrackedPromise,\n  InitialEntry,\n  Location,\n  MemoryHistory,\n  Router as RemixRouter,\n  To,\n  LazyRouteFunction,\n  RelativeRoutingType,\n  RouterState,\n} from \"@remix-run/router\";\nimport {\n  Action as NavigationType,\n  AbortedDeferredError,\n  createMemoryHistory,\n  UNSAFE_invariant as invariant,\n  parsePath,\n  resolveTo,\n  stripBasename,\n  UNSAFE_warning as warning,\n  UNSAFE_getPathContributingMatches as getPathContributingMatches,\n} from \"@remix-run/router\";\n\nimport type {\n  DataRouteObject,\n  IndexRouteObject,\n  RouteMatch,\n  RouteObject,\n  Navigator,\n  NonIndexRouteObject,\n} from \"./context\";\nimport {\n  LocationContext,\n  NavigationContext,\n  DataRouterContext,\n  DataRouterStateContext,\n  AwaitContext,\n  RouteContext,\n} from \"./context\";\nimport {\n  useAsyncValue,\n  useInRouterContext,\n  useNavigate,\n  useOutlet,\n  useRoutes,\n  _renderMatches,\n  useRoutesImpl,\n  useLocation,\n} from \"./hooks\";\n\nexport interface FutureConfig {\n  v7_startTransition: boolean;\n}\n\nexport interface RouterProviderProps {\n  fallbackElement?: React.ReactNode;\n  router: RemixRouter;\n  future?: FutureConfig;\n}\n\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nconst START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = React[START_TRANSITION];\n\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nexport function RouterProvider({\n  fallbackElement,\n  router,\n  future,\n}: RouterProviderProps): React.ReactElement {\n  // Need to use a layout effect here so we are subscribed early enough to\n  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n  let [state, setStateImpl] = React.useState(router.state);\n  let { v7_startTransition } = future || {};\n  let setState = React.useCallback(\n    (newState: RouterState) => {\n      v7_startTransition && startTransitionImpl\n        ? startTransitionImpl(() => setStateImpl(newState))\n        : setStateImpl(newState);\n    },\n    [setStateImpl, v7_startTransition]\n  );\n  React.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n\n  let navigator = React.useMemo((): Navigator => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: (n) => router.navigate(n),\n      push: (to, state, opts) =>\n        router.navigate(to, {\n          state,\n          preventScrollReset: opts?.preventScrollReset,\n        }),\n      replace: (to, state, opts) =>\n        router.navigate(to, {\n          replace: true,\n          state,\n          preventScrollReset: opts?.preventScrollReset,\n        }),\n    };\n  }, [router]);\n\n  let basename = router.basename || \"/\";\n\n  let dataRouterContext = React.useMemo(\n    () => ({\n      router,\n      navigator,\n      static: false,\n      basename,\n    }),\n    [router, navigator, basename]\n  );\n\n  // The fragment and {null} here are important!  We need them to keep React 18's\n  // useId happy when we are server-rendering since we may have a <script> here\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\n  // useId relies on the component tree structure to generate deterministic id's\n  // so we need to ensure it remains the same on the client even though\n  // we don't need the <script> tag\n  return (\n    <>\n      <DataRouterContext.Provider value={dataRouterContext}>\n        <DataRouterStateContext.Provider value={state}>\n          <Router\n            basename={basename}\n            location={state.location}\n            navigationType={state.historyAction}\n            navigator={navigator}\n          >\n            {state.initialized ? (\n              <DataRoutes routes={router.routes} state={state} />\n            ) : (\n              fallbackElement\n            )}\n          </Router>\n        </DataRouterStateContext.Provider>\n      </DataRouterContext.Provider>\n      {null}\n    </>\n  );\n}\n\nfunction DataRoutes({\n  routes,\n  state,\n}: {\n  routes: DataRouteObject[];\n  state: RouterState;\n}): React.ReactElement | null {\n  return useRoutesImpl(routes, undefined, state);\n}\n\nexport interface MemoryRouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n  future?: FutureConfig;\n}\n\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/router-components/memory-router\n */\nexport function MemoryRouter({\n  basename,\n  children,\n  initialEntries,\n  initialIndex,\n  future,\n}: MemoryRouterProps): React.ReactElement {\n  let historyRef = React.useRef<MemoryHistory>();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries,\n      initialIndex,\n      v5Compat: true,\n    });\n  }\n\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location,\n  });\n  let { v7_startTransition } = future || {};\n  let setState = React.useCallback(\n    (newState: { action: NavigationType; location: Location }) => {\n      v7_startTransition && startTransitionImpl\n        ? startTransitionImpl(() => setStateImpl(newState))\n        : setStateImpl(newState);\n    },\n    [setStateImpl, v7_startTransition]\n  );\n\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n\n  return (\n    <Router\n      basename={basename}\n      children={children}\n      location={state.location}\n      navigationType={state.action}\n      navigator={history}\n    />\n  );\n}\n\nexport interface NavigateProps {\n  to: To;\n  replace?: boolean;\n  state?: any;\n  relative?: RelativeRoutingType;\n}\n\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/components/navigate\n */\nexport function Navigate({\n  to,\n  replace,\n  state,\n  relative,\n}: NavigateProps): null {\n  invariant(\n    useInRouterContext(),\n    // TODO: This error is probably because they somehow have 2 versions of\n    // the router loaded. We can help them understand how to avoid that.\n    `<Navigate> may be used only in the context of a <Router> component.`\n  );\n\n  warning(\n    !React.useContext(NavigationContext).static,\n    `<Navigate> must not be used on the initial render in a <StaticRouter>. ` +\n      `This is a no-op, but you should modify your code so the <Navigate> is ` +\n      `only ever rendered in response to some user interaction or state change.`\n  );\n\n  let { matches } = React.useContext(RouteContext);\n  let { pathname: locationPathname } = useLocation();\n  let navigate = useNavigate();\n\n  // Resolve the path outside of the effect so that when effects run twice in\n  // StrictMode they navigate to the same place\n  let path = resolveTo(\n    to,\n    getPathContributingMatches(matches).map((match) => match.pathnameBase),\n    locationPathname,\n    relative === \"path\"\n  );\n  let jsonPath = JSON.stringify(path);\n\n  React.useEffect(\n    () => navigate(JSON.parse(jsonPath), { replace, state, relative }),\n    [navigate, jsonPath, relative, replace, state]\n  );\n\n  return null;\n}\n\nexport interface OutletProps {\n  context?: unknown;\n}\n\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/components/outlet\n */\nexport function Outlet(props: OutletProps): React.ReactElement | null {\n  return useOutlet(props.context);\n}\n\nexport interface PathRouteProps {\n  caseSensitive?: NonIndexRouteObject[\"caseSensitive\"];\n  path?: NonIndexRouteObject[\"path\"];\n  id?: NonIndexRouteObject[\"id\"];\n  lazy?: LazyRouteFunction<NonIndexRouteObject>;\n  loader?: NonIndexRouteObject[\"loader\"];\n  action?: NonIndexRouteObject[\"action\"];\n  hasErrorBoundary?: NonIndexRouteObject[\"hasErrorBoundary\"];\n  shouldRevalidate?: NonIndexRouteObject[\"shouldRevalidate\"];\n  handle?: NonIndexRouteObject[\"handle\"];\n  index?: false;\n  children?: React.ReactNode;\n  element?: React.ReactNode | null;\n  errorElement?: React.ReactNode | null;\n  Component?: React.ComponentType | null;\n  ErrorBoundary?: React.ComponentType | null;\n}\n\nexport interface LayoutRouteProps extends PathRouteProps {}\n\nexport interface IndexRouteProps {\n  caseSensitive?: IndexRouteObject[\"caseSensitive\"];\n  path?: IndexRouteObject[\"path\"];\n  id?: IndexRouteObject[\"id\"];\n  lazy?: LazyRouteFunction<IndexRouteObject>;\n  loader?: IndexRouteObject[\"loader\"];\n  action?: IndexRouteObject[\"action\"];\n  hasErrorBoundary?: IndexRouteObject[\"hasErrorBoundary\"];\n  shouldRevalidate?: IndexRouteObject[\"shouldRevalidate\"];\n  handle?: IndexRouteObject[\"handle\"];\n  index: true;\n  children?: undefined;\n  element?: React.ReactNode | null;\n  errorElement?: React.ReactNode | null;\n  Component?: React.ComponentType | null;\n  ErrorBoundary?: React.ComponentType | null;\n}\n\nexport type RouteProps = PathRouteProps | LayoutRouteProps | IndexRouteProps;\n\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/components/route\n */\nexport function Route(_props: RouteProps): React.ReactElement | null {\n  invariant(\n    false,\n    `A <Route> is only ever to be used as the child of <Routes> element, ` +\n      `never rendered directly. Please wrap your <Route> in a <Routes>.`\n  );\n}\n\nexport interface RouterProps {\n  basename?: string;\n  children?: React.ReactNode;\n  location: Partial<Location> | string;\n  navigationType?: NavigationType;\n  navigator: Navigator;\n  static?: boolean;\n}\n\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/router-components/router\n */\nexport function Router({\n  basename: basenameProp = \"/\",\n  children = null,\n  location: locationProp,\n  navigationType = NavigationType.Pop,\n  navigator,\n  static: staticProp = false,\n}: RouterProps): React.ReactElement | null {\n  invariant(\n    !useInRouterContext(),\n    `You cannot render a <Router> inside another <Router>.` +\n      ` You should never have more than one in your app.`\n  );\n\n  // Preserve trailing slashes on basename, so we can let the user control\n  // the enforcement of trailing slashes throughout the app\n  let basename = basenameProp.replace(/^\\/*/, \"/\");\n  let navigationContext = React.useMemo(\n    () => ({ basename, navigator, static: staticProp }),\n    [basename, navigator, staticProp]\n  );\n\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\",\n  } = locationProp;\n\n  let locationContext = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n\n    if (trailingPathname == null) {\n      return null;\n    }\n\n    return {\n      location: {\n        pathname: trailingPathname,\n        search,\n        hash,\n        state,\n        key,\n      },\n      navigationType,\n    };\n  }, [basename, pathname, search, hash, state, key, navigationType]);\n\n  warning(\n    locationContext != null,\n    `<Router basename=\"${basename}\"> is not able to match the URL ` +\n      `\"${pathname}${search}${hash}\" because it does not start with the ` +\n      `basename, so the <Router> won't render anything.`\n  );\n\n  if (locationContext == null) {\n    return null;\n  }\n\n  return (\n    <NavigationContext.Provider value={navigationContext}>\n      <LocationContext.Provider children={children} value={locationContext} />\n    </NavigationContext.Provider>\n  );\n}\n\nexport interface RoutesProps {\n  children?: React.ReactNode;\n  location?: Partial<Location> | string;\n}\n\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/components/routes\n */\nexport function Routes({\n  children,\n  location,\n}: RoutesProps): React.ReactElement | null {\n  return useRoutes(createRoutesFromChildren(children), location);\n}\n\nexport interface AwaitResolveRenderFunction {\n  (data: Awaited<any>): React.ReactNode;\n}\n\nexport interface AwaitProps {\n  children: React.ReactNode | AwaitResolveRenderFunction;\n  errorElement?: React.ReactNode;\n  resolve: TrackedPromise | any;\n}\n\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */\nexport function Await({ children, errorElement, resolve }: AwaitProps) {\n  return (\n    <AwaitErrorBoundary resolve={resolve} errorElement={errorElement}>\n      <ResolveAwait>{children}</ResolveAwait>\n    </AwaitErrorBoundary>\n  );\n}\n\ntype AwaitErrorBoundaryProps = React.PropsWithChildren<{\n  errorElement?: React.ReactNode;\n  resolve: TrackedPromise | any;\n}>;\n\ntype AwaitErrorBoundaryState = {\n  error: any;\n};\n\nenum AwaitRenderStatus {\n  pending,\n  success,\n  error,\n}\n\nconst neverSettledPromise = new Promise(() => {});\n\nclass AwaitErrorBoundary extends React.Component<\n  AwaitErrorBoundaryProps,\n  AwaitErrorBoundaryState\n> {\n  constructor(props: AwaitErrorBoundaryProps) {\n    super(props);\n    this.state = { error: null };\n  }\n\n  static getDerivedStateFromError(error: any) {\n    return { error };\n  }\n\n  componentDidCatch(error: any, errorInfo: any) {\n    console.error(\n      \"<Await> caught the following error during render\",\n      error,\n      errorInfo\n    );\n  }\n\n  render() {\n    let { children, errorElement, resolve } = this.props;\n\n    let promise: TrackedPromise | null = null;\n    let status: AwaitRenderStatus = AwaitRenderStatus.pending;\n\n    if (!(resolve instanceof Promise)) {\n      // Didn't get a promise - provide as a resolved promise\n      status = AwaitRenderStatus.success;\n      promise = Promise.resolve();\n      Object.defineProperty(promise, \"_tracked\", { get: () => true });\n      Object.defineProperty(promise, \"_data\", { get: () => resolve });\n    } else if (this.state.error) {\n      // Caught a render error, provide it as a rejected promise\n      status = AwaitRenderStatus.error;\n      let renderError = this.state.error;\n      promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings\n      Object.defineProperty(promise, \"_tracked\", { get: () => true });\n      Object.defineProperty(promise, \"_error\", { get: () => renderError });\n    } else if ((resolve as TrackedPromise)._tracked) {\n      // Already tracked promise - check contents\n      promise = resolve;\n      status =\n        promise._error !== undefined\n          ? AwaitRenderStatus.error\n          : promise._data !== undefined\n          ? AwaitRenderStatus.success\n          : AwaitRenderStatus.pending;\n    } else {\n      // Raw (untracked) promise - track it\n      status = AwaitRenderStatus.pending;\n      Object.defineProperty(resolve, \"_tracked\", { get: () => true });\n      promise = resolve.then(\n        (data: any) =>\n          Object.defineProperty(resolve, \"_data\", { get: () => data }),\n        (error: any) =>\n          Object.defineProperty(resolve, \"_error\", { get: () => error })\n      );\n    }\n\n    if (\n      status === AwaitRenderStatus.error &&\n      promise._error instanceof AbortedDeferredError\n    ) {\n      // Freeze the UI by throwing a never resolved promise\n      throw neverSettledPromise;\n    }\n\n    if (status === AwaitRenderStatus.error && !errorElement) {\n      // No errorElement, throw to the nearest route-level error boundary\n      throw promise._error;\n    }\n\n    if (status === AwaitRenderStatus.error) {\n      // Render via our errorElement\n      return <AwaitContext.Provider value={promise} children={errorElement} />;\n    }\n\n    if (status === AwaitRenderStatus.success) {\n      // Render children with resolved value\n      return <AwaitContext.Provider value={promise} children={children} />;\n    }\n\n    // Throw to the suspense boundary\n    throw promise;\n  }\n}\n\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on <Await>\n */\nfunction ResolveAwait({\n  children,\n}: {\n  children: React.ReactNode | AwaitResolveRenderFunction;\n}) {\n  let data = useAsyncValue();\n  let toRender = typeof children === \"function\" ? children(data) : children;\n  return <>{toRender}</>;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/utils/create-routes-from-children\n */\nexport function createRoutesFromChildren(\n  children: React.ReactNode,\n  parentPath: number[] = []\n): RouteObject[] {\n  let routes: RouteObject[] = [];\n\n  React.Children.forEach(children, (element, index) => {\n    if (!React.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n\n    let treePath = [...parentPath, index];\n\n    if (element.type === React.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(\n        routes,\n        createRoutesFromChildren(element.props.children, treePath)\n      );\n      return;\n    }\n\n    invariant(\n      element.type === Route,\n      `[${\n        typeof element.type === \"string\" ? element.type : element.type.name\n      }] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`\n    );\n\n    invariant(\n      !element.props.index || !element.props.children,\n      \"An index route cannot have child routes.\"\n    );\n\n    let route: RouteObject = {\n      id: element.props.id || treePath.join(\"-\"),\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      Component: element.props.Component,\n      index: element.props.index,\n      path: element.props.path,\n      loader: element.props.loader,\n      action: element.props.action,\n      errorElement: element.props.errorElement,\n      ErrorBoundary: element.props.ErrorBoundary,\n      hasErrorBoundary:\n        element.props.ErrorBoundary != null ||\n        element.props.errorElement != null,\n      shouldRevalidate: element.props.shouldRevalidate,\n      handle: element.props.handle,\n      lazy: element.props.lazy,\n    };\n\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(\n        element.props.children,\n        treePath\n      );\n    }\n\n    routes.push(route);\n  });\n\n  return routes;\n}\n\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nexport function renderMatches(\n  matches: RouteMatch[] | null\n): React.ReactElement | null {\n  return _renderMatches(matches);\n}\n","import * as React from \"react\";\nimport type {\n  ActionFunction,\n  ActionFunctionArgs,\n  Blocker,\n  BlockerFunction,\n  Fetcher,\n  HydrationState,\n  JsonFunction,\n  LoaderFunction,\n  LoaderFunctionArgs,\n  Location,\n  Navigation,\n  Params,\n  ParamParseKey,\n  Path,\n  PathMatch,\n  PathPattern,\n  RedirectFunction,\n  RelativeRoutingType,\n  Router as RemixRouter,\n  ShouldRevalidateFunction,\n  To,\n  InitialEntry,\n  LazyRouteFunction,\n  FutureConfig as RouterFutureConfig,\n} from \"@remix-run/router\";\nimport {\n  AbortedDeferredError,\n  Action as NavigationType,\n  createMemoryHistory,\n  createPath,\n  createRouter,\n  defer,\n  generatePath,\n  isRouteErrorResponse,\n  json,\n  matchPath,\n  matchRoutes,\n  parsePath,\n  redirect,\n  resolvePath,\n  UNSAFE_warning as warning,\n} from \"@remix-run/router\";\n\nimport type {\n  AwaitProps,\n  MemoryRouterProps,\n  NavigateProps,\n  OutletProps,\n  RouteProps,\n  PathRouteProps,\n  LayoutRouteProps,\n  IndexRouteProps,\n  RouterProps,\n  RoutesProps,\n  RouterProviderProps,\n  FutureConfig,\n} from \"./lib/components\";\nimport {\n  createRoutesFromChildren,\n  renderMatches,\n  Await,\n  MemoryRouter,\n  Navigate,\n  Outlet,\n  Route,\n  Router,\n  RouterProvider,\n  Routes,\n} from \"./lib/components\";\nimport type {\n  DataRouteMatch,\n  DataRouteObject,\n  IndexRouteObject,\n  Navigator,\n  NavigateOptions,\n  NonIndexRouteObject,\n  RouteMatch,\n  RouteObject,\n} from \"./lib/context\";\nimport {\n  DataRouterContext,\n  DataRouterStateContext,\n  LocationContext,\n  NavigationContext,\n  RouteContext,\n} from \"./lib/context\";\nimport type { NavigateFunction } from \"./lib/hooks\";\nimport {\n  useBlocker,\n  useHref,\n  useInRouterContext,\n  useLocation,\n  useMatch,\n  useNavigationType,\n  useNavigate,\n  useOutlet,\n  useOutletContext,\n  useParams,\n  useResolvedPath,\n  useRoutes,\n  useActionData,\n  useAsyncError,\n  useAsyncValue,\n  useRouteId,\n  useLoaderData,\n  useMatches,\n  useNavigation,\n  useRevalidator,\n  useRouteError,\n  useRouteLoaderData,\n  useRoutesImpl,\n} from \"./lib/hooks\";\n\n// Exported for backwards compatibility, but not being used internally anymore\ntype Hash = string;\ntype Pathname = string;\ntype Search = string;\n\n// Expose react-router public API\nexport type {\n  ActionFunction,\n  ActionFunctionArgs,\n  AwaitProps,\n  Blocker as unstable_Blocker,\n  BlockerFunction as unstable_BlockerFunction,\n  DataRouteMatch,\n  DataRouteObject,\n  Fetcher,\n  FutureConfig,\n  Hash,\n  IndexRouteObject,\n  IndexRouteProps,\n  JsonFunction,\n  LazyRouteFunction,\n  LayoutRouteProps,\n  LoaderFunction,\n  LoaderFunctionArgs,\n  Location,\n  MemoryRouterProps,\n  NavigateFunction,\n  NavigateOptions,\n  NavigateProps,\n  Navigation,\n  Navigator,\n  NonIndexRouteObject,\n  OutletProps,\n  Params,\n  ParamParseKey,\n  Path,\n  PathMatch,\n  Pathname,\n  PathPattern,\n  PathRouteProps,\n  RedirectFunction,\n  RelativeRoutingType,\n  RouteMatch,\n  RouteObject,\n  RouteProps,\n  RouterProps,\n  RouterProviderProps,\n  RoutesProps,\n  Search,\n  ShouldRevalidateFunction,\n  To,\n};\nexport {\n  AbortedDeferredError,\n  Await,\n  MemoryRouter,\n  Navigate,\n  NavigationType,\n  Outlet,\n  Route,\n  Router,\n  RouterProvider,\n  Routes,\n  createPath,\n  createRoutesFromChildren,\n  createRoutesFromChildren as createRoutesFromElements,\n  defer,\n  isRouteErrorResponse,\n  generatePath,\n  json,\n  matchPath,\n  matchRoutes,\n  parsePath,\n  redirect,\n  renderMatches,\n  resolvePath,\n  useActionData,\n  useAsyncError,\n  useAsyncValue,\n  useBlocker as unstable_useBlocker,\n  useHref,\n  useInRouterContext,\n  useLoaderData,\n  useLocation,\n  useMatch,\n  useMatches,\n  useNavigate,\n  useNavigation,\n  useNavigationType,\n  useOutlet,\n  useOutletContext,\n  useParams,\n  useResolvedPath,\n  useRevalidator,\n  useRouteError,\n  useRouteLoaderData,\n  useRoutes,\n};\n\nfunction mapRouteProperties(route: RouteObject) {\n  let updates: Partial<RouteObject> & { hasErrorBoundary: boolean } = {\n    // Note: this check also occurs in createRoutesFromChildren so update\n    // there if you change this -- please and thank you!\n    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null,\n  };\n\n  if (route.Component) {\n    if (__DEV__) {\n      if (route.element) {\n        warning(\n          false,\n          \"You should not include both `Component` and `element` on your route - \" +\n            \"`Component` will be used.\"\n        );\n      }\n    }\n    Object.assign(updates, {\n      element: React.createElement(route.Component),\n      Component: undefined,\n    });\n  }\n\n  if (route.ErrorBoundary) {\n    if (__DEV__) {\n      if (route.errorElement) {\n        warning(\n          false,\n          \"You should not include both `ErrorBoundary` and `errorElement` on your route - \" +\n            \"`ErrorBoundary` will be used.\"\n        );\n      }\n    }\n    Object.assign(updates, {\n      errorElement: React.createElement(route.ErrorBoundary),\n      ErrorBoundary: undefined,\n    });\n  }\n\n  return updates;\n}\n\nexport function createMemoryRouter(\n  routes: RouteObject[],\n  opts?: {\n    basename?: string;\n    future?: Partial<Omit<RouterFutureConfig, \"v7_prependBasename\">>;\n    hydrationData?: HydrationState;\n    initialEntries?: InitialEntry[];\n    initialIndex?: number;\n  }\n): RemixRouter {\n  return createRouter({\n    basename: opts?.basename,\n    future: {\n      ...opts?.future,\n      v7_prependBasename: true,\n    },\n    history: createMemoryHistory({\n      initialEntries: opts?.initialEntries,\n      initialIndex: opts?.initialIndex,\n    }),\n    hydrationData: opts?.hydrationData,\n    routes,\n    mapRouteProperties,\n  }).initialize();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// DANGER! PLEASE READ ME!\n// We provide these exports as an escape hatch in the event that you need any\n// routing data that we don't provide an explicit API for. With that said, we\n// want to cover your use case if we can, so if you feel the need to use these\n// we want to hear from you. Let us know what you're building and we'll do our\n// best to make sure we can support you!\n//\n// We consider these exports an implementation detail and do not guarantee\n// against any breaking changes, regardless of the semver release. Use with\n// extreme caution and only if you understand the consequences. Godspeed.\n///////////////////////////////////////////////////////////////////////////////\n\n/** @internal */\nexport {\n  NavigationContext as UNSAFE_NavigationContext,\n  LocationContext as UNSAFE_LocationContext,\n  RouteContext as UNSAFE_RouteContext,\n  DataRouterContext as UNSAFE_DataRouterContext,\n  DataRouterStateContext as UNSAFE_DataRouterStateContext,\n  mapRouteProperties as UNSAFE_mapRouteProperties,\n  useRouteId as UNSAFE_useRouteId,\n  useRoutesImpl as UNSAFE_useRoutesImpl,\n};\n","/**\n * @remix-run/router v1.7.2\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */\nvar Action;\n(function (Action) {\n  /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */\n  Action[\"Pop\"] = \"POP\";\n  /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */\n  Action[\"Push\"] = \"PUSH\";\n  /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */\n  Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nconst PopStateEventType = \"popstate\";\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    initialEntries = [\"/\"],\n    initialIndex,\n    v5Compat = false\n  } = options;\n  let entries; // Declare so we can access from createMemoryLocation\n  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index === 0 ? \"default\" : undefined));\n  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n  let action = Action.Pop;\n  let listener = null;\n  function clampIndex(n) {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation() {\n    return entries[index];\n  }\n  function createMemoryLocation(to, state, key) {\n    if (state === void 0) {\n      state = null;\n    }\n    let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\n    return location;\n  }\n  function createHref(to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  let history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref,\n    createURL(to) {\n      return new URL(createHref(to), \"http://localhost\");\n    },\n    encodeLocation(to) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\"\n      };\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 1\n        });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 0\n        });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta\n        });\n      }\n    },\n    listen(fn) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    }\n  };\n  return history;\n}\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createBrowserLocation(window, globalHistory) {\n    let {\n      pathname,\n      search,\n      hash\n    } = window.location;\n    return createLocation(\"\", {\n      pathname,\n      search,\n      hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n  }\n  function createBrowserHref(window, to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createHashLocation(window, globalHistory) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\"\n    } = parsePath(window.location.hash.substr(1));\n    return createLocation(\"\", {\n      pathname,\n      search,\n      hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n  }\n  function createHashHref(window, to) {\n    let base = window.document.querySelector(\"base\");\n    let href = \"\";\n    if (base && base.getAttribute(\"href\")) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n  function validateHashLocation(location, to) {\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\n  }\n  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\n * For browser-based histories, we combine the state and key into an object\n */\nfunction getHistoryState(location, index) {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index\n  };\n}\n/**\n * Creates a Location object with a unique key from the given Path\n */\nfunction createLocation(current, to, state, key) {\n  if (state === void 0) {\n    state = null;\n  }\n  let location = _extends({\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\"\n  }, typeof to === \"string\" ? parsePath(to) : to, {\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: to && to.key || key || createKey()\n  });\n  return location;\n}\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */\nfunction createPath(_ref) {\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\"\n  } = _ref;\n  if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nfunction parsePath(path) {\n  let parsedPath = {};\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n  return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    window = document.defaultView,\n    v5Compat = false\n  } = options;\n  let globalHistory = window.history;\n  let action = Action.Pop;\n  let listener = null;\n  let index = getIndex();\n  // Index should only be null when we initialize. If not, it's because the\n  // user called history.pushState or history.replaceState directly, in which\n  // case we should log a warning as it will result in bugs.\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), \"\");\n  }\n  function getIndex() {\n    let state = globalHistory.state || {\n      idx: null\n    };\n    return state.idx;\n  }\n  function handlePop() {\n    action = Action.Pop;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({\n        action,\n        location: history.location,\n        delta\n      });\n    }\n  }\n  function push(to, state) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    // try...catch because iOS limits us to 100 pushState calls :/\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      // If the exception is because `state` can't be serialized, let that throw\n      // outwards just like a replace call would so the dev knows the cause\n      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\n        throw error;\n      }\n      // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n      window.location.assign(url);\n    }\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 1\n      });\n    }\n  }\n  function replace(to, state) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 0\n      });\n    }\n  }\n  function createURL(to) {\n    // window.location.origin is \"null\" (the literal string value) in Firefox\n    // under certain conditions, notably when serving from a local HTML file\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n    let base = window.location.origin !== \"null\" ? window.location.origin : window.location.href;\n    let href = typeof to === \"string\" ? to : createPath(to);\n    invariant(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\n    return new URL(href, base);\n  }\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n    listen(fn) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n      return () => {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      // Encode a Location the same way window.location would\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    }\n  };\n  return history;\n}\n//#endregion\n\nvar ResultType;\n(function (ResultType) {\n  ResultType[\"data\"] = \"data\";\n  ResultType[\"deferred\"] = \"deferred\";\n  ResultType[\"redirect\"] = \"redirect\";\n  ResultType[\"error\"] = \"error\";\n})(ResultType || (ResultType = {}));\nconst immutableRouteKeys = new Set([\"lazy\", \"caseSensitive\", \"path\", \"id\", \"index\", \"children\"]);\nfunction isIndexRoute(route) {\n  return route.index === true;\n}\n// Walk the route tree generating unique IDs where necessary so we are working\n// solely with AgnosticDataRouteObject's within the Router\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  if (manifest === void 0) {\n    manifest = {};\n  }\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, index];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\n    invariant(!manifest[id], \"Found a route id collision on id \\\"\" + id + \"\\\".  Route \" + \"id's must be globally unique within Data Router usages\");\n    if (isIndexRoute(route)) {\n      let indexRoute = _extends({}, route, mapRouteProperties(route), {\n        id\n      });\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {\n        id,\n        children: undefined\n      });\n      manifest[id] = pathOrLayoutRoute;\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);\n      }\n      return pathOrLayoutRoute;\n    }\n  });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */\nfunction matchRoutes(routes, locationArg, basename) {\n  if (basename === void 0) {\n    basename = \"/\";\n  }\n  let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n  if (pathname == null) {\n    return null;\n  }\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(branches[i],\n    // Incoming pathnames are generally encoded from either window.location\n    // or from router.navigate, but we want to match against the unencoded\n    // paths in the route definitions.  Memory router locations won't be\n    // encoded here but there also shouldn't be anything to decode so this\n    // should be a safe operation.  This avoids needing matchRoutes to be\n    // history-aware.\n    safelyDecodeURI(pathname));\n  }\n  return matches;\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n  if (branches === void 0) {\n    branches = [];\n  }\n  if (parentsMeta === void 0) {\n    parentsMeta = [];\n  }\n  if (parentPath === void 0) {\n    parentPath = \"\";\n  }\n  let flattenRoute = (route, index, relativePath) => {\n    let meta = {\n      relativePath: relativePath === undefined ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route\n    };\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(meta.relativePath.startsWith(parentPath), \"Absolute route path \\\"\" + meta.relativePath + \"\\\" nested under path \" + (\"\\\"\" + parentPath + \"\\\" is not valid. An absolute child route path \") + \"must start with the combined path of all its parent routes.\");\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n    // Add the children before adding this route to the array so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n      // Our types know better, but runtime JS may not!\n      // @ts-expect-error\n      route.index !== true, \"Index routes must not have child routes. Please remove \" + (\"all child routes from route path \\\"\" + path + \"\\\".\"));\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta\n    });\n  };\n  routes.forEach((route, index) => {\n    var _route$path;\n    // coarse-grain check for optional params\n    if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n  return branches;\n}\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */\nfunction explodeOptionalSegments(path) {\n  let segments = path.split(\"/\");\n  if (segments.length === 0) return [];\n  let [first, ...rest] = segments;\n  // Optional path segments are denoted by a trailing `?`\n  let isOptional = first.endsWith(\"?\");\n  // Compute the corresponding required segment: `foo?` -> `foo`\n  let required = first.replace(/\\?$/, \"\");\n  if (rest.length === 0) {\n    // Intepret empty string as omitting an optional segment\n    // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n    return isOptional ? [required, \"\"] : [required];\n  }\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n  let result = [];\n  // All child paths with the prefix.  Do this for all children before the\n  // optional version for all children so we get consistent ordering where the\n  // parent optional aspect is preferred as required.  Otherwise, we can get\n  // child sections interspersed where deeper optional segments are higher than\n  // parent optional segments, where for example, /:two would explodes _earlier_\n  // then /:one.  By always including the parent as required _for all children_\n  // first, we avoid this issue\n  result.push(...restExploded.map(subpath => subpath === \"\" ? required : [required, subpath].join(\"/\")));\n  // Then if this is an optional value, add all child versions without\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n  // for absolute paths, ensure `/` instead of empty segment\n  return result.map(exploded => path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction rankRouteBranches(branches) {\n  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first\n  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));\n}\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = s => s === \"*\";\nfunction computeScore(path, index) {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n  return siblings ?\n  // If two routes are siblings, we should try to match the earlier sibling\n  // first. This allows people to have fine-grained control over the matching\n  // behavior by simply putting routes with identical paths in the order they\n  // want them tried.\n  a[a.length - 1] - b[b.length - 1] :\n  // Otherwise, it doesn't really make sense to rank non-siblings by index,\n  // so they sort equally.\n  0;\n}\nfunction matchRouteBranch(branch, pathname) {\n  let {\n    routesMeta\n  } = branch;\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath({\n      path: meta.relativePath,\n      caseSensitive: meta.caseSensitive,\n      end\n    }, remainingPathname);\n    if (!match) return null;\n    Object.assign(matchedParams, match.params);\n    let route = meta.route;\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),\n      route\n    });\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n  return matches;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */\nfunction generatePath(originalPath, params) {\n  if (params === void 0) {\n    params = {};\n  }\n  let path = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(false, \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\n    path = path.replace(/\\*$/, \"/*\");\n  }\n  // ensure `/` is added at the beginning if the path is absolute\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n  const stringify = p => p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n  const segments = path.split(/\\/+/).map((segment, index, array) => {\n    const isLastSegment = index === array.length - 1;\n    // only apply the splat if it's the last segment\n    if (isLastSegment && segment === \"*\") {\n      const star = \"*\";\n      // Apply the splat\n      return stringify(params[star]);\n    }\n    const keyMatch = segment.match(/^:(\\w+)(\\??)$/);\n    if (keyMatch) {\n      const [, key, optional] = keyMatch;\n      let param = params[key];\n      invariant(optional === \"?\" || param != null, \"Missing \\\":\" + key + \"\\\" param\");\n      return stringify(param);\n    }\n    // Remove any optional markers from optional static segments\n    return segment.replace(/\\?$/g, \"\");\n  })\n  // Remove empty segments\n  .filter(segment => !!segment);\n  return prefix + segments.join(\"/\");\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === \"string\") {\n    pattern = {\n      path: pattern,\n      caseSensitive: false,\n      end: true\n    };\n  }\n  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n  let match = pathname.match(matcher);\n  if (!match) return null;\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params = paramNames.reduce((memo, paramName, index) => {\n    // We need to compute the pathnameBase here using the raw splat value\n    // instead of using params[\"*\"] later because it will be decoded then\n    if (paramName === \"*\") {\n      let splatValue = captureGroups[index] || \"\";\n      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n    }\n    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || \"\", paramName);\n    return memo;\n  }, {});\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\nfunction compilePath(path, caseSensitive, end) {\n  if (caseSensitive === void 0) {\n    caseSensitive = false;\n  }\n  if (end === void 0) {\n    end = true;\n  }\n  warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\n  let paramNames = [];\n  let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n  .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n  .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n  .replace(/\\/:(\\w+)/g, (_, paramName) => {\n    paramNames.push(paramName);\n    return \"/([^\\\\/]+)\";\n  });\n  if (path.endsWith(\"*\")) {\n    paramNames.push(\"*\");\n    regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\n    : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else if (end) {\n    // When matching to the end, ignore trailing slashes\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    // If our path is non-empty and contains anything beyond an initial slash,\n    // then we have _some_ form of path in our regex so we should expect to\n    // match only if we find the end of this path segment.  Look for an optional\n    // non-captured trailing slash (to match a portion of the URL) or the end\n    // of the path (if we've matched to the end).  We used to do this with a\n    // word boundary but that gives false positives on routes like\n    // /user-preferences since `-` counts as a word boundary.\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else ;\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n  return [matcher, paramNames];\n}\nfunction safelyDecodeURI(value) {\n  try {\n    return decodeURI(value);\n  } catch (error) {\n    warning(false, \"The URL path \\\"\" + value + \"\\\" could not be decoded because it is is a \" + \"malformed URL segment. This is probably due to a bad percent \" + (\"encoding (\" + error + \").\"));\n    return value;\n  }\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(false, \"The value for the URL param \\\"\" + paramName + \"\\\" will not be decoded because\" + (\" the string \\\"\" + value + \"\\\" is a malformed URL segment. This is probably\") + (\" due to a bad percent encoding (\" + error + \").\"));\n    return value;\n  }\n}\n/**\n * @private\n */\nfunction stripBasename(pathname, basename) {\n  if (basename === \"/\") return pathname;\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n  // We want to leave trailing slash behavior in the user's control, so if they\n  // specify a basename with a trailing slash, we should support it\n  let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n  return pathname.slice(startIndex) || \"/\";\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */\nfunction resolvePath(to, fromPathname) {\n  if (fromPathname === void 0) {\n    fromPathname = \"/\";\n  }\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\"\n  } = typeof to === \"string\" ? parsePath(to) : to;\n  let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n  relativeSegments.forEach(segment => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n  return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + \"a string in <Link to=\\\"...\\\"> and the router will parse it for you.\";\n}\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */\nfunction getPathContributingMatches(matches) {\n  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);\n}\n/**\n * @private\n */\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n  if (isPathRelative === void 0) {\n    isPathRelative = false;\n  }\n  let to;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = _extends({}, toArg);\n    invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n    invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n    invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n  }\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n  let from;\n  // Routing is relative to the current pathname if explicitly requested.\n  //\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  if (isPathRelative || toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n      // Each leading .. segment means \"go up one route\" instead of \"go up one\n      // URL segment\".  This is a key difference from how <a href> works and a\n      // major reason we call this a \"to\" value instead of a \"href\".\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n    // If there are more \"..\" segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n  let path = resolvePath(to, from);\n  // Ensure the pathname has a trailing slash if the original \"to\" had one\n  let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  // Or if this was a link to the current path which has a trailing slash\n  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n    path.pathname += \"/\";\n  }\n  return path;\n}\n/**\n * @private\n */\nfunction getToPathname(to) {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\n}\n/**\n * @private\n */\nconst joinPaths = paths => paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n/**\n * @private\n */\nconst normalizePathname = pathname => pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n/**\n * @private\n */\nconst normalizeSearch = search => !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n/**\n * @private\n */\nconst normalizeHash = hash => !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */\nconst json = function json(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n  }\n  return new Response(JSON.stringify(data), _extends({}, responseInit, {\n    headers\n  }));\n};\nclass AbortedDeferredError extends Error {}\nclass DeferredData {\n  constructor(data, responseInit) {\n    this.pendingKeysSet = new Set();\n    this.subscribers = new Set();\n    this.deferredKeys = [];\n    invariant(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\");\n    // Set up an AbortController + Promise we can race against to exit early\n    // cancellation\n    let reject;\n    this.abortPromise = new Promise((_, r) => reject = r);\n    this.controller = new AbortController();\n    let onAbort = () => reject(new AbortedDeferredError(\"Deferred data aborted\"));\n    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener(\"abort\", onAbort);\n    this.controller.signal.addEventListener(\"abort\", onAbort);\n    this.data = Object.entries(data).reduce((acc, _ref) => {\n      let [key, value] = _ref;\n      return Object.assign(acc, {\n        [key]: this.trackPromise(key, value)\n      });\n    }, {});\n    if (this.done) {\n      // All incoming values were resolved\n      this.unlistenAbortSignal();\n    }\n    this.init = responseInit;\n  }\n  trackPromise(key, value) {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n    this.deferredKeys.push(key);\n    this.pendingKeysSet.add(key);\n    // We store a little wrapper promise that will be extended with\n    // _data/_error props upon resolve/reject\n    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, undefined, data), error => this.onSettle(promise, key, error));\n    // Register rejection listeners to avoid uncaught promise rejections on\n    // errors or aborted deferred values\n    promise.catch(() => {});\n    Object.defineProperty(promise, \"_tracked\", {\n      get: () => true\n    });\n    return promise;\n  }\n  onSettle(promise, key, error, data) {\n    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      return Promise.reject(error);\n    }\n    this.pendingKeysSet.delete(key);\n    if (this.done) {\n      // Nothing left to abort!\n      this.unlistenAbortSignal();\n    }\n    // If the promise was resolved/rejected with undefined, we'll throw an error as you\n    // should always resolve with a value or null\n    if (error === undefined && data === undefined) {\n      let undefinedError = new Error(\"Deferred data for key \\\"\" + key + \"\\\" resolved/rejected with `undefined`, \" + \"you must resolve/reject with a value or `null`.\");\n      Object.defineProperty(promise, \"_error\", {\n        get: () => undefinedError\n      });\n      this.emit(false, key);\n      return Promise.reject(undefinedError);\n    }\n    if (data === undefined) {\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      this.emit(false, key);\n      return Promise.reject(error);\n    }\n    Object.defineProperty(promise, \"_data\", {\n      get: () => data\n    });\n    this.emit(false, key);\n    return data;\n  }\n  emit(aborted, settledKey) {\n    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));\n  }\n  subscribe(fn) {\n    this.subscribers.add(fn);\n    return () => this.subscribers.delete(fn);\n  }\n  cancel() {\n    this.controller.abort();\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\n    this.emit(true);\n  }\n  async resolveData(signal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener(\"abort\", onAbort);\n      aborted = await new Promise(resolve => {\n        this.subscribe(aborted => {\n          signal.removeEventListener(\"abort\", onAbort);\n          if (aborted || this.done) {\n            resolve(aborted);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n  get done() {\n    return this.pendingKeysSet.size === 0;\n  }\n  get unwrappedData() {\n    invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\n    return Object.entries(this.data).reduce((acc, _ref2) => {\n      let [key, value] = _ref2;\n      return Object.assign(acc, {\n        [key]: unwrapTrackedPromise(value)\n      });\n    }, {});\n  }\n  get pendingKeys() {\n    return Array.from(this.pendingKeysSet);\n  }\n}\nfunction isTrackedPromise(value) {\n  return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\nconst defer = function defer(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  return new DeferredData(data, responseInit);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nconst redirect = function redirect(url, init) {\n  if (init === void 0) {\n    init = 302;\n  }\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = {\n      status: responseInit\n    };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n  return new Response(null, _extends({}, responseInit, {\n    headers\n  }));\n};\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n */\nclass ErrorResponse {\n  constructor(status, statusText, data, internal) {\n    if (internal === void 0) {\n      internal = false;\n    }\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data instanceof Error) {\n      this.data = data.toString();\n      this.error = data;\n    } else {\n      this.data = data;\n    }\n  }\n}\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */\nfunction isRouteErrorResponse(error) {\n  return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\n\nconst validMutationMethodsArr = [\"post\", \"put\", \"patch\", \"delete\"];\nconst validMutationMethods = new Set(validMutationMethodsArr);\nconst validRequestMethodsArr = [\"get\", ...validMutationMethodsArr];\nconst validRequestMethods = new Set(validRequestMethodsArr);\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst redirectPreserveMethodStatusCodes = new Set([307, 308]);\nconst IDLE_NAVIGATION = {\n  state: \"idle\",\n  location: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nconst IDLE_FETCHER = {\n  state: \"idle\",\n  data: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nconst IDLE_BLOCKER = {\n  state: \"unblocked\",\n  proceed: undefined,\n  reset: undefined,\n  location: undefined\n};\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nconst defaultMapRouteProperties = route => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary)\n});\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */\nfunction createRouter(init) {\n  const routerWindow = init.window ? init.window : typeof window !== \"undefined\" ? window : undefined;\n  const isBrowser = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n  const isServer = !isBrowser;\n  invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n  let mapRouteProperties;\n  if (init.mapRouteProperties) {\n    mapRouteProperties = init.mapRouteProperties;\n  } else if (init.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = init.detectErrorBoundary;\n    mapRouteProperties = route => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  // Routes keyed by ID\n  let manifest = {};\n  // Routes in tree format for matching\n  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);\n  let inFlightDataRoutes;\n  let basename = init.basename || \"/\";\n  // Config driven behavior flags\n  let future = _extends({\n    v7_normalizeFormMethod: false,\n    v7_prependBasename: false\n  }, init.future);\n  // Cleanup function for history\n  let unlistenHistory = null;\n  // Externally-provided functions to call on all state changes\n  let subscribers = new Set();\n  // Externally-provided object to hold scroll restoration locations during routing\n  let savedScrollPositions = null;\n  // Externally-provided function to get scroll restoration keys\n  let getScrollRestorationKey = null;\n  // Externally-provided function to get current scroll position\n  let getScrollPosition = null;\n  // One-time flag to control the initial hydration scroll restoration.  Because\n  // we don't get the saved positions from <ScrollRestoration /> until _after_\n  // the initial render, we need to manually trigger a separate updateState to\n  // send along the restoreScrollPosition\n  // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n  // SSR did the initial scroll restoration.\n  let initialScrollRestored = init.hydrationData != null;\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialErrors = null;\n  if (initialMatches == null) {\n    // If we do not match a user-provided-route, fall back to the root\n    // to allow the error boundary to take over\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname\n    });\n    let {\n      matches,\n      route\n    } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = {\n      [route.id]: error\n    };\n  }\n  let initialized =\n  // All initialMatches need to be loaded before we're ready.  If we have lazy\n  // functions around still then we'll need to run them in initialize()\n  !initialMatches.some(m => m.route.lazy) && (\n  // And we have to either have no loaders or have been provided hydrationData\n  !initialMatches.some(m => m.route.loader) || init.hydrationData != null);\n  let router;\n  let state = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n    fetchers: new Map(),\n    blockers: new Map()\n  };\n  // -- Stateful internal variables to manage navigations --\n  // Current navigation in progress (to be committed in completeNavigation)\n  let pendingAction = Action.Pop;\n  // Should the current navigation prevent the scroll reset if scroll cannot\n  // be restored?\n  let pendingPreventScrollReset = false;\n  // AbortController for the active navigation\n  let pendingNavigationController;\n  // We use this to avoid touching history in completeNavigation if a\n  // revalidation is entirely uninterrupted\n  let isUninterruptedRevalidation = false;\n  // Use this internal flag to force revalidation of all loaders:\n  //  - submissions (completed or interrupted)\n  //  - useRevalidator()\n  //  - X-Remix-Revalidate (from redirect)\n  let isRevalidationRequired = false;\n  // Use this internal array to capture routes that require revalidation due\n  // to a cancelled deferred on action submission\n  let cancelledDeferredRoutes = [];\n  // Use this internal array to capture fetcher loads that were cancelled by an\n  // action navigation and require revalidation\n  let cancelledFetcherLoads = [];\n  // AbortControllers for any in-flight fetchers\n  let fetchControllers = new Map();\n  // Track loads based on the order in which they started\n  let incrementingLoadId = 0;\n  // Track the outstanding pending navigation data load to be compared against\n  // the globally incrementing load when a fetcher load lands after a completed\n  // navigation\n  let pendingNavigationLoadId = -1;\n  // Fetchers that triggered data reloads as a result of their actions\n  let fetchReloadIds = new Map();\n  // Fetchers that triggered redirect navigations\n  let fetchRedirectIds = new Set();\n  // Most recent href/match for fetcher.load calls for fetchers\n  let fetchLoadMatches = new Map();\n  // Store DeferredData instances for active route matches.  When a\n  // route loader returns defer() we stick one in here.  Then, when a nested\n  // promise resolves we update loaderData.  If a new navigation starts we\n  // cancel active deferreds for eliminated routes.\n  let activeDeferreds = new Map();\n  // Store blocker functions in a separate Map outside of router state since\n  // we don't need to update UI state if they change\n  let blockerFunctions = new Map();\n  // Flag to ignore the next history update, so we can revert the URL change on\n  // a POP navigation that was blocked by the user without touching router state\n  let ignoreNextHistoryUpdate = false;\n  // Initialize the router, all side effects should be kicked off from here.\n  // Implemented as a Fluent API for ease of:\n  //   let router = createRouter(init).initialize();\n  function initialize() {\n    // If history informs us of a POP navigation, start the navigation but do not update\n    // state.  We'll update our own state once the navigation completes\n    unlistenHistory = init.history.listen(_ref => {\n      let {\n        action: historyAction,\n        location,\n        delta\n      } = _ref;\n      // Ignore this event if it was just us resetting the URL from a\n      // blocked POP navigation\n      if (ignoreNextHistoryUpdate) {\n        ignoreNextHistoryUpdate = false;\n        return;\n      }\n      warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location \" + \"that was not created by @remix-run/router. This will fail silently in \" + \"production. This can happen if you are navigating outside the router \" + \"via `window.history.pushState`/`window.location.hash` instead of using \" + \"router navigation APIs.  This can also happen if you are using \" + \"createHashRouter and the user manually changes the URL.\");\n      let blockerKey = shouldBlockNavigation({\n        currentLocation: state.location,\n        nextLocation: location,\n        historyAction\n      });\n      if (blockerKey && delta != null) {\n        // Restore the URL to match the current UI, but don't update router state\n        ignoreNextHistoryUpdate = true;\n        init.history.go(delta * -1);\n        // Put the blocker into a blocked state\n        updateBlocker(blockerKey, {\n          state: \"blocked\",\n          location,\n          proceed() {\n            updateBlocker(blockerKey, {\n              state: \"proceeding\",\n              proceed: undefined,\n              reset: undefined,\n              location\n            });\n            // Re-do the same POP navigation we just blocked\n            init.history.go(delta);\n          },\n          reset() {\n            let blockers = new Map(state.blockers);\n            blockers.set(blockerKey, IDLE_BLOCKER);\n            updateState({\n              blockers\n            });\n          }\n        });\n        return;\n      }\n      return startNavigation(historyAction, location);\n    });\n    // Kick off initial data load if needed.  Use Pop to avoid modifying history\n    // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n    // in the normal navigation flow.  For SSR it's expected that lazy modules are\n    // resolved prior to router creation since we can't go into a fallbackElement\n    // UI for SSR'd apps\n    if (!state.initialized) {\n      startNavigation(Action.Pop, state.location);\n    }\n    return router;\n  }\n  // Clean up a router and it's side effects\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n  // Subscribe to state updates for the router\n  function subscribe(fn) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n  // Update our state and notify the calling context of the change\n  function updateState(newState) {\n    state = _extends({}, state, newState);\n    subscribers.forEach(subscriber => subscriber(state));\n  }\n  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n  // and setting state.[historyAction/location/matches] to the new route.\n  // - Location is a required param\n  // - Navigation will always be set to IDLE_NAVIGATION\n  // - Can pass any other state in newState\n  function completeNavigation(location, newState) {\n    var _location$state, _location$state2;\n    // Deduce if we're in a loading/actionReload state:\n    // - We have committed actionData in the store\n    // - The current navigation was a mutation submission\n    // - We're past the submitting state and into the loading state\n    // - The location being loaded is not the result of a redirect\n    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n    let actionData;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        // Empty actionData -> clear prior actionData due to an action error\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      // Keep the current data if we're wrapping up the action reload\n      actionData = state.actionData;\n    } else {\n      // Clear actionData on any other completed navigations\n      actionData = null;\n    }\n    // Always preserve any existing loaderData from re-used routes\n    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n    // On a successful navigation we can assume we got through all blockers\n    // so we can start fresh\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n    // Always respect the user flag.  Otherwise don't reset on mutation\n    // submission navigations unless they redirect\n    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = undefined;\n    }\n    if (isUninterruptedRevalidation) ; else if (pendingAction === Action.Pop) ; else if (pendingAction === Action.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === Action.Replace) {\n      init.history.replace(location, location.state);\n    }\n    updateState(_extends({}, newState, {\n      actionData,\n      loaderData,\n      historyAction: pendingAction,\n      location,\n      initialized: true,\n      navigation: IDLE_NAVIGATION,\n      revalidation: \"idle\",\n      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n      preventScrollReset,\n      blockers\n    }));\n    // Reset stateful navigation vars\n    pendingAction = Action.Pop;\n    pendingPreventScrollReset = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n  // Trigger a navigation event, which can either be a numerical POP or a PUSH\n  // replace with an optional submission\n  async function navigate(to, opts) {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n    // URL from window.location, so we need to encode it here so the behavior\n    // remains the same as POP and non-data-router usages.  new URL() does all\n    // the same encoding we'd get from a history.pushState/window.location read\n    // without having to touch history\n    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n    let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n    let historyAction = Action.Push;\n    if (userReplace === true) {\n      historyAction = Action.Replace;\n    } else if (userReplace === false) ; else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n      // By default on submissions to the current location we REPLACE so that\n      // users don't have to double-click the back button to get to the prior\n      // location.  If the user redirects to a different location from the\n      // action/loader this will be ignored and the redirect will be a PUSH\n      historyAction = Action.Replace;\n    }\n    let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : undefined;\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction\n    });\n    if (blockerKey) {\n      // Put the blocker into a blocked state\n      updateBlocker(blockerKey, {\n        state: \"blocked\",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey, {\n            state: \"proceeding\",\n            proceed: undefined,\n            reset: undefined,\n            location: nextLocation\n          });\n          // Send the same navigation through\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey, IDLE_BLOCKER);\n          updateState({\n            blockers\n          });\n        }\n      });\n      return;\n    }\n    return await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace\n    });\n  }\n  // Revalidate all current loaders.  If a navigation is in progress or if this\n  // is interrupted by a navigation, allow this to \"succeed\" by calling all\n  // loaders during the next loader round\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({\n      revalidation: \"loading\"\n    });\n    // If we're currently submitting an action, we don't need to start a new\n    // navigation, we'll just let the follow up loader execution call all loaders\n    if (state.navigation.state === \"submitting\") {\n      return;\n    }\n    // If we're currently in an idle state, start a new navigation for the current\n    // action/location and mark it as uninterrupted, which will skip the history\n    // update in completeNavigation\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true\n      });\n      return;\n    }\n    // Otherwise, if we're currently in a loading state, just start a new\n    // navigation to the navigation.location but do not trigger an uninterrupted\n    // revalidation so that history correctly updates once the navigation completes\n    startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n      overrideNavigation: state.navigation\n    });\n  }\n  // Start a navigation to the given action/location.  Can optionally provide a\n  // overrideNavigation which will override the normalLoad in the case of a redirect\n  // navigation\n  async function startNavigation(historyAction, location, opts) {\n    // Abort any in-progress navigations and start a new one. Unset any ongoing\n    // uninterrupted revalidations unless told otherwise, since we want this\n    // new navigation to update history normally\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n    // Save the current scroll position every time we start a new navigation,\n    // and track whether we should reset scroll on completion\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(routesToUse, location, basename);\n    // Short circuit with a 404 on the root error boundary if we match nothing\n    if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(routesToUse);\n      // Cancel all pending deferred on 404s since we don't keep any routes\n      cancelActiveDeferreds();\n      completeNavigation(location, {\n        matches: notFoundMatches,\n        loaderData: {},\n        errors: {\n          [route.id]: error\n        }\n      });\n      return;\n    }\n    // Short circuit if it's only a hash change and not a revalidation or\n    // mutation submission.\n    //\n    // Ignore on initial page loads because since the initial load will always\n    // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n    // which will default to a navigation to /page\n    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n      completeNavigation(location, {\n        matches\n      });\n      return;\n    }\n    // Create a controller/Request for this navigation\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n    let pendingActionData;\n    let pendingError;\n    if (opts && opts.pendingError) {\n      // If we have a pendingError, it means the user attempted a GET submission\n      // with binary FormData so assign here and skip to handleLoaders.  That\n      // way we handle calling loaders above the boundary etc.  It's not really\n      // different from an actionError in that sense.\n      pendingError = {\n        [findNearestBoundary(matches).route.id]: opts.pendingError\n      };\n    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n      // Call action if we received an action submission\n      let actionOutput = await handleAction(request, location, opts.submission, matches, {\n        replace: opts.replace\n      });\n      if (actionOutput.shortCircuited) {\n        return;\n      }\n      pendingActionData = actionOutput.pendingActionData;\n      pendingError = actionOutput.pendingActionError;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n      // Create a GET request for the loaders\n      request = new Request(request.url, {\n        signal: request.signal\n      });\n    }\n    // Call loaders\n    let {\n      shortCircuited,\n      loaderData,\n      errors\n    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, pendingActionData, pendingError);\n    if (shortCircuited) {\n      return;\n    }\n    // Clean up now that the action/loaders have completed.  Don't clean up if\n    // we short circuited because pendingNavigationController will have already\n    // been assigned to a new controller for the next navigation\n    pendingNavigationController = null;\n    completeNavigation(location, _extends({\n      matches\n    }, pendingActionData ? {\n      actionData: pendingActionData\n    } : {}, {\n      loaderData,\n      errors\n    }));\n  }\n  // Call the action matched by the leaf route for this navigation and handle\n  // redirects/errors\n  async function handleAction(request, location, submission, matches, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    interruptActiveLoads();\n    // Put us in a submitting state\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({\n      navigation\n    });\n    // Call our action and get the result\n    let result;\n    let actionMatch = getTargetMatch(matches, location);\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: ResultType.error,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id\n        })\n      };\n    } else {\n      result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename);\n      if (request.signal.aborted) {\n        return {\n          shortCircuited: true\n        };\n      }\n    }\n    if (isRedirectResult(result)) {\n      let replace;\n      if (opts && opts.replace != null) {\n        replace = opts.replace;\n      } else {\n        // If the user didn't explicity indicate replace behavior, replace if\n        // we redirected to the exact same location we're currently at to avoid\n        // double back-buttons\n        replace = result.location === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(state, result, {\n        submission,\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      // By default, all submissions are REPLACE navigations, but if the\n      // action threw an error that'll be rendered in an errorElement, we fall\n      // back to PUSH so that the user can use the back button to get back to\n      // the pre-submission form location to try again\n      if ((opts && opts.replace) !== true) {\n        pendingAction = Action.Push;\n      }\n      return {\n        // Send back an empty object we can use to clear out any prior actionData\n        pendingActionData: {},\n        pendingActionError: {\n          [boundaryMatch.route.id]: result.error\n        }\n      };\n    }\n    if (isDeferredResult(result)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n    return {\n      pendingActionData: {\n        [actionMatch.route.id]: result.data\n      }\n    };\n  }\n  // Call all applicable loaders for the given matches, handling redirects,\n  // errors, etc.\n  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, pendingActionData, pendingError) {\n    // Figure out the right navigation we want to use for data loading\n    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n    // If this was a redirect from an action we don't have a \"submission\" but\n    // we have it on the loading navigation so use that if available\n    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);\n    // Cancel pending deferreds for no-longer-matched routes or routes we're\n    // about to reload.  Note that if this is an action reload we would have\n    // already cancelled all pending deferreds so this would be a no-op\n    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId));\n    pendingNavigationLoadId = ++incrementingLoadId;\n    // Short circuit if we have no loaders to run\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      let updatedFetchers = markFetchRedirectsDone();\n      completeNavigation(location, _extends({\n        matches,\n        loaderData: {},\n        // Commit pending error if we're short circuiting\n        errors: pendingError || null\n      }, pendingActionData ? {\n        actionData: pendingActionData\n      } : {}, updatedFetchers ? {\n        fetchers: new Map(state.fetchers)\n      } : {}));\n      return {\n        shortCircuited: true\n      };\n    }\n    // If this is an uninterrupted revalidation, we remain in our current idle\n    // state.  If not, we need to switch to our loading state and load data,\n    // preserving any new action data or existing action data (in the case of\n    // a revalidation interrupting an actionReload)\n    if (!isUninterruptedRevalidation) {\n      revalidatingFetchers.forEach(rf => {\n        let fetcher = state.fetchers.get(rf.key);\n        let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);\n        state.fetchers.set(rf.key, revalidatingFetcher);\n      });\n      let actionData = pendingActionData || state.actionData;\n      updateState(_extends({\n        navigation: loadingNavigation\n      }, actionData ? Object.keys(actionData).length === 0 ? {\n        actionData: null\n      } : {\n        actionData\n      } : {}, revalidatingFetchers.length > 0 ? {\n        fetchers: new Map(state.fetchers)\n      } : {}));\n    }\n    revalidatingFetchers.forEach(rf => {\n      if (fetchControllers.has(rf.key)) {\n        abortFetcher(rf.key);\n      }\n      if (rf.controller) {\n        // Fetchers use an independent AbortController so that aborting a fetcher\n        // (via deleteFetcher) does not abort the triggering navigation that\n        // triggered the revalidation\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n    // Proxy navigation abort through to revalidation fetchers\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(f => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\n    if (request.signal.aborted) {\n      return {\n        shortCircuited: true\n      };\n    }\n    // Clean up _after_ loaders have completed.  Don't clean up if we short\n    // circuited because fetchControllers would have been aborted and\n    // reassigned to new controllers for the next navigation\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key));\n    // If any loaders returned a redirect Response, start a new REPLACE navigation\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      await startRedirectNavigation(state, redirect.result, {\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    // Process and commit output from loaders\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);\n    // Wire up subscribers to update loaderData as promises settle\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe(aborted => {\n        // Note: No need to updateState here since the TrackedPromise on\n        // loaderData is stable across resolve/reject\n        // Remove this instance if we were aborted or if promises have settled\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n    return _extends({\n      loaderData,\n      errors\n    }, shouldUpdateFetchers ? {\n      fetchers: new Map(state.fetchers)\n    } : {});\n  }\n  function getFetcher(key) {\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n  // Trigger a fetcher load/submit for the given fetcher key\n  function fetch(key, routeId, href, opts) {\n    if (isServer) {\n      throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. \" + \"You are likely calling a useFetcher() method in the body of your component. \" + \"Try moving it to a useEffect or a callback.\");\n    }\n    if (fetchControllers.has(key)) abortFetcher(key);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, routeId, opts == null ? void 0 : opts.relative);\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n    if (!matches) {\n      setFetcherError(key, routeId, getInternalRouterError(404, {\n        pathname: normalizedPath\n      }));\n      return;\n    }\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\n    if (error) {\n      setFetcherError(key, routeId, error);\n      return;\n    }\n    let match = getTargetMatch(matches, path);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(key, routeId, path, match, matches, submission);\n      return;\n    }\n    // Store off the match so we can call it's shouldRevalidate on subsequent\n    // revalidations\n    fetchLoadMatches.set(key, {\n      routeId,\n      path\n    });\n    handleFetcherLoader(key, routeId, path, match, matches, submission);\n  }\n  // Call the action for the matched fetcher.submit(), and then handle redirects,\n  // errors, and revalidation\n  async function handleFetcherAction(key, routeId, path, match, requestMatches, submission) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n    if (!match.route.action && !match.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId: routeId\n      });\n      setFetcherError(key, routeId, error);\n      return;\n    }\n    // Put this fetcher into it's submitting state\n    let existingFetcher = state.fetchers.get(key);\n    let fetcher = getSubmittingFetcher(submission, existingFetcher);\n    state.fetchers.set(key, fetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n    // Call the action for the fetcher\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let actionResult = await callLoaderOrAction(\"action\", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename);\n    if (fetchRequest.signal.aborted) {\n      // We can delete this so long as we weren't aborted by ou our own fetcher\n      // re-submit which would have put _new_ controller is in fetchControllers\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n    if (isRedirectResult(actionResult)) {\n      fetchControllers.delete(key);\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our action started, so that\n        // should take precedence over this redirect navigation.  We already\n        // set isRevalidationRequired so all loaders for the new route should\n        // fire unless opted out via shouldRevalidate\n        let doneFetcher = getDoneFetcher(undefined);\n        state.fetchers.set(key, doneFetcher);\n        updateState({\n          fetchers: new Map(state.fetchers)\n        });\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        let loadingFetcher = getLoadingFetcher(submission);\n        state.fetchers.set(key, loadingFetcher);\n        updateState({\n          fetchers: new Map(state.fetchers)\n        });\n        return startRedirectNavigation(state, actionResult, {\n          submission,\n          isFetchActionRedirect: true\n        });\n      }\n    }\n    // Process any non-redirect errors thrown\n    if (isErrorResult(actionResult)) {\n      setFetcherError(key, routeId, actionResult.error);\n      return;\n    }\n    if (isDeferredResult(actionResult)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n    // Start the data load for current matches, or the next location if we're\n    // in the middle of a navigation\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, {\n      [match.route.id]: actionResult.data\n    }, undefined // No need to send through errors since we short circuit above\n    );\n    // Put all revalidating fetchers into the loading state, except for the\n    // current fetcher which we want to keep in it's current loading state which\n    // contains it's action submission info + action data\n    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {\n      let staleKey = rf.key;\n      let existingFetcher = state.fetchers.get(staleKey);\n      let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);\n      state.fetchers.set(staleKey, revalidatingFetcher);\n      if (fetchControllers.has(staleKey)) {\n        abortFetcher(staleKey);\n      }\n      if (rf.controller) {\n        fetchControllers.set(staleKey, rf.controller);\n      }\n    });\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(rf => abortFetcher(rf.key));\n    abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n    if (abortController.signal.aborted) {\n      return;\n    }\n    abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      return startRedirectNavigation(state, redirect.result);\n    }\n    // Process and commit output from loaders\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);\n    // Since we let revalidations complete even if the submitting fetcher was\n    // deleted, only put it back to idle if it hasn't been deleted\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n    let didAbortFetchLoads = abortStaleFetchLoads(loadId);\n    // If we are currently in a navigation loading state and this fetcher is\n    // more recent than the navigation, we want the newer data so abort the\n    // navigation and complete it with the fetcher data\n    if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers)\n      });\n    } else {\n      // otherwise just update with the fetcher data, preserving any existing\n      // loaderData for loaders that did not need to reload.  We have to\n      // manually merge here since we aren't going through completeNavigation\n      updateState(_extends({\n        errors,\n        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)\n      }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {\n        fetchers: new Map(state.fetchers)\n      } : {}));\n      isRevalidationRequired = false;\n    }\n  }\n  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n  async function handleFetcherLoader(key, routeId, path, match, matches, submission) {\n    let existingFetcher = state.fetchers.get(key);\n    // Put this fetcher into it's loading state\n    let loadingFetcher = getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined);\n    state.fetchers.set(key, loadingFetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n    // Call the loader for this fetcher route match\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let result = await callLoaderOrAction(\"loader\", fetchRequest, match, matches, manifest, mapRouteProperties, basename);\n    // Deferred isn't supported for fetcher loads, await everything and treat it\n    // as a normal load.  resolveDeferredData will return undefined if this\n    // fetcher gets aborted, so we just leave result untouched and short circuit\n    // below if that happens\n    if (isDeferredResult(result)) {\n      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;\n    }\n    // We can delete this so long as we weren't aborted by our our own fetcher\n    // re-load which would have put _new_ controller is in fetchControllers\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n    // If the loader threw a redirect Response, start a new REPLACE navigation\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our loader started, so that\n        // should take precedence over this redirect navigation\n        let doneFetcher = getDoneFetcher(undefined);\n        state.fetchers.set(key, doneFetcher);\n        updateState({\n          fetchers: new Map(state.fetchers)\n        });\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(state, result);\n        return;\n      }\n    }\n    // Process any non-redirect errors thrown\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, routeId);\n      state.fetchers.delete(key);\n      // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -\n      // do we need to behave any differently with our non-redirect errors?\n      // What if it was a non-redirect Response?\n      updateState({\n        fetchers: new Map(state.fetchers),\n        errors: {\n          [boundaryMatch.route.id]: result.error\n        }\n      });\n      return;\n    }\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n    // Put the fetcher back into an idle state\n    let doneFetcher = getDoneFetcher(result.data);\n    state.fetchers.set(key, doneFetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n  }\n  /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */\n  async function startRedirectNavigation(state, redirect, _temp) {\n    let {\n      submission,\n      replace,\n      isFetchActionRedirect\n    } = _temp === void 0 ? {} : _temp;\n    if (redirect.revalidate) {\n      isRevalidationRequired = true;\n    }\n    let redirectLocation = createLocation(state.location, redirect.location, // TODO: This can be removed once we get rid of useTransition in Remix v2\n    _extends({\n      _isRedirect: true\n    }, isFetchActionRedirect ? {\n      _isFetchActionRedirect: true\n    } : {}));\n    invariant(redirectLocation, \"Expected a location on the redirect navigation\");\n    // Check if this an absolute external redirect that goes to a new origin\n    if (ABSOLUTE_URL_REGEX.test(redirect.location) && isBrowser) {\n      let url = init.history.createURL(redirect.location);\n      let isDifferentBasename = stripBasename(url.pathname, basename) == null;\n      if (routerWindow.location.origin !== url.origin || isDifferentBasename) {\n        if (replace) {\n          routerWindow.location.replace(redirect.location);\n        } else {\n          routerWindow.location.assign(redirect.location);\n        }\n        return;\n      }\n    }\n    // There's no need to abort on redirects, since we don't detect the\n    // redirect until the action/loaders have settled\n    pendingNavigationController = null;\n    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\n    // Use the incoming submission if provided, fallback on the active one in\n    // state.navigation\n    let activeSubmission = submission || getSubmissionFromNavigation(state.navigation);\n    // If this was a 307/308 submission we want to preserve the HTTP method and\n    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n    // redirected location\n    if (redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        submission: _extends({}, activeSubmission, {\n          formAction: redirect.location\n        }),\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    } else if (isFetchActionRedirect) {\n      // For a fetch action redirect, we kick off a new loading navigation\n      // without the fetcher submission, but we send it along for shouldRevalidate\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation: getLoadingNavigation(redirectLocation),\n        fetcherSubmission: activeSubmission,\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    } else {\n      // If we have a submission, we will preserve it through the redirect navigation\n      let overrideNavigation = getLoadingNavigation(redirectLocation, activeSubmission);\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation,\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    }\n  }\n  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n    // Call all navigation loaders and revalidating fetcher loaders in parallel,\n    // then slice off the results into separate arrays so we can handle them\n    // accordingly\n    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename)), ...fetchersToLoad.map(f => {\n      if (f.matches && f.match && f.controller) {\n        return callLoaderOrAction(\"loader\", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties, basename);\n      } else {\n        let error = {\n          type: ResultType.error,\n          error: getInternalRouterError(404, {\n            pathname: f.path\n          })\n        };\n        return error;\n      }\n    })]);\n    let loaderResults = results.slice(0, matchesToLoad.length);\n    let fetcherResults = results.slice(matchesToLoad.length);\n    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(f => f.match), fetcherResults, fetchersToLoad.map(f => f.controller ? f.controller.signal : null), true)]);\n    return {\n      results,\n      loaderResults,\n      fetcherResults\n    };\n  }\n  function interruptActiveLoads() {\n    // Every interruption triggers a revalidation\n    isRevalidationRequired = true;\n    // Cancel pending route-level deferreds and mark cancelled routes for\n    // revalidation\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n    // Abort in-flight fetcher loads\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n  function setFetcherError(key, routeId, error) {\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState({\n      errors: {\n        [boundaryMatch.route.id]: error\n      },\n      fetchers: new Map(state.fetchers)\n    });\n  }\n  function deleteFetcher(key) {\n    let fetcher = state.fetchers.get(key);\n    // Don't abort the controller if this is a deletion of a fetcher.submit()\n    // in it's loading phase since - we don't want to abort the corresponding\n    // revalidation and want them to complete and land\n    if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    state.fetchers.delete(key);\n  }\n  function abortFetcher(key) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, \"Expected fetch controller: \" + key);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n  function markFetchersDone(keys) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  function markFetchRedirectsDone() {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, \"Expected fetcher: \" + key);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n  function abortStaleFetchLoads(landedId) {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, \"Expected fetcher: \" + key);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n  function getBlocker(key, fn) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n    return blocker;\n  }\n  function deleteBlocker(key) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n  // Utility function to update blockers, ensuring valid state transitions\n  function updateBlocker(key, newBlocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    // Poor mans state machine :)\n    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n    invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({\n      blockers\n    });\n  }\n  function shouldBlockNavigation(_ref2) {\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = _ref2;\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n    // We ony support a single active blocker at the moment since we don't have\n    // any compelling use cases for multi-blocker yet\n    if (blockerFunctions.size > 1) {\n      warning(false, \"A router only supports one blocker at a time\");\n    }\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n    if (blocker && blocker.state === \"proceeding\") {\n      // If the blocker is currently proceeding, we don't need to re-check\n      // it and can let this navigation continue\n      return;\n    }\n    // At this point, we know we're unblocked/blocked so we need to check the\n    // user-provided blocker function\n    if (blockerFunction({\n      currentLocation,\n      nextLocation,\n      historyAction\n    })) {\n      return blockerKey;\n    }\n  }\n  function cancelActiveDeferreds(predicate) {\n    let cancelledRouteIds = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        // Cancel the deferred - but do not remove from activeDeferreds here -\n        // we rely on the subscribers to do that so our tests can assert proper\n        // cleanup via _internalActiveDeferreds\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n  // Opt in to capturing and reporting scroll positions during navigations,\n  // used by the <ScrollRestoration> component\n  function enableScrollRestoration(positions, getPosition, getKey) {\n    savedScrollPositions = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || null;\n    // Perform initial hydration scroll restoration, since we miss the boat on\n    // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n    // and therefore have no savedScrollPositions available\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({\n          restoreScrollPosition: y\n        });\n      }\n    }\n    return () => {\n      savedScrollPositions = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n  function getScrollKey(location, matches) {\n    if (getScrollRestorationKey) {\n      let key = getScrollRestorationKey(location, matches.map(m => createUseMatchesMatch(m, state.loaderData)));\n      return key || location.key;\n    }\n    return location.key;\n  }\n  function saveScrollPosition(location, matches) {\n    if (savedScrollPositions && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions[key] = getScrollPosition();\n    }\n  }\n  function getSavedScrollPosition(location, matches) {\n    if (savedScrollPositions) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n  function _internalSetRoutes(newRoutes) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);\n  }\n  router = {\n    get basename() {\n      return basename;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: to => init.history.createHref(to),\n    encodeLocation: to => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes\n  };\n  return router;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nconst UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\nfunction createStaticHandler(routes, opts) {\n  invariant(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\n  let manifest = {};\n  let basename = (opts ? opts.basename : null) || \"/\";\n  let mapRouteProperties;\n  if (opts != null && opts.mapRouteProperties) {\n    mapRouteProperties = opts.mapRouteProperties;\n  } else if (opts != null && opts.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = opts.detectErrorBoundary;\n    mapRouteProperties = route => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);\n  /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */\n  async function query(request, _temp2) {\n    let {\n      requestContext\n    } = _temp2 === void 0 ? {} : _temp2;\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\") {\n      let error = getInternalRouterError(405, {\n        method\n      });\n      let {\n        matches: methodNotAllowedMatches,\n        route\n      } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    } else if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    let result = await queryImpl(request, location, matches, requestContext);\n    if (isResponse(result)) {\n      return result;\n    }\n    // When returning StaticHandlerContext, we patch back in the location here\n    // since we need it for React Context.  But this helps keep our submit and\n    // loadRouteData operating on a Request instead of a Location\n    return _extends({\n      location,\n      basename\n    }, result);\n  }\n  /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */\n  async function queryRoute(request, _temp3) {\n    let {\n      routeId,\n      requestContext\n    } = _temp3 === void 0 ? {} : _temp3;\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n      throw getInternalRouterError(405, {\n        method\n      });\n    } else if (!matches) {\n      throw getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n    }\n    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);\n    if (routeId && !match) {\n      throw getInternalRouterError(403, {\n        pathname: location.pathname,\n        routeId\n      });\n    } else if (!match) {\n      // This should never hit I don't think?\n      throw getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n    }\n    let result = await queryImpl(request, location, matches, requestContext, match);\n    if (isResponse(result)) {\n      return result;\n    }\n    let error = result.errors ? Object.values(result.errors)[0] : undefined;\n    if (error !== undefined) {\n      // If we got back result.errors, that means the loader/action threw\n      // _something_ that wasn't a Response, but it's not guaranteed/required\n      // to be an `instanceof Error` either, so we have to use throw here to\n      // preserve the \"error\" state outside of queryImpl.\n      throw error;\n    }\n    // Pick off the right state value to return\n    if (result.actionData) {\n      return Object.values(result.actionData)[0];\n    }\n    if (result.loaderData) {\n      var _result$activeDeferre;\n      let data = Object.values(result.loaderData)[0];\n      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {\n        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n      }\n      return data;\n    }\n    return undefined;\n  }\n  async function queryImpl(request, location, matches, requestContext, routeMatch) {\n    invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n    try {\n      if (isMutationMethod(request.method.toLowerCase())) {\n        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);\n        return result;\n      }\n      let result = await loadRouteData(request, matches, requestContext, routeMatch);\n      return isResponse(result) ? result : _extends({}, result, {\n        actionData: null,\n        actionHeaders: {}\n      });\n    } catch (e) {\n      // If the user threw/returned a Response in callLoaderOrAction, we throw\n      // it to bail out and then return or throw here based on whether the user\n      // returned or threw\n      if (isQueryRouteResponse(e)) {\n        if (e.type === ResultType.error && !isRedirectResponse(e.response)) {\n          throw e.response;\n        }\n        return e.response;\n      }\n      // Redirects are always returned since they don't propagate to catch\n      // boundaries\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n  async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {\n    let result;\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: actionMatch.route.id\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error\n      };\n    } else {\n      result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename, {\n        isStaticRequest: true,\n        isRouteRequest,\n        requestContext\n      });\n      if (request.signal.aborted) {\n        let method = isRouteRequest ? \"queryRoute\" : \"query\";\n        throw new Error(method + \"() call aborted\");\n      }\n    }\n    if (isRedirectResult(result)) {\n      // Uhhhh - this should never happen, we should always throw these from\n      // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n      // can get back on the \"throw all redirect responses\" train here should\n      // this ever happen :/\n      throw new Response(null, {\n        status: result.status,\n        headers: {\n          Location: result.location\n        }\n      });\n    }\n    if (isDeferredResult(result)) {\n      let error = getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error\n      };\n    }\n    if (isRouteRequest) {\n      // Note: This should only be non-Response values if we get here, since\n      // isRouteRequest should throw any Response received in callLoaderOrAction\n      if (isErrorResult(result)) {\n        throw result.error;\n      }\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: {\n          [actionMatch.route.id]: result.data\n        },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      let context = await loadRouteData(request, matches, requestContext, undefined, {\n        [boundaryMatch.route.id]: result.error\n      });\n      // action status codes take precedence over loader status codes\n      return _extends({}, context, {\n        statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,\n        actionData: null,\n        actionHeaders: _extends({}, result.headers ? {\n          [actionMatch.route.id]: result.headers\n        } : {})\n      });\n    }\n    // Create a GET request for the loaders\n    let loaderRequest = new Request(request.url, {\n      headers: request.headers,\n      redirect: request.redirect,\n      signal: request.signal\n    });\n    let context = await loadRouteData(loaderRequest, matches, requestContext);\n    return _extends({}, context, result.statusCode ? {\n      statusCode: result.statusCode\n    } : {}, {\n      actionData: {\n        [actionMatch.route.id]: result.data\n      },\n      actionHeaders: _extends({}, result.headers ? {\n        [actionMatch.route.id]: result.headers\n      } : {})\n    });\n  }\n  async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {\n    let isRouteRequest = routeMatch != null;\n    // Short circuit if we have no loaders to run (queryRoute())\n    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {\n      throw getInternalRouterError(400, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: routeMatch == null ? void 0 : routeMatch.route.id\n      });\n    }\n    let requestMatches = routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);\n    let matchesToLoad = requestMatches.filter(m => m.route.loader || m.route.lazy);\n    // Short circuit if we have no loaders to run (query())\n    if (matchesToLoad.length === 0) {\n      return {\n        matches,\n        // Add a null for all matched routes for proper revalidation on the client\n        loaderData: matches.reduce((acc, m) => Object.assign(acc, {\n          [m.route.id]: null\n        }), {}),\n        errors: pendingActionError || null,\n        statusCode: 200,\n        loaderHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename, {\n      isStaticRequest: true,\n      isRouteRequest,\n      requestContext\n    }))]);\n    if (request.signal.aborted) {\n      let method = isRouteRequest ? \"queryRoute\" : \"query\";\n      throw new Error(method + \"() call aborted\");\n    }\n    // Process and commit output from loaders\n    let activeDeferreds = new Map();\n    let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds);\n    // Add a null for any non-loader matches for proper revalidation on the client\n    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));\n    matches.forEach(match => {\n      if (!executedLoaders.has(match.route.id)) {\n        context.loaderData[match.route.id] = null;\n      }\n    });\n    return _extends({}, context, {\n      matches,\n      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\n    });\n  }\n  return {\n    dataRoutes,\n    query,\n    queryRoute\n  };\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */\nfunction getStaticContextFromError(routes, context, error) {\n  let newContext = _extends({}, context, {\n    statusCode: 500,\n    errors: {\n      [context._deepestRenderedBoundaryId || routes[0].id]: error\n    }\n  });\n  return newContext;\n}\nfunction isSubmissionNavigation(opts) {\n  return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== undefined);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, fromRouteId, relative) {\n  let contextualMatches;\n  let activeRouteMatch;\n  if (fromRouteId != null && relative !== \"path\") {\n    // Grab matches up to the calling route so our route-relative logic is\n    // relative to the correct source route.  When using relative:path,\n    // fromRouteId is ignored since that is always relative to the current\n    // location path\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n  // Resolve the relative path\n  let path = resolveTo(to ? to : \".\", getPathContributingMatches(contextualMatches).map(m => m.pathnameBase), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n  // When `to` is not specified we inherit search/hash from the current\n  // location, unlike when to=\".\" and we just inherit the path.\n  // See https://github.com/remix-run/remix/issues/927\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n  // Add an ?index param for matched index routes if we don't already have one\n  if ((to == null || to === \"\" || to === \".\") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  // If we're operating within a basename, prepend it to the pathname.  If\n  // this is a root navigation, then just use the raw basename which allows\n  // the basename to have full control over the presence of a trailing slash\n  // on root actions\n  if (prependBasename && basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n  // Return location verbatim on non-submission navigations\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return {\n      path\n    };\n  }\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, {\n        method: opts.formMethod\n      })\n    };\n  }\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, {\n      type: \"invalid-body\"\n    })\n  });\n  // Create a Submission on non-GET navigations\n  let rawFormMethod = opts.formMethod || \"get\";\n  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n  let formAction = stripHashFromPath(path);\n  if (opts.body !== undefined) {\n    if (opts.formEncType === \"text/plain\") {\n      // text only support POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ?\n      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n      Array.from(opts.body.entries()).reduce((acc, _ref3) => {\n        let [name, value] = _ref3;\n        return \"\" + acc + name + \"=\" + value + \"\\n\";\n      }, \"\") : String(opts.body);\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: undefined,\n          json: undefined,\n          text\n        }\n      };\n    } else if (opts.formEncType === \"application/json\") {\n      // json only supports POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      try {\n        let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: undefined,\n            json,\n            text: undefined\n          }\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n  invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n  let searchParams;\n  let formData;\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n  let submission = {\n    formMethod,\n    formAction,\n    formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n    formData,\n    json: undefined,\n    text: undefined\n  };\n  if (isMutationMethod(submission.formMethod)) {\n    return {\n      path,\n      submission\n    };\n  }\n  // Flatten submission onto URLSearchParams for GET submissions\n  let parsedPath = parsePath(path);\n  // On GET navigation submissions we can drop the ?index param from the\n  // resulting location since all loaders will run.  But fetcher GET submissions\n  // only run a single loader so we need to preserve any incoming ?index params\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append(\"index\", \"\");\n  }\n  parsedPath.search = \"?\" + searchParams;\n  return {\n    path: createPath(parsedPath),\n    submission\n  };\n}\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n  let boundaryMatches = matches;\n  if (boundaryId) {\n    let index = matches.findIndex(m => m.route.id === boundaryId);\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\n  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n  // Pick navigation matches that are net-new or qualify for revalidation\n  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n  let navigationMatches = boundaryMatches.filter((match, index) => {\n    if (match.route.lazy) {\n      // We haven't loaded this route yet so we don't know if it's got a loader!\n      return true;\n    }\n    if (match.route.loader == null) {\n      return false;\n    }\n    // Always call the loader on new route instances and pending defer cancellations\n    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {\n      return true;\n    }\n    // This is the default implementation for when we revalidate.  If the route\n    // provides it's own implementation, then we give them full control but\n    // provide this value so they can leverage it if needed after they check\n    // their own specific use cases\n    let currentRouteMatch = state.matches[index];\n    let nextRouteMatch = match;\n    return shouldRevalidateLoader(match, _extends({\n      currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl,\n      nextParams: nextRouteMatch.params\n    }, submission, {\n      actionResult,\n      defaultShouldRevalidate:\n      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n      isRevalidationRequired ||\n      // Clicked the same link, resubmitted a GET form\n      currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search ||\n      // Search params affect all loaders\n      currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n    }));\n  });\n  // Pick fetcher.loads that need to be revalidated\n  let revalidatingFetchers = [];\n  fetchLoadMatches.forEach((f, key) => {\n    // Don't revalidate if fetcher won't be present in the subsequent render\n    if (!matches.some(m => m.route.id === f.routeId)) {\n      return;\n    }\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n    // If the fetcher path no longer matches, push it in with null matches so\n    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n    // currently only a use-case for Remix HMR where the route tree can change\n    // at runtime and remove a route previously loaded via a fetcher\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null\n      });\n      return;\n    }\n    // Revalidating fetchers are decoupled from the route matches since they\n    // load from a static href.  They revalidate based on explicit revalidation\n    // (submission, useRevalidator, or X-Remix-Revalidate)\n    let fetcher = state.fetchers.get(key);\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n    let shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      // Never trigger a revalidation of an actively redirecting fetcher\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.includes(key)) {\n      // Always revalidate if the fetcher was cancelled\n      shouldRevalidate = true;\n    } else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === undefined) {\n      // If the fetcher hasn't ever completed loading yet, then this isn't a\n      // revalidation, it would just be a brand new load if an explicit\n      // revalidation is required\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n      // to explicit revalidations only\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n        currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl,\n        nextParams: matches[matches.length - 1].params\n      }, submission, {\n        actionResult,\n        defaultShouldRevalidate: isRevalidationRequired\n      }));\n    }\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController()\n      });\n    }\n  });\n  return [navigationMatches, revalidatingFetchers];\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n  let isNew =\n  // [a] -> [a, b]\n  !currentMatch ||\n  // [a, b] -> [a, c]\n  match.route.id !== currentMatch.route.id;\n  // Handle the case that we don't have data for a re-used route, potentially\n  // from a prior error or from a cancelled pending deferred\n  let isMissingData = currentLoaderData[match.route.id] === undefined;\n  // Always load if this is a net-new route or we don't yet have data\n  return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname ||\n    // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]\n  );\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n  return arg.defaultShouldRevalidate;\n}\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */\nasync function loadLazyRouteModule(route, mapRouteProperties, manifest) {\n  if (!route.lazy) {\n    return;\n  }\n  let lazyRoute = await route.lazy();\n  // If the lazy route function was executed and removed by another parallel\n  // call then we can return - first lazy() to finish wins because the return\n  // value of lazy is expected to be static\n  if (!route.lazy) {\n    return;\n  }\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n  // Update the route in place.  This should be safe because there's no way\n  // we could yet be sitting on this route as we can't get there without\n  // resolving lazy() first.\n  //\n  // This is different than the HMR \"update\" use-case where we may actively be\n  // on the route being updated.  The main concern boils down to \"does this\n  // mutation affect any ongoing navigations or any current state.matches\n  // values?\".  If not, it should be safe to update in place.\n  let routeUpdates = {};\n  for (let lazyRouteProperty in lazyRoute) {\n    let staticRouteValue = routeToUpdate[lazyRouteProperty];\n    let isPropertyStaticallyDefined = staticRouteValue !== undefined &&\n    // This property isn't static since it should always be updated based\n    // on the route updates\n    lazyRouteProperty !== \"hasErrorBoundary\";\n    warning(!isPropertyStaticallyDefined, \"Route \\\"\" + routeToUpdate.id + \"\\\" has a static property \\\"\" + lazyRouteProperty + \"\\\" \" + \"defined but its lazy function is also returning a value for this property. \" + (\"The lazy route property \\\"\" + lazyRouteProperty + \"\\\" will be ignored.\"));\n    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n    }\n  }\n  // Mutate the route with the provided updates.  Do this first so we pass\n  // the updated version to mapRouteProperties\n  Object.assign(routeToUpdate, routeUpdates);\n  // Mutate the `hasErrorBoundary` property on the route based on the route\n  // updates and remove the `lazy` function so we don't resolve the lazy\n  // route again.\n  Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {\n    lazy: undefined\n  }));\n}\nasync function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  let resultType;\n  let result;\n  let onReject;\n  let runHandler = handler => {\n    // Setup a promise we can race against so that abort signals short circuit\n    let reject;\n    let abortPromise = new Promise((_, r) => reject = r);\n    onReject = () => reject();\n    request.signal.addEventListener(\"abort\", onReject);\n    return Promise.race([handler({\n      request,\n      params: match.params,\n      context: opts.requestContext\n    }), abortPromise]);\n  };\n  try {\n    let handler = match.route[type];\n    if (match.route.lazy) {\n      if (handler) {\n        // Run statically defined handler in parallel with lazy()\n        let values = await Promise.all([runHandler(handler), loadLazyRouteModule(match.route, mapRouteProperties, manifest)]);\n        result = values[0];\n      } else {\n        // Load lazy route module, then run any returned handler\n        await loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n        handler = match.route[type];\n        if (handler) {\n          // Handler still run even if we got interrupted to maintain consistency\n          // with un-abortable behavior of handler execution on non-lazy or\n          // previously-lazy-loaded routes\n          result = await runHandler(handler);\n        } else if (type === \"action\") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id\n          });\n        } else {\n          // lazy() route has no loader to run.  Short circuit here so we don't\n          // hit the invariant below that errors on returning undefined.\n          return {\n            type: ResultType.data,\n            data: undefined\n          };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n    invariant(result !== undefined, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + (\"\\\"\" + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\n  } catch (e) {\n    resultType = ResultType.error;\n    result = e;\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener(\"abort\", onReject);\n    }\n  }\n  if (isResponse(result)) {\n    let status = result.status;\n    // Process redirects\n    if (redirectStatusCodes.has(status)) {\n      let location = result.headers.get(\"Location\");\n      invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n      // Support relative routing in internal redirects\n      if (!ABSOLUTE_URL_REGEX.test(location)) {\n        location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location);\n      } else if (!opts.isStaticRequest) {\n        // Strip off the protocol+origin for same-origin + same-basename absolute\n        // redirects. If this is a static request, we can let it go back to the\n        // browser as-is\n        let currentUrl = new URL(request.url);\n        let url = location.startsWith(\"//\") ? new URL(currentUrl.protocol + location) : new URL(location);\n        let isSameBasename = stripBasename(url.pathname, basename) != null;\n        if (url.origin === currentUrl.origin && isSameBasename) {\n          location = url.pathname + url.search + url.hash;\n        }\n      }\n      // Don't process redirects in the router during static requests requests.\n      // Instead, throw the Response and let the server handle it with an HTTP\n      // redirect.  We also update the Location header in place in this flow so\n      // basename and relative routing is taken into account\n      if (opts.isStaticRequest) {\n        result.headers.set(\"Location\", location);\n        throw result;\n      }\n      return {\n        type: ResultType.redirect,\n        status,\n        location,\n        revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null\n      };\n    }\n    // For SSR single-route requests, we want to hand Responses back directly\n    // without unwrapping.  We do this with the QueryRouteResponse wrapper\n    // interface so we can know whether it was returned or thrown\n    if (opts.isRouteRequest) {\n      // eslint-disable-next-line no-throw-literal\n      throw {\n        type: resultType || ResultType.data,\n        response: result\n      };\n    }\n    let data;\n    let contentType = result.headers.get(\"Content-Type\");\n    // Check between word boundaries instead of startsWith() due to the last\n    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      data = await result.json();\n    } else {\n      data = await result.text();\n    }\n    if (resultType === ResultType.error) {\n      return {\n        type: resultType,\n        error: new ErrorResponse(status, result.statusText, data),\n        headers: result.headers\n      };\n    }\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers\n    };\n  }\n  if (resultType === ResultType.error) {\n    return {\n      type: resultType,\n      error: result\n    };\n  }\n  if (isDeferredData(result)) {\n    var _result$init, _result$init2;\n    return {\n      type: ResultType.deferred,\n      deferredData: result,\n      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n    };\n  }\n  return {\n    type: ResultType.data,\n    data: result\n  };\n}\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(history, location, signal, submission) {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init = {\n    signal\n  };\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let {\n      formMethod,\n      formEncType\n    } = submission;\n    // Didn't think we needed this but it turns out unlike other methods, patch\n    // won't be properly normalized to uppercase and results in a 405 error.\n    // See: https://fetch.spec.whatwg.org/#concept-method\n    init.method = formMethod.toUpperCase();\n    if (formEncType === \"application/json\") {\n      init.headers = new Headers({\n        \"Content-Type\": formEncType\n      });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === \"text/plain\") {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.text;\n    } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.formData;\n    }\n  }\n  return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n  let searchParams = new URLSearchParams();\n  for (let [key, value] of formData.entries()) {\n    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n  }\n  return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n  // Fill in loaderData/errors from our loaders\n  let loaderData = {};\n  let errors = null;\n  let statusCode;\n  let foundError = false;\n  let loaderHeaders = {};\n  // Process loader results into state.loaderData/state.errors\n  results.forEach((result, index) => {\n    let id = matchesToLoad[index].route.id;\n    invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n    if (isErrorResult(result)) {\n      // Look upwards from the matched route for the closest ancestor\n      // error boundary, defaulting to the root match\n      let boundaryMatch = findNearestBoundary(matches, id);\n      let error = result.error;\n      // If we have a pending action error, we report it at the highest-route\n      // that throws a loader error, and then clear it out to indicate that\n      // it was consumed\n      if (pendingError) {\n        error = Object.values(pendingError)[0];\n        pendingError = undefined;\n      }\n      errors = errors || {};\n      // Prefer higher error values if lower errors bubble to the same boundary\n      if (errors[boundaryMatch.route.id] == null) {\n        errors[boundaryMatch.route.id] = error;\n      }\n      // Clear our any prior loaderData for the throwing route\n      loaderData[id] = undefined;\n      // Once we find our first (highest) error, we set the status code and\n      // prevent deeper status codes from overriding\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      if (isDeferredResult(result)) {\n        activeDeferreds.set(id, result.deferredData);\n        loaderData[id] = result.deferredData.data;\n      } else {\n        loaderData[id] = result.data;\n      }\n      // Error status codes always override success status codes, but if all\n      // loaders are successful we take the deepest status code.\n      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n  // If we didn't consume the pending action error (i.e., all loaders\n  // resolved), then consume it here.  Also clear out any loaderData for the\n  // throwing route\n  if (pendingError) {\n    errors = pendingError;\n    loaderData[Object.keys(pendingError)[0]] = undefined;\n  }\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders\n  };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n  let {\n    loaderData,\n    errors\n  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);\n  // Process results from our revalidating fetchers\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let {\n      key,\n      match,\n      controller\n    } = revalidatingFetchers[index];\n    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, \"Did not find corresponding fetcher result\");\n    let result = fetcherResults[index];\n    // Process fetcher non-redirect errors\n    if (controller && controller.signal.aborted) {\n      // Nothing to do for aborted fetchers\n      continue;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = _extends({}, errors, {\n          [boundaryMatch.route.id]: result.error\n        });\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      // Should never get here, redirects should get processed above, but we\n      // keep this to type narrow to a success result in the else\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\n    } else if (isDeferredResult(result)) {\n      // Should never get here, deferred data should be awaited for fetchers\n      // in resolveDeferredResults\n      invariant(false, \"Unhandled fetcher deferred data\");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  return {\n    loaderData,\n    errors\n  };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n  let mergedLoaderData = _extends({}, newLoaderData);\n  for (let match of matches) {\n    let id = match.route.id;\n    if (newLoaderData.hasOwnProperty(id)) {\n      if (newLoaderData[id] !== undefined) {\n        mergedLoaderData[id] = newLoaderData[id];\n      }\n    } else if (loaderData[id] !== undefined && match.route.loader) {\n      // Preserve existing keys not included in newLoaderData and where a loader\n      // wasn't removed by HMR\n      mergedLoaderData[id] = loaderData[id];\n    }\n    if (errors && errors.hasOwnProperty(id)) {\n      // Don't keep any loader data below the boundary\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches, routeId) {\n  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];\n  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n  // Prefer a root layout route if present, otherwise shim in a route object\n  let route = routes.find(r => r.index || !r.path || r.path === \"/\") || {\n    id: \"__shim-error-route__\"\n  };\n  return {\n    matches: [{\n      params: {},\n      pathname: \"\",\n      pathnameBase: \"\",\n      route\n    }],\n    route\n  };\n}\nfunction getInternalRouterError(status, _temp4) {\n  let {\n    pathname,\n    routeId,\n    method,\n    type\n  } = _temp4 === void 0 ? {} : _temp4;\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide a `loader` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\n    } else if (type === \"defer-action\") {\n      errorMessage = \"defer() is not supported in actions\";\n    } else if (type === \"invalid-body\") {\n      errorMessage = \"Unable to encode submission body\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = \"Route \\\"\" + routeId + \"\\\" does not match URL \\\"\" + pathname + \"\\\"\";\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = \"No route matches URL \\\"\" + pathname + \"\\\"\";\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method.toUpperCase() + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide an `action` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\n    } else if (method) {\n      errorMessage = \"Invalid request method \\\"\" + method.toUpperCase() + \"\\\"\";\n    }\n  }\n  return new ErrorResponse(status || 500, statusText, new Error(errorMessage), true);\n}\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results) {\n  for (let i = results.length - 1; i >= 0; i--) {\n    let result = results[i];\n    if (isRedirectResult(result)) {\n      return {\n        result,\n        idx: i\n      };\n    }\n  }\n}\nfunction stripHashFromPath(path) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath(_extends({}, parsedPath, {\n    hash: \"\"\n  }));\n}\nfunction isHashChangeOnly(a, b) {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n  if (a.hash === \"\") {\n    // /page -> /page#hash\n    return b.hash !== \"\";\n  } else if (a.hash === b.hash) {\n    // /page#hash -> /page#hash\n    return true;\n  } else if (b.hash !== \"\") {\n    // /page#hash -> /page#other\n    return true;\n  }\n  // If the hash is removed the browser will re-perform a request to the server\n  // /page#hash -> /page\n  return false;\n}\nfunction isDeferredResult(result) {\n  return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n  return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n  return (result && result.type) === ResultType.redirect;\n}\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectResponse(result) {\n  if (!isResponse(result)) {\n    return false;\n  }\n  let status = result.status;\n  let location = result.headers.get(\"Location\");\n  return status >= 300 && status <= 399 && location != null;\n}\nfunction isQueryRouteResponse(obj) {\n  return obj && isResponse(obj.response) && (obj.type === ResultType.data || ResultType.error);\n}\nfunction isValidMethod(method) {\n  return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n  return validMutationMethods.has(method.toLowerCase());\n}\nasync function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n  for (let index = 0; index < results.length; index++) {\n    let result = results[index];\n    let match = matchesToLoad[index];\n    // If we don't have a match, then we can have a deferred result to do\n    // anything with.  This is for revalidating fetchers where the route was\n    // removed during HMR\n    if (!match) {\n      continue;\n    }\n    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);\n    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n      // Note: we do not have to touch activeDeferreds here since we race them\n      // against the signal in resolveDeferredData and they'll get aborted\n      // there if needed\n      let signal = signals[index];\n      invariant(signal, \"Expected an AbortSignal for revalidating fetcher deferred result\");\n      await resolveDeferredData(result, signal, isFetcher).then(result => {\n        if (result) {\n          results[index] = result || results[index];\n        }\n      });\n    }\n  }\n}\nasync function resolveDeferredData(result, signal, unwrap) {\n  if (unwrap === void 0) {\n    unwrap = false;\n  }\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData\n      };\n    } catch (e) {\n      // Handle any TrackedPromise._error values encountered while unwrapping\n      return {\n        type: ResultType.error,\n        error: e\n      };\n    }\n  }\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data\n  };\n}\nfunction hasNakedIndexQuery(search) {\n  return new URLSearchParams(search).getAll(\"index\").some(v => v === \"\");\n}\n// Note: This should match the format exported by useMatches, so if you change\n// this please also change that :)  Eventually we'll DRY this up\nfunction createUseMatchesMatch(match, loaderData) {\n  let {\n    route,\n    pathname,\n    params\n  } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    handle: route.handle\n  };\n}\nfunction getTargetMatch(matches, location) {\n  let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n    // Return the leaf index route when index is present\n    return matches[matches.length - 1];\n  }\n  // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n  // pathless layout routes)\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n  let {\n    formMethod,\n    formAction,\n    formEncType,\n    text,\n    formData,\n    json\n  } = navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json: undefined,\n      text\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: undefined,\n      text: undefined\n    };\n  } else if (json !== undefined) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json,\n      text: undefined\n    };\n  }\n}\nfunction getLoadingNavigation(location, submission) {\n  if (submission) {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text\n    };\n    return navigation;\n  } else {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined\n    };\n    return navigation;\n  }\n}\nfunction getSubmittingNavigation(location, submission) {\n  let navigation = {\n    state: \"submitting\",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text\n  };\n  return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n  if (submission) {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data,\n      \" _hasFetcherDoneAnything \": true\n    };\n    return fetcher;\n  } else {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n      data,\n      \" _hasFetcherDoneAnything \": true\n    };\n    return fetcher;\n  }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n  let fetcher = {\n    state: \"submitting\",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : undefined,\n    \" _hasFetcherDoneAnything \": true\n  };\n  return fetcher;\n}\nfunction getDoneFetcher(data) {\n  let fetcher = {\n    state: \"idle\",\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined,\n    data,\n    \" _hasFetcherDoneAnything \": true\n  };\n  return fetcher;\n}\n//#endregion\n\nexport { AbortedDeferredError, Action, ErrorResponse, IDLE_BLOCKER, IDLE_FETCHER, IDLE_NAVIGATION, UNSAFE_DEFERRED_SYMBOL, DeferredData as UNSAFE_DeferredData, convertRoutesToDataRoutes as UNSAFE_convertRoutesToDataRoutes, getPathContributingMatches as UNSAFE_getPathContributingMatches, invariant as UNSAFE_invariant, warning as UNSAFE_warning, createBrowserHistory, createHashHistory, createMemoryHistory, createPath, createRouter, createStaticHandler, defer, generatePath, getStaticContextFromError, getToPathname, isDeferredData, isRouteErrorResponse, joinPaths, json, matchPath, matchRoutes, normalizePathname, parsePath, redirect, resolvePath, resolveTo, stripBasename };\n//# sourceMappingURL=router.js.map\n","////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Actions represent the type of change to a location value.\n */\nexport enum Action {\n  /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */\n  Pop = \"POP\",\n\n  /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */\n  Push = \"PUSH\",\n\n  /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */\n  Replace = \"REPLACE\",\n}\n\n/**\n * The pathname, search, and hash values of a URL.\n */\nexport interface Path {\n  /**\n   * A URL pathname, beginning with a /.\n   */\n  pathname: string;\n\n  /**\n   * A URL search string, beginning with a ?.\n   */\n  search: string;\n\n  /**\n   * A URL fragment identifier, beginning with a #.\n   */\n  hash: string;\n}\n\n/**\n * An entry in a history stack. A location contains information about the\n * URL path, as well as possibly some arbitrary state and a key.\n */\nexport interface Location extends Path {\n  /**\n   * A value of arbitrary data associated with this location.\n   */\n  state: any;\n\n  /**\n   * A unique string associated with this location. May be used to safely store\n   * and retrieve data in some other storage API, like `localStorage`.\n   *\n   * Note: This value is always \"default\" on the initial location.\n   */\n  key: string;\n}\n\n/**\n * A change to the current location.\n */\nexport interface Update {\n  /**\n   * The action that triggered the change.\n   */\n  action: Action;\n\n  /**\n   * The new location.\n   */\n  location: Location;\n\n  /**\n   * The delta between this location and the former location in the history stack\n   */\n  delta: number | null;\n}\n\n/**\n * A function that receives notifications about location changes.\n */\nexport interface Listener {\n  (update: Update): void;\n}\n\n/**\n * Describes a location that is the destination of some navigation, either via\n * `history.push` or `history.replace`. May be either a URL or the pieces of a\n * URL path.\n */\nexport type To = string | Partial<Path>;\n\n/**\n * A history is an interface to the navigation stack. The history serves as the\n * source of truth for the current location, as well as provides a set of\n * methods that may be used to change it.\n *\n * It is similar to the DOM's `window.history` object, but with a smaller, more\n * focused API.\n */\nexport interface History {\n  /**\n   * The last action that modified the current location. This will always be\n   * Action.Pop when a history instance is first created. This value is mutable.\n   */\n  readonly action: Action;\n\n  /**\n   * The current location. This value is mutable.\n   */\n  readonly location: Location;\n\n  /**\n   * Returns a valid href for the given `to` value that may be used as\n   * the value of an <a href> attribute.\n   *\n   * @param to - The destination URL\n   */\n  createHref(to: To): string;\n\n  /**\n   * Returns a URL for the given `to` value\n   *\n   * @param to - The destination URL\n   */\n  createURL(to: To): URL;\n\n  /**\n   * Encode a location the same way window.history would do (no-op for memory\n   * history) so we ensure our PUSH/REPLACE navigations for data routers\n   * behave the same as POP\n   *\n   * @param to Unencoded path\n   */\n  encodeLocation(to: To): Path;\n\n  /**\n   * Pushes a new location onto the history stack, increasing its length by one.\n   * If there were any entries in the stack after the current one, they are\n   * lost.\n   *\n   * @param to - The new URL\n   * @param state - Data to associate with the new location\n   */\n  push(to: To, state?: any): void;\n\n  /**\n   * Replaces the current location in the history stack with a new one.  The\n   * location that was replaced will no longer be available.\n   *\n   * @param to - The new URL\n   * @param state - Data to associate with the new location\n   */\n  replace(to: To, state?: any): void;\n\n  /**\n   * Navigates `n` entries backward/forward in the history stack relative to the\n   * current index. For example, a \"back\" navigation would use go(-1).\n   *\n   * @param delta - The delta in the stack index\n   */\n  go(delta: number): void;\n\n  /**\n   * Sets up a listener that will be called whenever the current location\n   * changes.\n   *\n   * @param listener - A function that will be called when the location changes\n   * @returns unlisten - A function that may be used to stop listening\n   */\n  listen(listener: Listener): () => void;\n}\n\ntype HistoryState = {\n  usr: any;\n  key?: string;\n  idx: number;\n};\n\nconst PopStateEventType = \"popstate\";\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Memory History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A user-supplied object that describes a location. Used when providing\n * entries to `createMemoryHistory` via its `initialEntries` option.\n */\nexport type InitialEntry = string | Partial<Location>;\n\nexport type MemoryHistoryOptions = {\n  initialEntries?: InitialEntry[];\n  initialIndex?: number;\n  v5Compat?: boolean;\n};\n\n/**\n * A memory history stores locations in memory. This is useful in stateful\n * environments where there is no web browser, such as node tests or React\n * Native.\n */\nexport interface MemoryHistory extends History {\n  /**\n   * The current index in the history stack.\n   */\n  readonly index: number;\n}\n\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */\nexport function createMemoryHistory(\n  options: MemoryHistoryOptions = {}\n): MemoryHistory {\n  let { initialEntries = [\"/\"], initialIndex, v5Compat = false } = options;\n  let entries: Location[]; // Declare so we can access from createMemoryLocation\n  entries = initialEntries.map((entry, index) =>\n    createMemoryLocation(\n      entry,\n      typeof entry === \"string\" ? null : entry.state,\n      index === 0 ? \"default\" : undefined\n    )\n  );\n  let index = clampIndex(\n    initialIndex == null ? entries.length - 1 : initialIndex\n  );\n  let action = Action.Pop;\n  let listener: Listener | null = null;\n\n  function clampIndex(n: number): number {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation(): Location {\n    return entries[index];\n  }\n  function createMemoryLocation(\n    to: To,\n    state: any = null,\n    key?: string\n  ): Location {\n    let location = createLocation(\n      entries ? getCurrentLocation().pathname : \"/\",\n      to,\n      state,\n      key\n    );\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in memory history: ${JSON.stringify(\n        to\n      )}`\n    );\n    return location;\n  }\n\n  function createHref(to: To) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n\n  let history: MemoryHistory = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref,\n    createURL(to) {\n      return new URL(createHref(to), \"http://localhost\");\n    },\n    encodeLocation(to: To) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\",\n      };\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation, delta: 1 });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({ action, location: nextLocation, delta: 0 });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({ action, location: nextLocation, delta });\n      }\n    },\n    listen(fn: Listener) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    },\n  };\n\n  return history;\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Browser History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A browser history stores the current location in regular URLs in a web\n * browser environment. This is the standard for most web apps and provides the\n * cleanest URLs the browser's address bar.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#browserhistory\n */\nexport interface BrowserHistory extends UrlHistory {}\n\nexport type BrowserHistoryOptions = UrlHistoryOptions;\n\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */\nexport function createBrowserHistory(\n  options: BrowserHistoryOptions = {}\n): BrowserHistory {\n  function createBrowserLocation(\n    window: Window,\n    globalHistory: Window[\"history\"]\n  ) {\n    let { pathname, search, hash } = window.location;\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      (globalHistory.state && globalHistory.state.usr) || null,\n      (globalHistory.state && globalHistory.state.key) || \"default\"\n    );\n  }\n\n  function createBrowserHref(window: Window, to: To) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n\n  return getUrlBasedHistory(\n    createBrowserLocation,\n    createBrowserHref,\n    null,\n    options\n  );\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Hash History\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A hash history stores the current location in the fragment identifier portion\n * of the URL in a web browser environment.\n *\n * This is ideal for apps that do not control the server for some reason\n * (because the fragment identifier is never sent to the server), including some\n * shared hosting environments that do not provide fine-grained controls over\n * which pages are served at which URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#hashhistory\n */\nexport interface HashHistory extends UrlHistory {}\n\nexport type HashHistoryOptions = UrlHistoryOptions;\n\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */\nexport function createHashHistory(\n  options: HashHistoryOptions = {}\n): HashHistory {\n  function createHashLocation(\n    window: Window,\n    globalHistory: Window[\"history\"]\n  ) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\",\n    } = parsePath(window.location.hash.substr(1));\n    return createLocation(\n      \"\",\n      { pathname, search, hash },\n      // state defaults to `null` because `window.history.state` does\n      (globalHistory.state && globalHistory.state.usr) || null,\n      (globalHistory.state && globalHistory.state.key) || \"default\"\n    );\n  }\n\n  function createHashHref(window: Window, to: To) {\n    let base = window.document.querySelector(\"base\");\n    let href = \"\";\n\n    if (base && base.getAttribute(\"href\")) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n\n  function validateHashLocation(location: Location, to: To) {\n    warning(\n      location.pathname.charAt(0) === \"/\",\n      `relative pathnames are not supported in hash history.push(${JSON.stringify(\n        to\n      )})`\n    );\n  }\n\n  return getUrlBasedHistory(\n    createHashLocation,\n    createHashHref,\n    validateHashLocation,\n    options\n  );\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region UTILS\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @private\n */\nexport function invariant(value: boolean, message?: string): asserts value;\nexport function invariant<T>(\n  value: T | null | undefined,\n  message?: string\n): asserts value is T;\nexport function invariant(value: any, message?: string) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\n\nexport function warning(cond: any, message: string) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n\n/**\n * For browser-based histories, we combine the state and key into an object\n */\nfunction getHistoryState(location: Location, index: number): HistoryState {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index,\n  };\n}\n\n/**\n * Creates a Location object with a unique key from the given Path\n */\nexport function createLocation(\n  current: string | Location,\n  to: To,\n  state: any = null,\n  key?: string\n): Readonly<Location> {\n  let location: Readonly<Location> = {\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\",\n    ...(typeof to === \"string\" ? parsePath(to) : to),\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: (to && (to as Location).key) || key || createKey(),\n  };\n  return location;\n}\n\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */\nexport function createPath({\n  pathname = \"/\",\n  search = \"\",\n  hash = \"\",\n}: Partial<Path>) {\n  if (search && search !== \"?\")\n    pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\")\n    pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\n\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nexport function parsePath(path: string): Partial<Path> {\n  let parsedPath: Partial<Path> = {};\n\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport interface UrlHistory extends History {}\n\nexport type UrlHistoryOptions = {\n  window?: Window;\n  v5Compat?: boolean;\n};\n\nfunction getUrlBasedHistory(\n  getLocation: (window: Window, globalHistory: Window[\"history\"]) => Location,\n  createHref: (window: Window, to: To) => string,\n  validateLocation: ((location: Location, to: To) => void) | null,\n  options: UrlHistoryOptions = {}\n): UrlHistory {\n  let { window = document.defaultView!, v5Compat = false } = options;\n  let globalHistory = window.history;\n  let action = Action.Pop;\n  let listener: Listener | null = null;\n\n  let index = getIndex()!;\n  // Index should only be null when we initialize. If not, it's because the\n  // user called history.pushState or history.replaceState directly, in which\n  // case we should log a warning as it will result in bugs.\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState({ ...globalHistory.state, idx: index }, \"\");\n  }\n\n  function getIndex(): number {\n    let state = globalHistory.state || { idx: null };\n    return state.idx;\n  }\n\n  function handlePop() {\n    action = Action.Pop;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({ action, location: history.location, delta });\n    }\n  }\n\n  function push(to: To, state?: any) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n\n    // try...catch because iOS limits us to 100 pushState calls :/\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      // If the exception is because `state` can't be serialized, let that throw\n      // outwards just like a replace call would so the dev knows the cause\n      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\n        throw error;\n      }\n      // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n      window.location.assign(url);\n    }\n\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 1 });\n    }\n  }\n\n  function replace(to: To, state?: any) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n\n    if (v5Compat && listener) {\n      listener({ action, location: history.location, delta: 0 });\n    }\n  }\n\n  function createURL(to: To): URL {\n    // window.location.origin is \"null\" (the literal string value) in Firefox\n    // under certain conditions, notably when serving from a local HTML file\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n    let base =\n      window.location.origin !== \"null\"\n        ? window.location.origin\n        : window.location.href;\n\n    let href = typeof to === \"string\" ? to : createPath(to);\n    invariant(\n      base,\n      `No window.location.(origin|href) available to create URL for href: ${href}`\n    );\n    return new URL(href, base);\n  }\n\n  let history: History = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n    listen(fn: Listener) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n\n      return () => {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      // Encode a Location the same way window.location would\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash,\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    },\n  };\n\n  return history;\n}\n\n//#endregion\n","import type { Location, Path, To } from \"./history\";\nimport { warning, invariant, parsePath } from \"./history\";\n\n/**\n * Map of routeId -> data returned from a loader/action/error\n */\nexport interface RouteData {\n  [routeId: string]: any;\n}\n\nexport enum ResultType {\n  data = \"data\",\n  deferred = \"deferred\",\n  redirect = \"redirect\",\n  error = \"error\",\n}\n\n/**\n * Successful result from a loader or action\n */\nexport interface SuccessResult {\n  type: ResultType.data;\n  data: any;\n  statusCode?: number;\n  headers?: Headers;\n}\n\n/**\n * Successful defer() result from a loader or action\n */\nexport interface DeferredResult {\n  type: ResultType.deferred;\n  deferredData: DeferredData;\n  statusCode?: number;\n  headers?: Headers;\n}\n\n/**\n * Redirect result from a loader or action\n */\nexport interface RedirectResult {\n  type: ResultType.redirect;\n  status: number;\n  location: string;\n  revalidate: boolean;\n}\n\n/**\n * Unsuccessful result from a loader or action\n */\nexport interface ErrorResult {\n  type: ResultType.error;\n  error: any;\n  headers?: Headers;\n}\n\n/**\n * Result from a loader or action - potentially successful or unsuccessful\n */\nexport type DataResult =\n  | SuccessResult\n  | DeferredResult\n  | RedirectResult\n  | ErrorResult;\n\ntype LowerCaseFormMethod = \"get\" | \"post\" | \"put\" | \"patch\" | \"delete\";\ntype UpperCaseFormMethod = Uppercase<LowerCaseFormMethod>;\n\n/**\n * Users can specify either lowercase or uppercase form methods on <Form>,\n * useSubmit(), <fetcher.Form>, etc.\n */\nexport type HTMLFormMethod = LowerCaseFormMethod | UpperCaseFormMethod;\n\n/**\n * Active navigation/fetcher form methods are exposed in lowercase on the\n * RouterState\n */\nexport type FormMethod = LowerCaseFormMethod;\nexport type MutationFormMethod = Exclude<FormMethod, \"get\">;\n\n/**\n * In v7, active navigation/fetcher form methods are exposed in uppercase on the\n * RouterState.  This is to align with the normalization done via fetch().\n */\nexport type V7_FormMethod = UpperCaseFormMethod;\nexport type V7_MutationFormMethod = Exclude<V7_FormMethod, \"GET\">;\n\nexport type FormEncType =\n  | \"application/x-www-form-urlencoded\"\n  | \"multipart/form-data\"\n  | \"application/json\"\n  | \"text/plain\";\n\n// Thanks https://github.com/sindresorhus/type-fest!\ntype JsonObject = { [Key in string]: JsonValue } & {\n  [Key in string]?: JsonValue | undefined;\n};\ntype JsonArray = JsonValue[] | readonly JsonValue[];\ntype JsonPrimitive = string | number | boolean | null;\ntype JsonValue = JsonPrimitive | JsonObject | JsonArray;\n\n/**\n * @private\n * Internal interface to pass around for action submissions, not intended for\n * external consumption\n */\nexport type Submission =\n  | {\n      formMethod: FormMethod | V7_FormMethod;\n      formAction: string;\n      formEncType: FormEncType;\n      formData: FormData;\n      json: undefined;\n      text: undefined;\n    }\n  | {\n      formMethod: FormMethod | V7_FormMethod;\n      formAction: string;\n      formEncType: FormEncType;\n      formData: undefined;\n      json: JsonValue;\n      text: undefined;\n    }\n  | {\n      formMethod: FormMethod | V7_FormMethod;\n      formAction: string;\n      formEncType: FormEncType;\n      formData: undefined;\n      json: undefined;\n      text: string;\n    };\n\n/**\n * @private\n * Arguments passed to route loader/action functions.  Same for now but we keep\n * this as a private implementation detail in case they diverge in the future.\n */\ninterface DataFunctionArgs {\n  request: Request;\n  params: Params;\n  context?: any;\n}\n\n/**\n * Arguments passed to loader functions\n */\nexport interface LoaderFunctionArgs extends DataFunctionArgs {}\n\n/**\n * Arguments passed to action functions\n */\nexport interface ActionFunctionArgs extends DataFunctionArgs {}\n\n/**\n * Loaders and actions can return anything except `undefined` (`null` is a\n * valid return value if there is no data to return).  Responses are preferred\n * and will ease any future migration to Remix\n */\ntype DataFunctionValue = Response | NonNullable<unknown> | null;\n\n/**\n * Route loader function signature\n */\nexport interface LoaderFunction {\n  (args: LoaderFunctionArgs): Promise<DataFunctionValue> | DataFunctionValue;\n}\n\n/**\n * Route action function signature\n */\nexport interface ActionFunction {\n  (args: ActionFunctionArgs): Promise<DataFunctionValue> | DataFunctionValue;\n}\n\n/**\n * Route shouldRevalidate function signature.  This runs after any submission\n * (navigation or fetcher), so we flatten the navigation/fetcher submission\n * onto the arguments.  It shouldn't matter whether it came from a navigation\n * or a fetcher, what really matters is the URLs and the formData since loaders\n * have to re-run based on the data models that were potentially mutated.\n */\nexport interface ShouldRevalidateFunction {\n  (args: {\n    currentUrl: URL;\n    currentParams: AgnosticDataRouteMatch[\"params\"];\n    nextUrl: URL;\n    nextParams: AgnosticDataRouteMatch[\"params\"];\n    formMethod?: Submission[\"formMethod\"];\n    formAction?: Submission[\"formAction\"];\n    formEncType?: Submission[\"formEncType\"];\n    text?: Submission[\"text\"];\n    formData?: Submission[\"formData\"];\n    json?: Submission[\"json\"];\n    actionResult?: DataResult;\n    defaultShouldRevalidate: boolean;\n  }): boolean;\n}\n\n/**\n * Function provided by the framework-aware layers to set `hasErrorBoundary`\n * from the framework-aware `errorElement` prop\n *\n * @deprecated Use `mapRouteProperties` instead\n */\nexport interface DetectErrorBoundaryFunction {\n  (route: AgnosticRouteObject): boolean;\n}\n\n/**\n * Function provided by the framework-aware layers to set any framework-specific\n * properties from framework-agnostic properties\n */\nexport interface MapRoutePropertiesFunction {\n  (route: AgnosticRouteObject): {\n    hasErrorBoundary: boolean;\n  } & Record<string, any>;\n}\n\n/**\n * Keys we cannot change from within a lazy() function. We spread all other keys\n * onto the route. Either they're meaningful to the router, or they'll get\n * ignored.\n */\nexport type ImmutableRouteKey =\n  | \"lazy\"\n  | \"caseSensitive\"\n  | \"path\"\n  | \"id\"\n  | \"index\"\n  | \"children\";\n\nexport const immutableRouteKeys = new Set<ImmutableRouteKey>([\n  \"lazy\",\n  \"caseSensitive\",\n  \"path\",\n  \"id\",\n  \"index\",\n  \"children\",\n]);\n\ntype RequireOne<T, Key = keyof T> = Exclude<\n  {\n    [K in keyof T]: K extends Key ? Omit<T, K> & Required<Pick<T, K>> : never;\n  }[keyof T],\n  undefined\n>;\n\n/**\n * lazy() function to load a route definition, which can add non-matching\n * related properties to a route\n */\nexport interface LazyRouteFunction<R extends AgnosticRouteObject> {\n  (): Promise<RequireOne<Omit<R, ImmutableRouteKey>>>;\n}\n\n/**\n * Base RouteObject with common props shared by all types of routes\n */\ntype AgnosticBaseRouteObject = {\n  caseSensitive?: boolean;\n  path?: string;\n  id?: string;\n  loader?: LoaderFunction;\n  action?: ActionFunction;\n  hasErrorBoundary?: boolean;\n  shouldRevalidate?: ShouldRevalidateFunction;\n  handle?: any;\n  lazy?: LazyRouteFunction<AgnosticBaseRouteObject>;\n};\n\n/**\n * Index routes must not have children\n */\nexport type AgnosticIndexRouteObject = AgnosticBaseRouteObject & {\n  children?: undefined;\n  index: true;\n};\n\n/**\n * Non-index routes may have children, but cannot have index\n */\nexport type AgnosticNonIndexRouteObject = AgnosticBaseRouteObject & {\n  children?: AgnosticRouteObject[];\n  index?: false;\n};\n\n/**\n * A route object represents a logical route, with (optionally) its child\n * routes organized in a tree-like structure.\n */\nexport type AgnosticRouteObject =\n  | AgnosticIndexRouteObject\n  | AgnosticNonIndexRouteObject;\n\nexport type AgnosticDataIndexRouteObject = AgnosticIndexRouteObject & {\n  id: string;\n};\n\nexport type AgnosticDataNonIndexRouteObject = AgnosticNonIndexRouteObject & {\n  children?: AgnosticDataRouteObject[];\n  id: string;\n};\n\n/**\n * A data route object, which is just a RouteObject with a required unique ID\n */\nexport type AgnosticDataRouteObject =\n  | AgnosticDataIndexRouteObject\n  | AgnosticDataNonIndexRouteObject;\n\nexport type RouteManifest = Record<string, AgnosticDataRouteObject | undefined>;\n\n// Recursive helper for finding path parameters in the absence of wildcards\ntype _PathParam<Path extends string> =\n  // split path into individual path segments\n  Path extends `${infer L}/${infer R}`\n    ? _PathParam<L> | _PathParam<R>\n    : // find params after `:`\n    Path extends `:${infer Param}`\n    ? Param extends `${infer Optional}?`\n      ? Optional\n      : Param\n    : // otherwise, there aren't any params present\n      never;\n\n/**\n * Examples:\n * \"/a/b/*\" -> \"*\"\n * \":a\" -> \"a\"\n * \"/a/:b\" -> \"b\"\n * \"/a/blahblahblah:b\" -> \"b\"\n * \"/:a/:b\" -> \"a\" | \"b\"\n * \"/:a/b/:c/*\" -> \"a\" | \"c\" | \"*\"\n */\ntype PathParam<Path extends string> =\n  // check if path is just a wildcard\n  Path extends \"*\" | \"/*\"\n    ? \"*\"\n    : // look for wildcard at the end of the path\n    Path extends `${infer Rest}/*`\n    ? \"*\" | _PathParam<Rest>\n    : // look for params in the absence of wildcards\n      _PathParam<Path>;\n\n// Attempt to parse the given string segment. If it fails, then just return the\n// plain string type as a default fallback. Otherwise return the union of the\n// parsed string literals that were referenced as dynamic segments in the route.\nexport type ParamParseKey<Segment extends string> =\n  // if could not find path params, fallback to `string`\n  [PathParam<Segment>] extends [never] ? string : PathParam<Segment>;\n\n/**\n * The parameters that were parsed from the URL path.\n */\nexport type Params<Key extends string = string> = {\n  readonly [key in Key]: string | undefined;\n};\n\n/**\n * A RouteMatch contains info about how a route matched a URL.\n */\nexport interface AgnosticRouteMatch<\n  ParamKey extends string = string,\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The route object that was used to match.\n   */\n  route: RouteObjectType;\n}\n\nexport interface AgnosticDataRouteMatch\n  extends AgnosticRouteMatch<string, AgnosticDataRouteObject> {}\n\nfunction isIndexRoute(\n  route: AgnosticRouteObject\n): route is AgnosticIndexRouteObject {\n  return route.index === true;\n}\n\n// Walk the route tree generating unique IDs where necessary so we are working\n// solely with AgnosticDataRouteObject's within the Router\nexport function convertRoutesToDataRoutes(\n  routes: AgnosticRouteObject[],\n  mapRouteProperties: MapRoutePropertiesFunction,\n  parentPath: number[] = [],\n  manifest: RouteManifest = {}\n): AgnosticDataRouteObject[] {\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, index];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(\n      route.index !== true || !route.children,\n      `Cannot specify children on an index route`\n    );\n    invariant(\n      !manifest[id],\n      `Found a route id collision on id \"${id}\".  Route ` +\n        \"id's must be globally unique within Data Router usages\"\n    );\n\n    if (isIndexRoute(route)) {\n      let indexRoute: AgnosticDataIndexRouteObject = {\n        ...route,\n        ...mapRouteProperties(route),\n        id,\n      };\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute: AgnosticDataNonIndexRouteObject = {\n        ...route,\n        ...mapRouteProperties(route),\n        id,\n        children: undefined,\n      };\n      manifest[id] = pathOrLayoutRoute;\n\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(\n          route.children,\n          mapRouteProperties,\n          treePath,\n          manifest\n        );\n      }\n\n      return pathOrLayoutRoute;\n    }\n  });\n}\n\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */\nexport function matchRoutes<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  routes: RouteObjectType[],\n  locationArg: Partial<Location> | string,\n  basename = \"/\"\n): AgnosticRouteMatch<string, RouteObjectType>[] | null {\n  let location =\n    typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n\n  if (pathname == null) {\n    return null;\n  }\n\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch<string, RouteObjectType>(\n      branches[i],\n      // Incoming pathnames are generally encoded from either window.location\n      // or from router.navigate, but we want to match against the unencoded\n      // paths in the route definitions.  Memory router locations won't be\n      // encoded here but there also shouldn't be anything to decode so this\n      // should be a safe operation.  This avoids needing matchRoutes to be\n      // history-aware.\n      safelyDecodeURI(pathname)\n    );\n  }\n\n  return matches;\n}\n\ninterface RouteMeta<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  relativePath: string;\n  caseSensitive: boolean;\n  childrenIndex: number;\n  route: RouteObjectType;\n}\n\ninterface RouteBranch<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n> {\n  path: string;\n  score: number;\n  routesMeta: RouteMeta<RouteObjectType>[];\n}\n\nfunction flattenRoutes<\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  routes: RouteObjectType[],\n  branches: RouteBranch<RouteObjectType>[] = [],\n  parentsMeta: RouteMeta<RouteObjectType>[] = [],\n  parentPath = \"\"\n): RouteBranch<RouteObjectType>[] {\n  let flattenRoute = (\n    route: RouteObjectType,\n    index: number,\n    relativePath?: string\n  ) => {\n    let meta: RouteMeta<RouteObjectType> = {\n      relativePath:\n        relativePath === undefined ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route,\n    };\n\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(\n        meta.relativePath.startsWith(parentPath),\n        `Absolute route path \"${meta.relativePath}\" nested under path ` +\n          `\"${parentPath}\" is not valid. An absolute child route path ` +\n          `must start with the combined path of all its parent routes.`\n      );\n\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n\n    // Add the children before adding this route to the array so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n        // Our types know better, but runtime JS may not!\n        // @ts-expect-error\n        route.index !== true,\n        `Index routes must not have child routes. Please remove ` +\n          `all child routes from route path \"${path}\".`\n      );\n\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta,\n    });\n  };\n  routes.forEach((route, index) => {\n    // coarse-grain check for optional params\n    if (route.path === \"\" || !route.path?.includes(\"?\")) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n\n  return branches;\n}\n\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */\nfunction explodeOptionalSegments(path: string): string[] {\n  let segments = path.split(\"/\");\n  if (segments.length === 0) return [];\n\n  let [first, ...rest] = segments;\n\n  // Optional path segments are denoted by a trailing `?`\n  let isOptional = first.endsWith(\"?\");\n  // Compute the corresponding required segment: `foo?` -> `foo`\n  let required = first.replace(/\\?$/, \"\");\n\n  if (rest.length === 0) {\n    // Intepret empty string as omitting an optional segment\n    // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n    return isOptional ? [required, \"\"] : [required];\n  }\n\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n\n  let result: string[] = [];\n\n  // All child paths with the prefix.  Do this for all children before the\n  // optional version for all children so we get consistent ordering where the\n  // parent optional aspect is preferred as required.  Otherwise, we can get\n  // child sections interspersed where deeper optional segments are higher than\n  // parent optional segments, where for example, /:two would explodes _earlier_\n  // then /:one.  By always including the parent as required _for all children_\n  // first, we avoid this issue\n  result.push(\n    ...restExploded.map((subpath) =>\n      subpath === \"\" ? required : [required, subpath].join(\"/\")\n    )\n  );\n\n  // Then if this is an optional value, add all child versions without\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n\n  // for absolute paths, ensure `/` instead of empty segment\n  return result.map((exploded) =>\n    path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded\n  );\n}\n\nfunction rankRouteBranches(branches: RouteBranch[]): void {\n  branches.sort((a, b) =>\n    a.score !== b.score\n      ? b.score - a.score // Higher score first\n      : compareIndexes(\n          a.routesMeta.map((meta) => meta.childrenIndex),\n          b.routesMeta.map((meta) => meta.childrenIndex)\n        )\n  );\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s: string) => s === \"*\";\n\nfunction computeScore(path: string, index: boolean | undefined): number {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n\n  return segments\n    .filter((s) => !isSplat(s))\n    .reduce(\n      (score, segment) =>\n        score +\n        (paramRe.test(segment)\n          ? dynamicSegmentValue\n          : segment === \"\"\n          ? emptySegmentValue\n          : staticSegmentValue),\n      initialScore\n    );\n}\n\nfunction compareIndexes(a: number[], b: number[]): number {\n  let siblings =\n    a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n\n  return siblings\n    ? // If two routes are siblings, we should try to match the earlier sibling\n      // first. This allows people to have fine-grained control over the matching\n      // behavior by simply putting routes with identical paths in the order they\n      // want them tried.\n      a[a.length - 1] - b[b.length - 1]\n    : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n      // so they sort equally.\n      0;\n}\n\nfunction matchRouteBranch<\n  ParamKey extends string = string,\n  RouteObjectType extends AgnosticRouteObject = AgnosticRouteObject\n>(\n  branch: RouteBranch<RouteObjectType>,\n  pathname: string\n): AgnosticRouteMatch<ParamKey, RouteObjectType>[] | null {\n  let { routesMeta } = branch;\n\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches: AgnosticRouteMatch<ParamKey, RouteObjectType>[] = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname =\n      matchedPathname === \"/\"\n        ? pathname\n        : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath(\n      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },\n      remainingPathname\n    );\n\n    if (!match) return null;\n\n    Object.assign(matchedParams, match.params);\n\n    let route = meta.route;\n\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams as Params<ParamKey>,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(\n        joinPaths([matchedPathname, match.pathnameBase])\n      ),\n      route,\n    });\n\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */\nexport function generatePath<Path extends string>(\n  originalPath: Path,\n  params: {\n    [key in PathParam<Path>]: string | null;\n  } = {} as any\n): string {\n  let path: string = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(\n      false,\n      `Route path \"${path}\" will be treated as if it were ` +\n        `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n        `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n        `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n    );\n    path = path.replace(/\\*$/, \"/*\") as Path;\n  }\n\n  // ensure `/` is added at the beginning if the path is absolute\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n\n  const stringify = (p: any) =>\n    p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n\n  const segments = path\n    .split(/\\/+/)\n    .map((segment, index, array) => {\n      const isLastSegment = index === array.length - 1;\n\n      // only apply the splat if it's the last segment\n      if (isLastSegment && segment === \"*\") {\n        const star = \"*\" as PathParam<Path>;\n        // Apply the splat\n        return stringify(params[star]);\n      }\n\n      const keyMatch = segment.match(/^:(\\w+)(\\??)$/);\n      if (keyMatch) {\n        const [, key, optional] = keyMatch;\n        let param = params[key as PathParam<Path>];\n        invariant(optional === \"?\" || param != null, `Missing \":${key}\" param`);\n        return stringify(param);\n      }\n\n      // Remove any optional markers from optional static segments\n      return segment.replace(/\\?$/g, \"\");\n    })\n    // Remove empty segments\n    .filter((segment) => !!segment);\n\n  return prefix + segments.join(\"/\");\n}\n\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\nexport interface PathPattern<Path extends string = string> {\n  /**\n   * A string to match against a URL pathname. May contain `:id`-style segments\n   * to indicate placeholders for dynamic parameters. May also end with `/*` to\n   * indicate matching the rest of the URL pathname.\n   */\n  path: Path;\n  /**\n   * Should be `true` if the static portions of the `path` should be matched in\n   * the same case.\n   */\n  caseSensitive?: boolean;\n  /**\n   * Should be `true` if this pattern should match the entire URL pathname.\n   */\n  end?: boolean;\n}\n\n/**\n * A PathMatch contains info about how a PathPattern matched on a URL pathname.\n */\nexport interface PathMatch<ParamKey extends string = string> {\n  /**\n   * The names and values of dynamic parameters in the URL.\n   */\n  params: Params<ParamKey>;\n  /**\n   * The portion of the URL pathname that was matched.\n   */\n  pathname: string;\n  /**\n   * The portion of the URL pathname that was matched before child routes.\n   */\n  pathnameBase: string;\n  /**\n   * The pattern that was used to match.\n   */\n  pattern: PathPattern;\n}\n\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */\nexport function matchPath<\n  ParamKey extends ParamParseKey<Path>,\n  Path extends string\n>(\n  pattern: PathPattern<Path> | Path,\n  pathname: string\n): PathMatch<ParamKey> | null {\n  if (typeof pattern === \"string\") {\n    pattern = { path: pattern, caseSensitive: false, end: true };\n  }\n\n  let [matcher, paramNames] = compilePath(\n    pattern.path,\n    pattern.caseSensitive,\n    pattern.end\n  );\n\n  let match = pathname.match(matcher);\n  if (!match) return null;\n\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params: Params = paramNames.reduce<Mutable<Params>>(\n    (memo, paramName, index) => {\n      // We need to compute the pathnameBase here using the raw splat value\n      // instead of using params[\"*\"] later because it will be decoded then\n      if (paramName === \"*\") {\n        let splatValue = captureGroups[index] || \"\";\n        pathnameBase = matchedPathname\n          .slice(0, matchedPathname.length - splatValue.length)\n          .replace(/(.)\\/+$/, \"$1\");\n      }\n\n      memo[paramName] = safelyDecodeURIComponent(\n        captureGroups[index] || \"\",\n        paramName\n      );\n      return memo;\n    },\n    {}\n  );\n\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern,\n  };\n}\n\nfunction compilePath(\n  path: string,\n  caseSensitive = false,\n  end = true\n): [RegExp, string[]] {\n  warning(\n    path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"),\n    `Route path \"${path}\" will be treated as if it were ` +\n      `\"${path.replace(/\\*$/, \"/*\")}\" because the \\`*\\` character must ` +\n      `always follow a \\`/\\` in the pattern. To get rid of this warning, ` +\n      `please change the route path to \"${path.replace(/\\*$/, \"/*\")}\".`\n  );\n\n  let paramNames: string[] = [];\n  let regexpSource =\n    \"^\" +\n    path\n      .replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n      .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n      .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n      .replace(/\\/:(\\w+)/g, (_: string, paramName: string) => {\n        paramNames.push(paramName);\n        return \"/([^\\\\/]+)\";\n      });\n\n  if (path.endsWith(\"*\")) {\n    paramNames.push(\"*\");\n    regexpSource +=\n      path === \"*\" || path === \"/*\"\n        ? \"(.*)$\" // Already matched the initial /, just match the rest\n        : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else if (end) {\n    // When matching to the end, ignore trailing slashes\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    // If our path is non-empty and contains anything beyond an initial slash,\n    // then we have _some_ form of path in our regex so we should expect to\n    // match only if we find the end of this path segment.  Look for an optional\n    // non-captured trailing slash (to match a portion of the URL) or the end\n    // of the path (if we've matched to the end).  We used to do this with a\n    // word boundary but that gives false positives on routes like\n    // /user-preferences since `-` counts as a word boundary.\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else {\n    // Nothing to match for \"\" or \"/\"\n  }\n\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n\n  return [matcher, paramNames];\n}\n\nfunction safelyDecodeURI(value: string) {\n  try {\n    return decodeURI(value);\n  } catch (error) {\n    warning(\n      false,\n      `The URL path \"${value}\" could not be decoded because it is is a ` +\n        `malformed URL segment. This is probably due to a bad percent ` +\n        `encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\nfunction safelyDecodeURIComponent(value: string, paramName: string) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(\n      false,\n      `The value for the URL param \"${paramName}\" will not be decoded because` +\n        ` the string \"${value}\" is a malformed URL segment. This is probably` +\n        ` due to a bad percent encoding (${error}).`\n    );\n\n    return value;\n  }\n}\n\n/**\n * @private\n */\nexport function stripBasename(\n  pathname: string,\n  basename: string\n): string | null {\n  if (basename === \"/\") return pathname;\n\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n\n  // We want to leave trailing slash behavior in the user's control, so if they\n  // specify a basename with a trailing slash, we should support it\n  let startIndex = basename.endsWith(\"/\")\n    ? basename.length - 1\n    : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n\n  return pathname.slice(startIndex) || \"/\";\n}\n\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */\nexport function resolvePath(to: To, fromPathname = \"/\"): Path {\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\",\n  } = typeof to === \"string\" ? parsePath(to) : to;\n\n  let pathname = toPathname\n    ? toPathname.startsWith(\"/\")\n      ? toPathname\n      : resolvePathname(toPathname, fromPathname)\n    : fromPathname;\n\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash),\n  };\n}\n\nfunction resolvePathname(relativePath: string, fromPathname: string): string {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n\n  relativeSegments.forEach((segment) => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\n\nfunction getInvalidPathError(\n  char: string,\n  field: string,\n  dest: string,\n  path: Partial<Path>\n) {\n  return (\n    `Cannot include a '${char}' character in a manually specified ` +\n    `\\`to.${field}\\` field [${JSON.stringify(\n      path\n    )}].  Please separate it out to the ` +\n    `\\`to.${dest}\\` field. Alternatively you may provide the full path as ` +\n    `a string in <Link to=\"...\"> and the router will parse it for you.`\n  );\n}\n\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */\nexport function getPathContributingMatches<\n  T extends AgnosticRouteMatch = AgnosticRouteMatch\n>(matches: T[]) {\n  return matches.filter(\n    (match, index) =>\n      index === 0 || (match.route.path && match.route.path.length > 0)\n  );\n}\n\n/**\n * @private\n */\nexport function resolveTo(\n  toArg: To,\n  routePathnames: string[],\n  locationPathname: string,\n  isPathRelative = false\n): Path {\n  let to: Partial<Path>;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = { ...toArg };\n\n    invariant(\n      !to.pathname || !to.pathname.includes(\"?\"),\n      getInvalidPathError(\"?\", \"pathname\", \"search\", to)\n    );\n    invariant(\n      !to.pathname || !to.pathname.includes(\"#\"),\n      getInvalidPathError(\"#\", \"pathname\", \"hash\", to)\n    );\n    invariant(\n      !to.search || !to.search.includes(\"#\"),\n      getInvalidPathError(\"#\", \"search\", \"hash\", to)\n    );\n  }\n\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n\n  let from: string;\n\n  // Routing is relative to the current pathname if explicitly requested.\n  //\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  if (isPathRelative || toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n\n      // Each leading .. segment means \"go up one route\" instead of \"go up one\n      // URL segment\".  This is a key difference from how <a href> works and a\n      // major reason we call this a \"to\" value instead of a \"href\".\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n\n      to.pathname = toSegments.join(\"/\");\n    }\n\n    // If there are more \"..\" segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n\n  let path = resolvePath(to, from);\n\n  // Ensure the pathname has a trailing slash if the original \"to\" had one\n  let hasExplicitTrailingSlash =\n    toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  // Or if this was a link to the current path which has a trailing slash\n  let hasCurrentTrailingSlash =\n    (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (\n    !path.pathname.endsWith(\"/\") &&\n    (hasExplicitTrailingSlash || hasCurrentTrailingSlash)\n  ) {\n    path.pathname += \"/\";\n  }\n\n  return path;\n}\n\n/**\n * @private\n */\nexport function getToPathname(to: To): string | undefined {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || (to as Path).pathname === \"\"\n    ? \"/\"\n    : typeof to === \"string\"\n    ? parsePath(to).pathname\n    : to.pathname;\n}\n\n/**\n * @private\n */\nexport const joinPaths = (paths: string[]): string =>\n  paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n\n/**\n * @private\n */\nexport const normalizePathname = (pathname: string): string =>\n  pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n\n/**\n * @private\n */\nexport const normalizeSearch = (search: string): string =>\n  !search || search === \"?\"\n    ? \"\"\n    : search.startsWith(\"?\")\n    ? search\n    : \"?\" + search;\n\n/**\n * @private\n */\nexport const normalizeHash = (hash: string): string =>\n  !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n\nexport type JsonFunction = <Data>(\n  data: Data,\n  init?: number | ResponseInit\n) => Response;\n\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */\nexport const json: JsonFunction = (data, init = {}) => {\n  let responseInit = typeof init === \"number\" ? { status: init } : init;\n\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n  }\n\n  return new Response(JSON.stringify(data), {\n    ...responseInit,\n    headers,\n  });\n};\n\nexport interface TrackedPromise extends Promise<any> {\n  _tracked?: boolean;\n  _data?: any;\n  _error?: any;\n}\n\nexport class AbortedDeferredError extends Error {}\n\nexport class DeferredData {\n  private pendingKeysSet: Set<string> = new Set<string>();\n  private controller: AbortController;\n  private abortPromise: Promise<void>;\n  private unlistenAbortSignal: () => void;\n  private subscribers: Set<(aborted: boolean, settledKey?: string) => void> =\n    new Set();\n  data: Record<string, unknown>;\n  init?: ResponseInit;\n  deferredKeys: string[] = [];\n\n  constructor(data: Record<string, unknown>, responseInit?: ResponseInit) {\n    invariant(\n      data && typeof data === \"object\" && !Array.isArray(data),\n      \"defer() only accepts plain objects\"\n    );\n\n    // Set up an AbortController + Promise we can race against to exit early\n    // cancellation\n    let reject: (e: AbortedDeferredError) => void;\n    this.abortPromise = new Promise((_, r) => (reject = r));\n    this.controller = new AbortController();\n    let onAbort = () =>\n      reject(new AbortedDeferredError(\"Deferred data aborted\"));\n    this.unlistenAbortSignal = () =>\n      this.controller.signal.removeEventListener(\"abort\", onAbort);\n    this.controller.signal.addEventListener(\"abort\", onAbort);\n\n    this.data = Object.entries(data).reduce(\n      (acc, [key, value]) =>\n        Object.assign(acc, {\n          [key]: this.trackPromise(key, value),\n        }),\n      {}\n    );\n\n    if (this.done) {\n      // All incoming values were resolved\n      this.unlistenAbortSignal();\n    }\n\n    this.init = responseInit;\n  }\n\n  private trackPromise(\n    key: string,\n    value: Promise<unknown> | unknown\n  ): TrackedPromise | unknown {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n\n    this.deferredKeys.push(key);\n    this.pendingKeysSet.add(key);\n\n    // We store a little wrapper promise that will be extended with\n    // _data/_error props upon resolve/reject\n    let promise: TrackedPromise = Promise.race([value, this.abortPromise]).then(\n      (data) => this.onSettle(promise, key, undefined, data as unknown),\n      (error) => this.onSettle(promise, key, error as unknown)\n    );\n\n    // Register rejection listeners to avoid uncaught promise rejections on\n    // errors or aborted deferred values\n    promise.catch(() => {});\n\n    Object.defineProperty(promise, \"_tracked\", { get: () => true });\n    return promise;\n  }\n\n  private onSettle(\n    promise: TrackedPromise,\n    key: string,\n    error: unknown,\n    data?: unknown\n  ): unknown {\n    if (\n      this.controller.signal.aborted &&\n      error instanceof AbortedDeferredError\n    ) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, \"_error\", { get: () => error });\n      return Promise.reject(error);\n    }\n\n    this.pendingKeysSet.delete(key);\n\n    if (this.done) {\n      // Nothing left to abort!\n      this.unlistenAbortSignal();\n    }\n\n    // If the promise was resolved/rejected with undefined, we'll throw an error as you\n    // should always resolve with a value or null\n    if (error === undefined && data === undefined) {\n      let undefinedError = new Error(\n        `Deferred data for key \"${key}\" resolved/rejected with \\`undefined\\`, ` +\n          `you must resolve/reject with a value or \\`null\\`.`\n      );\n      Object.defineProperty(promise, \"_error\", { get: () => undefinedError });\n      this.emit(false, key);\n      return Promise.reject(undefinedError);\n    }\n\n    if (data === undefined) {\n      Object.defineProperty(promise, \"_error\", { get: () => error });\n      this.emit(false, key);\n      return Promise.reject(error);\n    }\n\n    Object.defineProperty(promise, \"_data\", { get: () => data });\n    this.emit(false, key);\n    return data;\n  }\n\n  private emit(aborted: boolean, settledKey?: string) {\n    this.subscribers.forEach((subscriber) => subscriber(aborted, settledKey));\n  }\n\n  subscribe(fn: (aborted: boolean, settledKey?: string) => void) {\n    this.subscribers.add(fn);\n    return () => this.subscribers.delete(fn);\n  }\n\n  cancel() {\n    this.controller.abort();\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\n    this.emit(true);\n  }\n\n  async resolveData(signal: AbortSignal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener(\"abort\", onAbort);\n      aborted = await new Promise((resolve) => {\n        this.subscribe((aborted) => {\n          signal.removeEventListener(\"abort\", onAbort);\n          if (aborted || this.done) {\n            resolve(aborted);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n\n  get done() {\n    return this.pendingKeysSet.size === 0;\n  }\n\n  get unwrappedData() {\n    invariant(\n      this.data !== null && this.done,\n      \"Can only unwrap data on initialized and settled deferreds\"\n    );\n\n    return Object.entries(this.data).reduce(\n      (acc, [key, value]) =>\n        Object.assign(acc, {\n          [key]: unwrapTrackedPromise(value),\n        }),\n      {}\n    );\n  }\n\n  get pendingKeys() {\n    return Array.from(this.pendingKeysSet);\n  }\n}\n\nfunction isTrackedPromise(value: any): value is TrackedPromise {\n  return (\n    value instanceof Promise && (value as TrackedPromise)._tracked === true\n  );\n}\n\nfunction unwrapTrackedPromise(value: any) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\n\nexport type DeferFunction = (\n  data: Record<string, unknown>,\n  init?: number | ResponseInit\n) => DeferredData;\n\nexport const defer: DeferFunction = (data, init = {}) => {\n  let responseInit = typeof init === \"number\" ? { status: init } : init;\n\n  return new DeferredData(data, responseInit);\n};\n\nexport type RedirectFunction = (\n  url: string,\n  init?: number | ResponseInit\n) => Response;\n\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nexport const redirect: RedirectFunction = (url, init = 302) => {\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = { status: responseInit };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n\n  return new Response(null, {\n    ...responseInit,\n    headers,\n  });\n};\n\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n */\nexport class ErrorResponse {\n  status: number;\n  statusText: string;\n  data: any;\n  error?: Error;\n  internal: boolean;\n\n  constructor(\n    status: number,\n    statusText: string | undefined,\n    data: any,\n    internal = false\n  ) {\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data instanceof Error) {\n      this.data = data.toString();\n      this.error = data;\n    } else {\n      this.data = data;\n    }\n  }\n}\n\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */\nexport function isRouteErrorResponse(error: any): error is ErrorResponse {\n  return (\n    error != null &&\n    typeof error.status === \"number\" &&\n    typeof error.statusText === \"string\" &&\n    typeof error.internal === \"boolean\" &&\n    \"data\" in error\n  );\n}\n","import type { History, Location, Path, To } from \"./history\";\nimport {\n  Action as HistoryAction,\n  createLocation,\n  createPath,\n  invariant,\n  parsePath,\n  warning,\n} from \"./history\";\nimport type {\n  DataResult,\n  DeferredData,\n  AgnosticDataRouteMatch,\n  AgnosticDataRouteObject,\n  DeferredResult,\n  ErrorResult,\n  FormEncType,\n  FormMethod,\n  DetectErrorBoundaryFunction,\n  RedirectResult,\n  RouteData,\n  AgnosticRouteObject,\n  Submission,\n  SuccessResult,\n  AgnosticRouteMatch,\n  ShouldRevalidateFunction,\n  RouteManifest,\n  ImmutableRouteKey,\n  ActionFunction,\n  LoaderFunction,\n  V7_MutationFormMethod,\n  V7_FormMethod,\n  HTMLFormMethod,\n  MutationFormMethod,\n  MapRoutePropertiesFunction,\n} from \"./utils\";\nimport {\n  ErrorResponse,\n  ResultType,\n  convertRoutesToDataRoutes,\n  getPathContributingMatches,\n  immutableRouteKeys,\n  isRouteErrorResponse,\n  joinPaths,\n  matchRoutes,\n  resolveTo,\n  stripBasename,\n} from \"./utils\";\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * A Router instance manages all navigation and data loading/mutations\n */\nexport interface Router {\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the basename for the router\n   */\n  get basename(): RouterInit[\"basename\"];\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the current state of the router\n   */\n  get state(): RouterState;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Return the routes for this router instance\n   */\n  get routes(): AgnosticDataRouteObject[];\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Initialize the router, including adding history listeners and kicking off\n   * initial data fetches.  Returns a function to cleanup listeners and abort\n   * any in-progress loads\n   */\n  initialize(): Router;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Subscribe to router.state updates\n   *\n   * @param fn function to call with the new state\n   */\n  subscribe(fn: RouterSubscriber): () => void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Enable scroll restoration behavior in the router\n   *\n   * @param savedScrollPositions Object that will manage positions, in case\n   *                             it's being restored from sessionStorage\n   * @param getScrollPosition    Function to get the active Y scroll position\n   * @param getKey               Function to get the key to use for restoration\n   */\n  enableScrollRestoration(\n    savedScrollPositions: Record<string, number>,\n    getScrollPosition: GetScrollPositionFunction,\n    getKey?: GetScrollRestorationKeyFunction\n  ): () => void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Navigate forward/backward in the history stack\n   * @param to Delta to move in the history stack\n   */\n  navigate(to: number): Promise<void>;\n\n  /**\n   * Navigate to the given path\n   * @param to Path to navigate to\n   * @param opts Navigation options (method, submission, etc.)\n   */\n  navigate(to: To | null, opts?: RouterNavigateOptions): Promise<void>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Trigger a fetcher load/submission\n   *\n   * @param key     Fetcher key\n   * @param routeId Route that owns the fetcher\n   * @param href    href to fetch\n   * @param opts    Fetcher options, (method, submission, etc.)\n   */\n  fetch(\n    key: string,\n    routeId: string,\n    href: string | null,\n    opts?: RouterFetchOptions\n  ): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Trigger a revalidation of all current route loaders and fetcher loads\n   */\n  revalidate(): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Utility function to create an href for the given location\n   * @param location\n   */\n  createHref(location: Location | URL): string;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Utility function to URL encode a destination path according to the internal\n   * history implementation\n   * @param to\n   */\n  encodeLocation(to: To): Path;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Get/create a fetcher for the given key\n   * @param key\n   */\n  getFetcher<TData = any>(key?: string): Fetcher<TData>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Delete the fetcher for a given key\n   * @param key\n   */\n  deleteFetcher(key?: string): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Cleanup listeners and abort any in-progress loads\n   */\n  dispose(): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Get a navigation blocker\n   * @param key The identifier for the blocker\n   * @param fn The blocker function implementation\n   */\n  getBlocker(key: string, fn: BlockerFunction): Blocker;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Delete a navigation blocker\n   * @param key The identifier for the blocker\n   */\n  deleteBlocker(key: string): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * HMR needs to pass in-flight route updates to React Router\n   * TODO: Replace this with granular route update APIs (addRoute, updateRoute, deleteRoute)\n   */\n  _internalSetRoutes(routes: AgnosticRouteObject[]): void;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Internal fetch AbortControllers accessed by unit tests\n   */\n  _internalFetchControllers: Map<string, AbortController>;\n\n  /**\n   * @internal\n   * PRIVATE - DO NOT USE\n   *\n   * Internal pending DeferredData instances accessed by unit tests\n   */\n  _internalActiveDeferreds: Map<string, DeferredData>;\n}\n\n/**\n * State maintained internally by the router.  During a navigation, all states\n * reflect the the \"old\" location unless otherwise noted.\n */\nexport interface RouterState {\n  /**\n   * The action of the most recent navigation\n   */\n  historyAction: HistoryAction;\n\n  /**\n   * The current location reflected by the router\n   */\n  location: Location;\n\n  /**\n   * The current set of route matches\n   */\n  matches: AgnosticDataRouteMatch[];\n\n  /**\n   * Tracks whether we've completed our initial data load\n   */\n  initialized: boolean;\n\n  /**\n   * Current scroll position we should start at for a new view\n   *  - number -> scroll position to restore to\n   *  - false -> do not restore scroll at all (used during submissions)\n   *  - null -> don't have a saved position, scroll to hash or top of page\n   */\n  restoreScrollPosition: number | false | null;\n\n  /**\n   * Indicate whether this navigation should skip resetting the scroll position\n   * if we are unable to restore the scroll position\n   */\n  preventScrollReset: boolean;\n\n  /**\n   * Tracks the state of the current navigation\n   */\n  navigation: Navigation;\n\n  /**\n   * Tracks any in-progress revalidations\n   */\n  revalidation: RevalidationState;\n\n  /**\n   * Data from the loaders for the current matches\n   */\n  loaderData: RouteData;\n\n  /**\n   * Data from the action for the current matches\n   */\n  actionData: RouteData | null;\n\n  /**\n   * Errors caught from loaders for the current matches\n   */\n  errors: RouteData | null;\n\n  /**\n   * Map of current fetchers\n   */\n  fetchers: Map<string, Fetcher>;\n\n  /**\n   * Map of current blockers\n   */\n  blockers: Map<string, Blocker>;\n}\n\n/**\n * Data that can be passed into hydrate a Router from SSR\n */\nexport type HydrationState = Partial<\n  Pick<RouterState, \"loaderData\" | \"actionData\" | \"errors\">\n>;\n\n/**\n * Future flags to toggle new feature behavior\n */\nexport interface FutureConfig {\n  v7_normalizeFormMethod: boolean;\n  v7_prependBasename: boolean;\n}\n\n/**\n * Initialization options for createRouter\n */\nexport interface RouterInit {\n  routes: AgnosticRouteObject[];\n  history: History;\n  basename?: string;\n  /**\n   * @deprecated Use `mapRouteProperties` instead\n   */\n  detectErrorBoundary?: DetectErrorBoundaryFunction;\n  mapRouteProperties?: MapRoutePropertiesFunction;\n  future?: Partial<FutureConfig>;\n  hydrationData?: HydrationState;\n  window?: Window;\n}\n\n/**\n * State returned from a server-side query() call\n */\nexport interface StaticHandlerContext {\n  basename: Router[\"basename\"];\n  location: RouterState[\"location\"];\n  matches: RouterState[\"matches\"];\n  loaderData: RouterState[\"loaderData\"];\n  actionData: RouterState[\"actionData\"];\n  errors: RouterState[\"errors\"];\n  statusCode: number;\n  loaderHeaders: Record<string, Headers>;\n  actionHeaders: Record<string, Headers>;\n  activeDeferreds: Record<string, DeferredData> | null;\n  _deepestRenderedBoundaryId?: string | null;\n}\n\n/**\n * A StaticHandler instance manages a singular SSR navigation/fetch event\n */\nexport interface StaticHandler {\n  dataRoutes: AgnosticDataRouteObject[];\n  query(\n    request: Request,\n    opts?: { requestContext?: unknown }\n  ): Promise<StaticHandlerContext | Response>;\n  queryRoute(\n    request: Request,\n    opts?: { routeId?: string; requestContext?: unknown }\n  ): Promise<any>;\n}\n\n/**\n * Subscriber function signature for changes to router state\n */\nexport interface RouterSubscriber {\n  (state: RouterState): void;\n}\n\ninterface UseMatchesMatch {\n  id: string;\n  pathname: string;\n  params: AgnosticRouteMatch[\"params\"];\n  data: unknown;\n  handle: unknown;\n}\n\n/**\n * Function signature for determining the key to be used in scroll restoration\n * for a given location\n */\nexport interface GetScrollRestorationKeyFunction {\n  (location: Location, matches: UseMatchesMatch[]): string | null;\n}\n\n/**\n * Function signature for determining the current scroll position\n */\nexport interface GetScrollPositionFunction {\n  (): number;\n}\n\nexport type RelativeRoutingType = \"route\" | \"path\";\n\n// Allowed for any navigation or fetch\ntype BaseNavigateOrFetchOptions = {\n  preventScrollReset?: boolean;\n  relative?: RelativeRoutingType;\n};\n\n// Only allowed for navigations\ntype BaseNavigateOptions = BaseNavigateOrFetchOptions & {\n  replace?: boolean;\n  state?: any;\n  fromRouteId?: string;\n};\n\n// Only allowed for submission navigations\ntype BaseSubmissionOptions = {\n  formMethod?: HTMLFormMethod;\n  formEncType?: FormEncType;\n} & (\n  | { formData: FormData; body?: undefined }\n  | { formData?: undefined; body: any }\n);\n\n/**\n * Options for a navigate() call for a normal (non-submission) navigation\n */\ntype LinkNavigateOptions = BaseNavigateOptions;\n\n/**\n * Options for a navigate() call for a submission navigation\n */\ntype SubmissionNavigateOptions = BaseNavigateOptions & BaseSubmissionOptions;\n\n/**\n * Options to pass to navigate() for a navigation\n */\nexport type RouterNavigateOptions =\n  | LinkNavigateOptions\n  | SubmissionNavigateOptions;\n\n/**\n * Options for a fetch() load\n */\ntype LoadFetchOptions = BaseNavigateOrFetchOptions;\n\n/**\n * Options for a fetch() submission\n */\ntype SubmitFetchOptions = BaseNavigateOrFetchOptions & BaseSubmissionOptions;\n\n/**\n * Options to pass to fetch()\n */\nexport type RouterFetchOptions = LoadFetchOptions | SubmitFetchOptions;\n\n/**\n * Potential states for state.navigation\n */\nexport type NavigationStates = {\n  Idle: {\n    state: \"idle\";\n    location: undefined;\n    formMethod: undefined;\n    formAction: undefined;\n    formEncType: undefined;\n    formData: undefined;\n    json: undefined;\n    text: undefined;\n  };\n  Loading: {\n    state: \"loading\";\n    location: Location;\n    formMethod: Submission[\"formMethod\"] | undefined;\n    formAction: Submission[\"formAction\"] | undefined;\n    formEncType: Submission[\"formEncType\"] | undefined;\n    formData: Submission[\"formData\"] | undefined;\n    json: Submission[\"json\"] | undefined;\n    text: Submission[\"text\"] | undefined;\n  };\n  Submitting: {\n    state: \"submitting\";\n    location: Location;\n    formMethod: Submission[\"formMethod\"];\n    formAction: Submission[\"formAction\"];\n    formEncType: Submission[\"formEncType\"];\n    formData: Submission[\"formData\"];\n    json: Submission[\"json\"];\n    text: Submission[\"text\"];\n  };\n};\n\nexport type Navigation = NavigationStates[keyof NavigationStates];\n\nexport type RevalidationState = \"idle\" | \"loading\";\n\n/**\n * Potential states for fetchers\n */\ntype FetcherStates<TData = any> = {\n  Idle: {\n    state: \"idle\";\n    formMethod: undefined;\n    formAction: undefined;\n    formEncType: undefined;\n    text: undefined;\n    formData: undefined;\n    json: undefined;\n    data: TData | undefined;\n    \" _hasFetcherDoneAnything \"?: boolean;\n  };\n  Loading: {\n    state: \"loading\";\n    formMethod: Submission[\"formMethod\"] | undefined;\n    formAction: Submission[\"formAction\"] | undefined;\n    formEncType: Submission[\"formEncType\"] | undefined;\n    text: Submission[\"text\"] | undefined;\n    formData: Submission[\"formData\"] | undefined;\n    json: Submission[\"json\"] | undefined;\n    data: TData | undefined;\n    \" _hasFetcherDoneAnything \"?: boolean;\n  };\n  Submitting: {\n    state: \"submitting\";\n    formMethod: Submission[\"formMethod\"];\n    formAction: Submission[\"formAction\"];\n    formEncType: Submission[\"formEncType\"];\n    text: Submission[\"text\"];\n    formData: Submission[\"formData\"];\n    json: Submission[\"json\"];\n    data: TData | undefined;\n    \" _hasFetcherDoneAnything \"?: boolean;\n  };\n};\n\nexport type Fetcher<TData = any> =\n  FetcherStates<TData>[keyof FetcherStates<TData>];\n\ninterface BlockerBlocked {\n  state: \"blocked\";\n  reset(): void;\n  proceed(): void;\n  location: Location;\n}\n\ninterface BlockerUnblocked {\n  state: \"unblocked\";\n  reset: undefined;\n  proceed: undefined;\n  location: undefined;\n}\n\ninterface BlockerProceeding {\n  state: \"proceeding\";\n  reset: undefined;\n  proceed: undefined;\n  location: Location;\n}\n\nexport type Blocker = BlockerUnblocked | BlockerBlocked | BlockerProceeding;\n\nexport type BlockerFunction = (args: {\n  currentLocation: Location;\n  nextLocation: Location;\n  historyAction: HistoryAction;\n}) => boolean;\n\ninterface ShortCircuitable {\n  /**\n   * startNavigation does not need to complete the navigation because we\n   * redirected or got interrupted\n   */\n  shortCircuited?: boolean;\n}\n\ninterface HandleActionResult extends ShortCircuitable {\n  /**\n   * Error thrown from the current action, keyed by the route containing the\n   * error boundary to render the error.  To be committed to the state after\n   * loaders have completed\n   */\n  pendingActionError?: RouteData;\n  /**\n   * Data returned from the current action, keyed by the route owning the action.\n   * To be committed to the state after loaders have completed\n   */\n  pendingActionData?: RouteData;\n}\n\ninterface HandleLoadersResult extends ShortCircuitable {\n  /**\n   * loaderData returned from the current set of loaders\n   */\n  loaderData?: RouterState[\"loaderData\"];\n  /**\n   * errors thrown from the current set of loaders\n   */\n  errors?: RouterState[\"errors\"];\n}\n\n/**\n * Cached info for active fetcher.load() instances so they can participate\n * in revalidation\n */\ninterface FetchLoadMatch {\n  routeId: string;\n  path: string;\n}\n\n/**\n * Identified fetcher.load() calls that need to be revalidated\n */\ninterface RevalidatingFetcher extends FetchLoadMatch {\n  key: string;\n  match: AgnosticDataRouteMatch | null;\n  matches: AgnosticDataRouteMatch[] | null;\n  controller: AbortController | null;\n}\n\n/**\n * Wrapper object to allow us to throw any response out from callLoaderOrAction\n * for queryRouter while preserving whether or not it was thrown or returned\n * from the loader/action\n */\ninterface QueryRouteResponse {\n  type: ResultType.data | ResultType.error;\n  response: Response;\n}\n\nconst validMutationMethodsArr: MutationFormMethod[] = [\n  \"post\",\n  \"put\",\n  \"patch\",\n  \"delete\",\n];\nconst validMutationMethods = new Set<MutationFormMethod>(\n  validMutationMethodsArr\n);\n\nconst validRequestMethodsArr: FormMethod[] = [\n  \"get\",\n  ...validMutationMethodsArr,\n];\nconst validRequestMethods = new Set<FormMethod>(validRequestMethodsArr);\n\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst redirectPreserveMethodStatusCodes = new Set([307, 308]);\n\nexport const IDLE_NAVIGATION: NavigationStates[\"Idle\"] = {\n  state: \"idle\",\n  location: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined,\n};\n\nexport const IDLE_FETCHER: FetcherStates[\"Idle\"] = {\n  state: \"idle\",\n  data: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined,\n};\n\nexport const IDLE_BLOCKER: BlockerUnblocked = {\n  state: \"unblocked\",\n  proceed: undefined,\n  reset: undefined,\n  location: undefined,\n};\n\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n\nconst defaultMapRouteProperties: MapRoutePropertiesFunction = (route) => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary),\n});\n\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Create a router and listen to history POP navigations\n */\nexport function createRouter(init: RouterInit): Router {\n  const routerWindow = init.window\n    ? init.window\n    : typeof window !== \"undefined\"\n    ? window\n    : undefined;\n  const isBrowser =\n    typeof routerWindow !== \"undefined\" &&\n    typeof routerWindow.document !== \"undefined\" &&\n    typeof routerWindow.document.createElement !== \"undefined\";\n  const isServer = !isBrowser;\n\n  invariant(\n    init.routes.length > 0,\n    \"You must provide a non-empty routes array to createRouter\"\n  );\n\n  let mapRouteProperties: MapRoutePropertiesFunction;\n  if (init.mapRouteProperties) {\n    mapRouteProperties = init.mapRouteProperties;\n  } else if (init.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = init.detectErrorBoundary;\n    mapRouteProperties = (route) => ({\n      hasErrorBoundary: detectErrorBoundary(route),\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n\n  // Routes keyed by ID\n  let manifest: RouteManifest = {};\n  // Routes in tree format for matching\n  let dataRoutes = convertRoutesToDataRoutes(\n    init.routes,\n    mapRouteProperties,\n    undefined,\n    manifest\n  );\n  let inFlightDataRoutes: AgnosticDataRouteObject[] | undefined;\n  let basename = init.basename || \"/\";\n  // Config driven behavior flags\n  let future: FutureConfig = {\n    v7_normalizeFormMethod: false,\n    v7_prependBasename: false,\n    ...init.future,\n  };\n  // Cleanup function for history\n  let unlistenHistory: (() => void) | null = null;\n  // Externally-provided functions to call on all state changes\n  let subscribers = new Set<RouterSubscriber>();\n  // Externally-provided object to hold scroll restoration locations during routing\n  let savedScrollPositions: Record<string, number> | null = null;\n  // Externally-provided function to get scroll restoration keys\n  let getScrollRestorationKey: GetScrollRestorationKeyFunction | null = null;\n  // Externally-provided function to get current scroll position\n  let getScrollPosition: GetScrollPositionFunction | null = null;\n  // One-time flag to control the initial hydration scroll restoration.  Because\n  // we don't get the saved positions from <ScrollRestoration /> until _after_\n  // the initial render, we need to manually trigger a separate updateState to\n  // send along the restoreScrollPosition\n  // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n  // SSR did the initial scroll restoration.\n  let initialScrollRestored = init.hydrationData != null;\n\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialErrors: RouteData | null = null;\n\n  if (initialMatches == null) {\n    // If we do not match a user-provided-route, fall back to the root\n    // to allow the error boundary to take over\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname,\n    });\n    let { matches, route } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = { [route.id]: error };\n  }\n\n  let initialized =\n    // All initialMatches need to be loaded before we're ready.  If we have lazy\n    // functions around still then we'll need to run them in initialize()\n    !initialMatches.some((m) => m.route.lazy) &&\n    // And we have to either have no loaders or have been provided hydrationData\n    (!initialMatches.some((m) => m.route.loader) || init.hydrationData != null);\n\n  let router: Router;\n  let state: RouterState = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: (init.hydrationData && init.hydrationData.loaderData) || {},\n    actionData: (init.hydrationData && init.hydrationData.actionData) || null,\n    errors: (init.hydrationData && init.hydrationData.errors) || initialErrors,\n    fetchers: new Map(),\n    blockers: new Map(),\n  };\n\n  // -- Stateful internal variables to manage navigations --\n  // Current navigation in progress (to be committed in completeNavigation)\n  let pendingAction: HistoryAction = HistoryAction.Pop;\n\n  // Should the current navigation prevent the scroll reset if scroll cannot\n  // be restored?\n  let pendingPreventScrollReset = false;\n\n  // AbortController for the active navigation\n  let pendingNavigationController: AbortController | null;\n\n  // We use this to avoid touching history in completeNavigation if a\n  // revalidation is entirely uninterrupted\n  let isUninterruptedRevalidation = false;\n\n  // Use this internal flag to force revalidation of all loaders:\n  //  - submissions (completed or interrupted)\n  //  - useRevalidator()\n  //  - X-Remix-Revalidate (from redirect)\n  let isRevalidationRequired = false;\n\n  // Use this internal array to capture routes that require revalidation due\n  // to a cancelled deferred on action submission\n  let cancelledDeferredRoutes: string[] = [];\n\n  // Use this internal array to capture fetcher loads that were cancelled by an\n  // action navigation and require revalidation\n  let cancelledFetcherLoads: string[] = [];\n\n  // AbortControllers for any in-flight fetchers\n  let fetchControllers = new Map<string, AbortController>();\n\n  // Track loads based on the order in which they started\n  let incrementingLoadId = 0;\n\n  // Track the outstanding pending navigation data load to be compared against\n  // the globally incrementing load when a fetcher load lands after a completed\n  // navigation\n  let pendingNavigationLoadId = -1;\n\n  // Fetchers that triggered data reloads as a result of their actions\n  let fetchReloadIds = new Map<string, number>();\n\n  // Fetchers that triggered redirect navigations\n  let fetchRedirectIds = new Set<string>();\n\n  // Most recent href/match for fetcher.load calls for fetchers\n  let fetchLoadMatches = new Map<string, FetchLoadMatch>();\n\n  // Store DeferredData instances for active route matches.  When a\n  // route loader returns defer() we stick one in here.  Then, when a nested\n  // promise resolves we update loaderData.  If a new navigation starts we\n  // cancel active deferreds for eliminated routes.\n  let activeDeferreds = new Map<string, DeferredData>();\n\n  // Store blocker functions in a separate Map outside of router state since\n  // we don't need to update UI state if they change\n  let blockerFunctions = new Map<string, BlockerFunction>();\n\n  // Flag to ignore the next history update, so we can revert the URL change on\n  // a POP navigation that was blocked by the user without touching router state\n  let ignoreNextHistoryUpdate = false;\n\n  // Initialize the router, all side effects should be kicked off from here.\n  // Implemented as a Fluent API for ease of:\n  //   let router = createRouter(init).initialize();\n  function initialize() {\n    // If history informs us of a POP navigation, start the navigation but do not update\n    // state.  We'll update our own state once the navigation completes\n    unlistenHistory = init.history.listen(\n      ({ action: historyAction, location, delta }) => {\n        // Ignore this event if it was just us resetting the URL from a\n        // blocked POP navigation\n        if (ignoreNextHistoryUpdate) {\n          ignoreNextHistoryUpdate = false;\n          return;\n        }\n\n        warning(\n          blockerFunctions.size === 0 || delta != null,\n          \"You are trying to use a blocker on a POP navigation to a location \" +\n            \"that was not created by @remix-run/router. This will fail silently in \" +\n            \"production. This can happen if you are navigating outside the router \" +\n            \"via `window.history.pushState`/`window.location.hash` instead of using \" +\n            \"router navigation APIs.  This can also happen if you are using \" +\n            \"createHashRouter and the user manually changes the URL.\"\n        );\n\n        let blockerKey = shouldBlockNavigation({\n          currentLocation: state.location,\n          nextLocation: location,\n          historyAction,\n        });\n\n        if (blockerKey && delta != null) {\n          // Restore the URL to match the current UI, but don't update router state\n          ignoreNextHistoryUpdate = true;\n          init.history.go(delta * -1);\n\n          // Put the blocker into a blocked state\n          updateBlocker(blockerKey, {\n            state: \"blocked\",\n            location,\n            proceed() {\n              updateBlocker(blockerKey!, {\n                state: \"proceeding\",\n                proceed: undefined,\n                reset: undefined,\n                location,\n              });\n              // Re-do the same POP navigation we just blocked\n              init.history.go(delta);\n            },\n            reset() {\n              let blockers = new Map(state.blockers);\n              blockers.set(blockerKey!, IDLE_BLOCKER);\n              updateState({ blockers });\n            },\n          });\n          return;\n        }\n\n        return startNavigation(historyAction, location);\n      }\n    );\n\n    // Kick off initial data load if needed.  Use Pop to avoid modifying history\n    // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n    // in the normal navigation flow.  For SSR it's expected that lazy modules are\n    // resolved prior to router creation since we can't go into a fallbackElement\n    // UI for SSR'd apps\n    if (!state.initialized) {\n      startNavigation(HistoryAction.Pop, state.location);\n    }\n\n    return router;\n  }\n\n  // Clean up a router and it's side effects\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n\n  // Subscribe to state updates for the router\n  function subscribe(fn: RouterSubscriber) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n\n  // Update our state and notify the calling context of the change\n  function updateState(newState: Partial<RouterState>): void {\n    state = {\n      ...state,\n      ...newState,\n    };\n    subscribers.forEach((subscriber) => subscriber(state));\n  }\n\n  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n  // and setting state.[historyAction/location/matches] to the new route.\n  // - Location is a required param\n  // - Navigation will always be set to IDLE_NAVIGATION\n  // - Can pass any other state in newState\n  function completeNavigation(\n    location: Location,\n    newState: Partial<Omit<RouterState, \"action\" | \"location\" | \"navigation\">>\n  ): void {\n    // Deduce if we're in a loading/actionReload state:\n    // - We have committed actionData in the store\n    // - The current navigation was a mutation submission\n    // - We're past the submitting state and into the loading state\n    // - The location being loaded is not the result of a redirect\n    let isActionReload =\n      state.actionData != null &&\n      state.navigation.formMethod != null &&\n      isMutationMethod(state.navigation.formMethod) &&\n      state.navigation.state === \"loading\" &&\n      location.state?._isRedirect !== true;\n\n    let actionData: RouteData | null;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        // Empty actionData -> clear prior actionData due to an action error\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      // Keep the current data if we're wrapping up the action reload\n      actionData = state.actionData;\n    } else {\n      // Clear actionData on any other completed navigations\n      actionData = null;\n    }\n\n    // Always preserve any existing loaderData from re-used routes\n    let loaderData = newState.loaderData\n      ? mergeLoaderData(\n          state.loaderData,\n          newState.loaderData,\n          newState.matches || [],\n          newState.errors\n        )\n      : state.loaderData;\n\n    // On a successful navigation we can assume we got through all blockers\n    // so we can start fresh\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n\n    // Always respect the user flag.  Otherwise don't reset on mutation\n    // submission navigations unless they redirect\n    let preventScrollReset =\n      pendingPreventScrollReset === true ||\n      (state.navigation.formMethod != null &&\n        isMutationMethod(state.navigation.formMethod) &&\n        location.state?._isRedirect !== true);\n\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = undefined;\n    }\n\n    if (isUninterruptedRevalidation) {\n      // If this was an uninterrupted revalidation then do not touch history\n    } else if (pendingAction === HistoryAction.Pop) {\n      // Do nothing for POP - URL has already been updated\n    } else if (pendingAction === HistoryAction.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === HistoryAction.Replace) {\n      init.history.replace(location, location.state);\n    }\n\n    updateState({\n      ...newState, // matches, errors, fetchers go through as-is\n      actionData,\n      loaderData,\n      historyAction: pendingAction,\n      location,\n      initialized: true,\n      navigation: IDLE_NAVIGATION,\n      revalidation: \"idle\",\n      restoreScrollPosition: getSavedScrollPosition(\n        location,\n        newState.matches || state.matches\n      ),\n      preventScrollReset,\n      blockers,\n    });\n\n    // Reset stateful navigation vars\n    pendingAction = HistoryAction.Pop;\n    pendingPreventScrollReset = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n\n  // Trigger a navigation event, which can either be a numerical POP or a PUSH\n  // replace with an optional submission\n  async function navigate(\n    to: number | To | null,\n    opts?: RouterNavigateOptions\n  ): Promise<void> {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n\n    let normalizedPath = normalizeTo(\n      state.location,\n      state.matches,\n      basename,\n      future.v7_prependBasename,\n      to,\n      opts?.fromRouteId,\n      opts?.relative\n    );\n    let { path, submission, error } = normalizeNavigateOptions(\n      future.v7_normalizeFormMethod,\n      false,\n      normalizedPath,\n      opts\n    );\n\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n\n    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n    // URL from window.location, so we need to encode it here so the behavior\n    // remains the same as POP and non-data-router usages.  new URL() does all\n    // the same encoding we'd get from a history.pushState/window.location read\n    // without having to touch history\n    nextLocation = {\n      ...nextLocation,\n      ...init.history.encodeLocation(nextLocation),\n    };\n\n    let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n\n    let historyAction = HistoryAction.Push;\n\n    if (userReplace === true) {\n      historyAction = HistoryAction.Replace;\n    } else if (userReplace === false) {\n      // no-op\n    } else if (\n      submission != null &&\n      isMutationMethod(submission.formMethod) &&\n      submission.formAction === state.location.pathname + state.location.search\n    ) {\n      // By default on submissions to the current location we REPLACE so that\n      // users don't have to double-click the back button to get to the prior\n      // location.  If the user redirects to a different location from the\n      // action/loader this will be ignored and the redirect will be a PUSH\n      historyAction = HistoryAction.Replace;\n    }\n\n    let preventScrollReset =\n      opts && \"preventScrollReset\" in opts\n        ? opts.preventScrollReset === true\n        : undefined;\n\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction,\n    });\n\n    if (blockerKey) {\n      // Put the blocker into a blocked state\n      updateBlocker(blockerKey, {\n        state: \"blocked\",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey!, {\n            state: \"proceeding\",\n            proceed: undefined,\n            reset: undefined,\n            location: nextLocation,\n          });\n          // Send the same navigation through\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey!, IDLE_BLOCKER);\n          updateState({ blockers });\n        },\n      });\n      return;\n    }\n\n    return await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n    });\n  }\n\n  // Revalidate all current loaders.  If a navigation is in progress or if this\n  // is interrupted by a navigation, allow this to \"succeed\" by calling all\n  // loaders during the next loader round\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({ revalidation: \"loading\" });\n\n    // If we're currently submitting an action, we don't need to start a new\n    // navigation, we'll just let the follow up loader execution call all loaders\n    if (state.navigation.state === \"submitting\") {\n      return;\n    }\n\n    // If we're currently in an idle state, start a new navigation for the current\n    // action/location and mark it as uninterrupted, which will skip the history\n    // update in completeNavigation\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true,\n      });\n      return;\n    }\n\n    // Otherwise, if we're currently in a loading state, just start a new\n    // navigation to the navigation.location but do not trigger an uninterrupted\n    // revalidation so that history correctly updates once the navigation completes\n    startNavigation(\n      pendingAction || state.historyAction,\n      state.navigation.location,\n      { overrideNavigation: state.navigation }\n    );\n  }\n\n  // Start a navigation to the given action/location.  Can optionally provide a\n  // overrideNavigation which will override the normalLoad in the case of a redirect\n  // navigation\n  async function startNavigation(\n    historyAction: HistoryAction,\n    location: Location,\n    opts?: {\n      submission?: Submission;\n      fetcherSubmission?: Submission;\n      overrideNavigation?: Navigation;\n      pendingError?: ErrorResponse;\n      startUninterruptedRevalidation?: boolean;\n      preventScrollReset?: boolean;\n      replace?: boolean;\n    }\n  ): Promise<void> {\n    // Abort any in-progress navigations and start a new one. Unset any ongoing\n    // uninterrupted revalidations unless told otherwise, since we want this\n    // new navigation to update history normally\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation =\n      (opts && opts.startUninterruptedRevalidation) === true;\n\n    // Save the current scroll position every time we start a new navigation,\n    // and track whether we should reset scroll on completion\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(routesToUse, location, basename);\n\n    // Short circuit with a 404 on the root error boundary if we match nothing\n    if (!matches) {\n      let error = getInternalRouterError(404, { pathname: location.pathname });\n      let { matches: notFoundMatches, route } =\n        getShortCircuitMatches(routesToUse);\n      // Cancel all pending deferred on 404s since we don't keep any routes\n      cancelActiveDeferreds();\n      completeNavigation(location, {\n        matches: notFoundMatches,\n        loaderData: {},\n        errors: {\n          [route.id]: error,\n        },\n      });\n      return;\n    }\n\n    // Short circuit if it's only a hash change and not a revalidation or\n    // mutation submission.\n    //\n    // Ignore on initial page loads because since the initial load will always\n    // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n    // which will default to a navigation to /page\n    if (\n      state.initialized &&\n      !isRevalidationRequired &&\n      isHashChangeOnly(state.location, location) &&\n      !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))\n    ) {\n      completeNavigation(location, { matches });\n      return;\n    }\n\n    // Create a controller/Request for this navigation\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(\n      init.history,\n      location,\n      pendingNavigationController.signal,\n      opts && opts.submission\n    );\n    let pendingActionData: RouteData | undefined;\n    let pendingError: RouteData | undefined;\n\n    if (opts && opts.pendingError) {\n      // If we have a pendingError, it means the user attempted a GET submission\n      // with binary FormData so assign here and skip to handleLoaders.  That\n      // way we handle calling loaders above the boundary etc.  It's not really\n      // different from an actionError in that sense.\n      pendingError = {\n        [findNearestBoundary(matches).route.id]: opts.pendingError,\n      };\n    } else if (\n      opts &&\n      opts.submission &&\n      isMutationMethod(opts.submission.formMethod)\n    ) {\n      // Call action if we received an action submission\n      let actionOutput = await handleAction(\n        request,\n        location,\n        opts.submission,\n        matches,\n        { replace: opts.replace }\n      );\n\n      if (actionOutput.shortCircuited) {\n        return;\n      }\n\n      pendingActionData = actionOutput.pendingActionData;\n      pendingError = actionOutput.pendingActionError;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n\n      // Create a GET request for the loaders\n      request = new Request(request.url, { signal: request.signal });\n    }\n\n    // Call loaders\n    let { shortCircuited, loaderData, errors } = await handleLoaders(\n      request,\n      location,\n      matches,\n      loadingNavigation,\n      opts && opts.submission,\n      opts && opts.fetcherSubmission,\n      opts && opts.replace,\n      pendingActionData,\n      pendingError\n    );\n\n    if (shortCircuited) {\n      return;\n    }\n\n    // Clean up now that the action/loaders have completed.  Don't clean up if\n    // we short circuited because pendingNavigationController will have already\n    // been assigned to a new controller for the next navigation\n    pendingNavigationController = null;\n\n    completeNavigation(location, {\n      matches,\n      ...(pendingActionData ? { actionData: pendingActionData } : {}),\n      loaderData,\n      errors,\n    });\n  }\n\n  // Call the action matched by the leaf route for this navigation and handle\n  // redirects/errors\n  async function handleAction(\n    request: Request,\n    location: Location,\n    submission: Submission,\n    matches: AgnosticDataRouteMatch[],\n    opts: { replace?: boolean } = {}\n  ): Promise<HandleActionResult> {\n    interruptActiveLoads();\n\n    // Put us in a submitting state\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({ navigation });\n\n    // Call our action and get the result\n    let result: DataResult;\n    let actionMatch = getTargetMatch(matches, location);\n\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: ResultType.error,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id,\n        }),\n      };\n    } else {\n      result = await callLoaderOrAction(\n        \"action\",\n        request,\n        actionMatch,\n        matches,\n        manifest,\n        mapRouteProperties,\n        basename\n      );\n\n      if (request.signal.aborted) {\n        return { shortCircuited: true };\n      }\n    }\n\n    if (isRedirectResult(result)) {\n      let replace: boolean;\n      if (opts && opts.replace != null) {\n        replace = opts.replace;\n      } else {\n        // If the user didn't explicity indicate replace behavior, replace if\n        // we redirected to the exact same location we're currently at to avoid\n        // double back-buttons\n        replace =\n          result.location === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(state, result, { submission, replace });\n      return { shortCircuited: true };\n    }\n\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n\n      // By default, all submissions are REPLACE navigations, but if the\n      // action threw an error that'll be rendered in an errorElement, we fall\n      // back to PUSH so that the user can use the back button to get back to\n      // the pre-submission form location to try again\n      if ((opts && opts.replace) !== true) {\n        pendingAction = HistoryAction.Push;\n      }\n\n      return {\n        // Send back an empty object we can use to clear out any prior actionData\n        pendingActionData: {},\n        pendingActionError: { [boundaryMatch.route.id]: result.error },\n      };\n    }\n\n    if (isDeferredResult(result)) {\n      throw getInternalRouterError(400, { type: \"defer-action\" });\n    }\n\n    return {\n      pendingActionData: { [actionMatch.route.id]: result.data },\n    };\n  }\n\n  // Call all applicable loaders for the given matches, handling redirects,\n  // errors, etc.\n  async function handleLoaders(\n    request: Request,\n    location: Location,\n    matches: AgnosticDataRouteMatch[],\n    overrideNavigation?: Navigation,\n    submission?: Submission,\n    fetcherSubmission?: Submission,\n    replace?: boolean,\n    pendingActionData?: RouteData,\n    pendingError?: RouteData\n  ): Promise<HandleLoadersResult> {\n    // Figure out the right navigation we want to use for data loading\n    let loadingNavigation =\n      overrideNavigation || getLoadingNavigation(location, submission);\n\n    // If this was a redirect from an action we don't have a \"submission\" but\n    // we have it on the loading navigation so use that if available\n    let activeSubmission =\n      submission ||\n      fetcherSubmission ||\n      getSubmissionFromNavigation(loadingNavigation);\n\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      init.history,\n      state,\n      matches,\n      activeSubmission,\n      location,\n      isRevalidationRequired,\n      cancelledDeferredRoutes,\n      cancelledFetcherLoads,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      pendingActionData,\n      pendingError\n    );\n\n    // Cancel pending deferreds for no-longer-matched routes or routes we're\n    // about to reload.  Note that if this is an action reload we would have\n    // already cancelled all pending deferreds so this would be a no-op\n    cancelActiveDeferreds(\n      (routeId) =>\n        !(matches && matches.some((m) => m.route.id === routeId)) ||\n        (matchesToLoad && matchesToLoad.some((m) => m.route.id === routeId))\n    );\n\n    pendingNavigationLoadId = ++incrementingLoadId;\n\n    // Short circuit if we have no loaders to run\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      let updatedFetchers = markFetchRedirectsDone();\n      completeNavigation(location, {\n        matches,\n        loaderData: {},\n        // Commit pending error if we're short circuiting\n        errors: pendingError || null,\n        ...(pendingActionData ? { actionData: pendingActionData } : {}),\n        ...(updatedFetchers ? { fetchers: new Map(state.fetchers) } : {}),\n      });\n      return { shortCircuited: true };\n    }\n\n    // If this is an uninterrupted revalidation, we remain in our current idle\n    // state.  If not, we need to switch to our loading state and load data,\n    // preserving any new action data or existing action data (in the case of\n    // a revalidation interrupting an actionReload)\n    if (!isUninterruptedRevalidation) {\n      revalidatingFetchers.forEach((rf) => {\n        let fetcher = state.fetchers.get(rf.key);\n        let revalidatingFetcher = getLoadingFetcher(\n          undefined,\n          fetcher ? fetcher.data : undefined\n        );\n        state.fetchers.set(rf.key, revalidatingFetcher);\n      });\n      let actionData = pendingActionData || state.actionData;\n      updateState({\n        navigation: loadingNavigation,\n        ...(actionData\n          ? Object.keys(actionData).length === 0\n            ? { actionData: null }\n            : { actionData }\n          : {}),\n        ...(revalidatingFetchers.length > 0\n          ? { fetchers: new Map(state.fetchers) }\n          : {}),\n      });\n    }\n\n    revalidatingFetchers.forEach((rf) => {\n      if (fetchControllers.has(rf.key)) {\n        abortFetcher(rf.key);\n      }\n      if (rf.controller) {\n        // Fetchers use an independent AbortController so that aborting a fetcher\n        // (via deleteFetcher) does not abort the triggering navigation that\n        // triggered the revalidation\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n\n    // Proxy navigation abort through to revalidation fetchers\n    let abortPendingFetchRevalidations = () =>\n      revalidatingFetchers.forEach((f) => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener(\n        \"abort\",\n        abortPendingFetchRevalidations\n      );\n    }\n\n    let { results, loaderResults, fetcherResults } =\n      await callLoadersAndMaybeResolveData(\n        state.matches,\n        matches,\n        matchesToLoad,\n        revalidatingFetchers,\n        request\n      );\n\n    if (request.signal.aborted) {\n      return { shortCircuited: true };\n    }\n\n    // Clean up _after_ loaders have completed.  Don't clean up if we short\n    // circuited because fetchControllers would have been aborted and\n    // reassigned to new controllers for the next navigation\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener(\n        \"abort\",\n        abortPendingFetchRevalidations\n      );\n    }\n    revalidatingFetchers.forEach((rf) => fetchControllers.delete(rf.key));\n\n    // If any loaders returned a redirect Response, start a new REPLACE navigation\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey =\n          revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      await startRedirectNavigation(state, redirect.result, { replace });\n      return { shortCircuited: true };\n    }\n\n    // Process and commit output from loaders\n    let { loaderData, errors } = processLoaderData(\n      state,\n      matches,\n      matchesToLoad,\n      loaderResults,\n      pendingError,\n      revalidatingFetchers,\n      fetcherResults,\n      activeDeferreds\n    );\n\n    // Wire up subscribers to update loaderData as promises settle\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe((aborted) => {\n        // Note: No need to updateState here since the TrackedPromise on\n        // loaderData is stable across resolve/reject\n        // Remove this instance if we were aborted or if promises have settled\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers =\n      updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n\n    return {\n      loaderData,\n      errors,\n      ...(shouldUpdateFetchers ? { fetchers: new Map(state.fetchers) } : {}),\n    };\n  }\n\n  function getFetcher<TData = any>(key: string): Fetcher<TData> {\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n\n  // Trigger a fetcher load/submit for the given fetcher key\n  function fetch(\n    key: string,\n    routeId: string,\n    href: string | null,\n    opts?: RouterFetchOptions\n  ) {\n    if (isServer) {\n      throw new Error(\n        \"router.fetch() was called during the server render, but it shouldn't be. \" +\n          \"You are likely calling a useFetcher() method in the body of your component. \" +\n          \"Try moving it to a useEffect or a callback.\"\n      );\n    }\n\n    if (fetchControllers.has(key)) abortFetcher(key);\n\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(\n      state.location,\n      state.matches,\n      basename,\n      future.v7_prependBasename,\n      href,\n      routeId,\n      opts?.relative\n    );\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n\n    if (!matches) {\n      setFetcherError(\n        key,\n        routeId,\n        getInternalRouterError(404, { pathname: normalizedPath })\n      );\n      return;\n    }\n\n    let { path, submission, error } = normalizeNavigateOptions(\n      future.v7_normalizeFormMethod,\n      true,\n      normalizedPath,\n      opts\n    );\n\n    if (error) {\n      setFetcherError(key, routeId, error);\n      return;\n    }\n\n    let match = getTargetMatch(matches, path);\n\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(key, routeId, path, match, matches, submission);\n      return;\n    }\n\n    // Store off the match so we can call it's shouldRevalidate on subsequent\n    // revalidations\n    fetchLoadMatches.set(key, { routeId, path });\n    handleFetcherLoader(key, routeId, path, match, matches, submission);\n  }\n\n  // Call the action for the matched fetcher.submit(), and then handle redirects,\n  // errors, and revalidation\n  async function handleFetcherAction(\n    key: string,\n    routeId: string,\n    path: string,\n    match: AgnosticDataRouteMatch,\n    requestMatches: AgnosticDataRouteMatch[],\n    submission: Submission\n  ) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n\n    if (!match.route.action && !match.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId: routeId,\n      });\n      setFetcherError(key, routeId, error);\n      return;\n    }\n\n    // Put this fetcher into it's submitting state\n    let existingFetcher = state.fetchers.get(key);\n    let fetcher = getSubmittingFetcher(submission, existingFetcher);\n    state.fetchers.set(key, fetcher);\n    updateState({ fetchers: new Map(state.fetchers) });\n\n    // Call the action for the fetcher\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      init.history,\n      path,\n      abortController.signal,\n      submission\n    );\n    fetchControllers.set(key, abortController);\n\n    let originatingLoadId = incrementingLoadId;\n    let actionResult = await callLoaderOrAction(\n      \"action\",\n      fetchRequest,\n      match,\n      requestMatches,\n      manifest,\n      mapRouteProperties,\n      basename\n    );\n\n    if (fetchRequest.signal.aborted) {\n      // We can delete this so long as we weren't aborted by ou our own fetcher\n      // re-submit which would have put _new_ controller is in fetchControllers\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n\n    if (isRedirectResult(actionResult)) {\n      fetchControllers.delete(key);\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our action started, so that\n        // should take precedence over this redirect navigation.  We already\n        // set isRevalidationRequired so all loaders for the new route should\n        // fire unless opted out via shouldRevalidate\n        let doneFetcher = getDoneFetcher(undefined);\n        state.fetchers.set(key, doneFetcher);\n        updateState({ fetchers: new Map(state.fetchers) });\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        let loadingFetcher = getLoadingFetcher(submission);\n        state.fetchers.set(key, loadingFetcher);\n        updateState({ fetchers: new Map(state.fetchers) });\n\n        return startRedirectNavigation(state, actionResult, {\n          submission,\n          isFetchActionRedirect: true,\n        });\n      }\n    }\n\n    // Process any non-redirect errors thrown\n    if (isErrorResult(actionResult)) {\n      setFetcherError(key, routeId, actionResult.error);\n      return;\n    }\n\n    if (isDeferredResult(actionResult)) {\n      throw getInternalRouterError(400, { type: \"defer-action\" });\n    }\n\n    // Start the data load for current matches, or the next location if we're\n    // in the middle of a navigation\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(\n      init.history,\n      nextLocation,\n      abortController.signal\n    );\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches =\n      state.navigation.state !== \"idle\"\n        ? matchRoutes(routesToUse, state.navigation.location, basename)\n        : state.matches;\n\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(\n      init.history,\n      state,\n      matches,\n      submission,\n      nextLocation,\n      isRevalidationRequired,\n      cancelledDeferredRoutes,\n      cancelledFetcherLoads,\n      fetchLoadMatches,\n      fetchRedirectIds,\n      routesToUse,\n      basename,\n      { [match.route.id]: actionResult.data },\n      undefined // No need to send through errors since we short circuit above\n    );\n\n    // Put all revalidating fetchers into the loading state, except for the\n    // current fetcher which we want to keep in it's current loading state which\n    // contains it's action submission info + action data\n    revalidatingFetchers\n      .filter((rf) => rf.key !== key)\n      .forEach((rf) => {\n        let staleKey = rf.key;\n        let existingFetcher = state.fetchers.get(staleKey);\n        let revalidatingFetcher = getLoadingFetcher(\n          undefined,\n          existingFetcher ? existingFetcher.data : undefined\n        );\n        state.fetchers.set(staleKey, revalidatingFetcher);\n        if (fetchControllers.has(staleKey)) {\n          abortFetcher(staleKey);\n        }\n        if (rf.controller) {\n          fetchControllers.set(staleKey, rf.controller);\n        }\n      });\n\n    updateState({ fetchers: new Map(state.fetchers) });\n\n    let abortPendingFetchRevalidations = () =>\n      revalidatingFetchers.forEach((rf) => abortFetcher(rf.key));\n\n    abortController.signal.addEventListener(\n      \"abort\",\n      abortPendingFetchRevalidations\n    );\n\n    let { results, loaderResults, fetcherResults } =\n      await callLoadersAndMaybeResolveData(\n        state.matches,\n        matches,\n        matchesToLoad,\n        revalidatingFetchers,\n        revalidationRequest\n      );\n\n    if (abortController.signal.aborted) {\n      return;\n    }\n\n    abortController.signal.removeEventListener(\n      \"abort\",\n      abortPendingFetchRevalidations\n    );\n\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach((r) => fetchControllers.delete(r.key));\n\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey =\n          revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      return startRedirectNavigation(state, redirect.result);\n    }\n\n    // Process and commit output from loaders\n    let { loaderData, errors } = processLoaderData(\n      state,\n      state.matches,\n      matchesToLoad,\n      loaderResults,\n      undefined,\n      revalidatingFetchers,\n      fetcherResults,\n      activeDeferreds\n    );\n\n    // Since we let revalidations complete even if the submitting fetcher was\n    // deleted, only put it back to idle if it hasn't been deleted\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n\n    let didAbortFetchLoads = abortStaleFetchLoads(loadId);\n\n    // If we are currently in a navigation loading state and this fetcher is\n    // more recent than the navigation, we want the newer data so abort the\n    // navigation and complete it with the fetcher data\n    if (\n      state.navigation.state === \"loading\" &&\n      loadId > pendingNavigationLoadId\n    ) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers),\n      });\n    } else {\n      // otherwise just update with the fetcher data, preserving any existing\n      // loaderData for loaders that did not need to reload.  We have to\n      // manually merge here since we aren't going through completeNavigation\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(\n          state.loaderData,\n          loaderData,\n          matches,\n          errors\n        ),\n        ...(didAbortFetchLoads || revalidatingFetchers.length > 0\n          ? { fetchers: new Map(state.fetchers) }\n          : {}),\n      });\n      isRevalidationRequired = false;\n    }\n  }\n\n  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n  async function handleFetcherLoader(\n    key: string,\n    routeId: string,\n    path: string,\n    match: AgnosticDataRouteMatch,\n    matches: AgnosticDataRouteMatch[],\n    submission?: Submission\n  ) {\n    let existingFetcher = state.fetchers.get(key);\n    // Put this fetcher into it's loading state\n    let loadingFetcher = getLoadingFetcher(\n      submission,\n      existingFetcher ? existingFetcher.data : undefined\n    );\n    state.fetchers.set(key, loadingFetcher);\n    updateState({ fetchers: new Map(state.fetchers) });\n\n    // Call the loader for this fetcher route match\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(\n      init.history,\n      path,\n      abortController.signal\n    );\n    fetchControllers.set(key, abortController);\n\n    let originatingLoadId = incrementingLoadId;\n    let result: DataResult = await callLoaderOrAction(\n      \"loader\",\n      fetchRequest,\n      match,\n      matches,\n      manifest,\n      mapRouteProperties,\n      basename\n    );\n\n    // Deferred isn't supported for fetcher loads, await everything and treat it\n    // as a normal load.  resolveDeferredData will return undefined if this\n    // fetcher gets aborted, so we just leave result untouched and short circuit\n    // below if that happens\n    if (isDeferredResult(result)) {\n      result =\n        (await resolveDeferredData(result, fetchRequest.signal, true)) ||\n        result;\n    }\n\n    // We can delete this so long as we weren't aborted by our our own fetcher\n    // re-load which would have put _new_ controller is in fetchControllers\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n\n    // If the loader threw a redirect Response, start a new REPLACE navigation\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our loader started, so that\n        // should take precedence over this redirect navigation\n        let doneFetcher = getDoneFetcher(undefined);\n        state.fetchers.set(key, doneFetcher);\n        updateState({ fetchers: new Map(state.fetchers) });\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(state, result);\n        return;\n      }\n    }\n\n    // Process any non-redirect errors thrown\n    if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, routeId);\n      state.fetchers.delete(key);\n      // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -\n      // do we need to behave any differently with our non-redirect errors?\n      // What if it was a non-redirect Response?\n      updateState({\n        fetchers: new Map(state.fetchers),\n        errors: {\n          [boundaryMatch.route.id]: result.error,\n        },\n      });\n      return;\n    }\n\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n\n    // Put the fetcher back into an idle state\n    let doneFetcher = getDoneFetcher(result.data);\n    state.fetchers.set(key, doneFetcher);\n    updateState({ fetchers: new Map(state.fetchers) });\n  }\n\n  /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */\n  async function startRedirectNavigation(\n    state: RouterState,\n    redirect: RedirectResult,\n    {\n      submission,\n      replace,\n      isFetchActionRedirect,\n    }: {\n      submission?: Submission;\n      replace?: boolean;\n      isFetchActionRedirect?: boolean;\n    } = {}\n  ) {\n    if (redirect.revalidate) {\n      isRevalidationRequired = true;\n    }\n\n    let redirectLocation = createLocation(\n      state.location,\n      redirect.location,\n      // TODO: This can be removed once we get rid of useTransition in Remix v2\n      {\n        _isRedirect: true,\n        ...(isFetchActionRedirect ? { _isFetchActionRedirect: true } : {}),\n      }\n    );\n    invariant(\n      redirectLocation,\n      \"Expected a location on the redirect navigation\"\n    );\n    // Check if this an absolute external redirect that goes to a new origin\n    if (ABSOLUTE_URL_REGEX.test(redirect.location) && isBrowser) {\n      let url = init.history.createURL(redirect.location);\n      let isDifferentBasename = stripBasename(url.pathname, basename) == null;\n\n      if (routerWindow.location.origin !== url.origin || isDifferentBasename) {\n        if (replace) {\n          routerWindow.location.replace(redirect.location);\n        } else {\n          routerWindow.location.assign(redirect.location);\n        }\n        return;\n      }\n    }\n\n    // There's no need to abort on redirects, since we don't detect the\n    // redirect until the action/loaders have settled\n    pendingNavigationController = null;\n\n    let redirectHistoryAction =\n      replace === true ? HistoryAction.Replace : HistoryAction.Push;\n\n    // Use the incoming submission if provided, fallback on the active one in\n    // state.navigation\n    let activeSubmission =\n      submission || getSubmissionFromNavigation(state.navigation);\n\n    // If this was a 307/308 submission we want to preserve the HTTP method and\n    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n    // redirected location\n    if (\n      redirectPreserveMethodStatusCodes.has(redirect.status) &&\n      activeSubmission &&\n      isMutationMethod(activeSubmission.formMethod)\n    ) {\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        submission: {\n          ...activeSubmission,\n          formAction: redirect.location,\n        },\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset,\n      });\n    } else if (isFetchActionRedirect) {\n      // For a fetch action redirect, we kick off a new loading navigation\n      // without the fetcher submission, but we send it along for shouldRevalidate\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation: getLoadingNavigation(redirectLocation),\n        fetcherSubmission: activeSubmission,\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset,\n      });\n    } else {\n      // If we have a submission, we will preserve it through the redirect navigation\n      let overrideNavigation = getLoadingNavigation(\n        redirectLocation,\n        activeSubmission\n      );\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation,\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset,\n      });\n    }\n  }\n\n  async function callLoadersAndMaybeResolveData(\n    currentMatches: AgnosticDataRouteMatch[],\n    matches: AgnosticDataRouteMatch[],\n    matchesToLoad: AgnosticDataRouteMatch[],\n    fetchersToLoad: RevalidatingFetcher[],\n    request: Request\n  ) {\n    // Call all navigation loaders and revalidating fetcher loaders in parallel,\n    // then slice off the results into separate arrays so we can handle them\n    // accordingly\n    let results = await Promise.all([\n      ...matchesToLoad.map((match) =>\n        callLoaderOrAction(\n          \"loader\",\n          request,\n          match,\n          matches,\n          manifest,\n          mapRouteProperties,\n          basename\n        )\n      ),\n      ...fetchersToLoad.map((f) => {\n        if (f.matches && f.match && f.controller) {\n          return callLoaderOrAction(\n            \"loader\",\n            createClientSideRequest(init.history, f.path, f.controller.signal),\n            f.match,\n            f.matches,\n            manifest,\n            mapRouteProperties,\n            basename\n          );\n        } else {\n          let error: ErrorResult = {\n            type: ResultType.error,\n            error: getInternalRouterError(404, { pathname: f.path }),\n          };\n          return error;\n        }\n      }),\n    ]);\n    let loaderResults = results.slice(0, matchesToLoad.length);\n    let fetcherResults = results.slice(matchesToLoad.length);\n\n    await Promise.all([\n      resolveDeferredResults(\n        currentMatches,\n        matchesToLoad,\n        loaderResults,\n        loaderResults.map(() => request.signal),\n        false,\n        state.loaderData\n      ),\n      resolveDeferredResults(\n        currentMatches,\n        fetchersToLoad.map((f) => f.match),\n        fetcherResults,\n        fetchersToLoad.map((f) => (f.controller ? f.controller.signal : null)),\n        true\n      ),\n    ]);\n\n    return { results, loaderResults, fetcherResults };\n  }\n\n  function interruptActiveLoads() {\n    // Every interruption triggers a revalidation\n    isRevalidationRequired = true;\n\n    // Cancel pending route-level deferreds and mark cancelled routes for\n    // revalidation\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n\n    // Abort in-flight fetcher loads\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n\n  function setFetcherError(key: string, routeId: string, error: any) {\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState({\n      errors: {\n        [boundaryMatch.route.id]: error,\n      },\n      fetchers: new Map(state.fetchers),\n    });\n  }\n\n  function deleteFetcher(key: string): void {\n    let fetcher = state.fetchers.get(key);\n    // Don't abort the controller if this is a deletion of a fetcher.submit()\n    // in it's loading phase since - we don't want to abort the corresponding\n    // revalidation and want them to complete and land\n    if (\n      fetchControllers.has(key) &&\n      !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))\n    ) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    state.fetchers.delete(key);\n  }\n\n  function abortFetcher(key: string) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, `Expected fetch controller: ${key}`);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n\n  function markFetchersDone(keys: string[]) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n\n  function markFetchRedirectsDone(): boolean {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, `Expected fetcher: ${key}`);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n\n  function abortStaleFetchLoads(landedId: number): boolean {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, `Expected fetcher: ${key}`);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n\n  function getBlocker(key: string, fn: BlockerFunction) {\n    let blocker: Blocker = state.blockers.get(key) || IDLE_BLOCKER;\n\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n\n    return blocker;\n  }\n\n  function deleteBlocker(key: string) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n\n  // Utility function to update blockers, ensuring valid state transitions\n  function updateBlocker(key: string, newBlocker: Blocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n\n    // Poor mans state machine :)\n    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n    invariant(\n      (blocker.state === \"unblocked\" && newBlocker.state === \"blocked\") ||\n        (blocker.state === \"blocked\" && newBlocker.state === \"blocked\") ||\n        (blocker.state === \"blocked\" && newBlocker.state === \"proceeding\") ||\n        (blocker.state === \"blocked\" && newBlocker.state === \"unblocked\") ||\n        (blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\"),\n      `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`\n    );\n\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({ blockers });\n  }\n\n  function shouldBlockNavigation({\n    currentLocation,\n    nextLocation,\n    historyAction,\n  }: {\n    currentLocation: Location;\n    nextLocation: Location;\n    historyAction: HistoryAction;\n  }): string | undefined {\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n\n    // We ony support a single active blocker at the moment since we don't have\n    // any compelling use cases for multi-blocker yet\n    if (blockerFunctions.size > 1) {\n      warning(false, \"A router only supports one blocker at a time\");\n    }\n\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n\n    if (blocker && blocker.state === \"proceeding\") {\n      // If the blocker is currently proceeding, we don't need to re-check\n      // it and can let this navigation continue\n      return;\n    }\n\n    // At this point, we know we're unblocked/blocked so we need to check the\n    // user-provided blocker function\n    if (blockerFunction({ currentLocation, nextLocation, historyAction })) {\n      return blockerKey;\n    }\n  }\n\n  function cancelActiveDeferreds(\n    predicate?: (routeId: string) => boolean\n  ): string[] {\n    let cancelledRouteIds: string[] = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        // Cancel the deferred - but do not remove from activeDeferreds here -\n        // we rely on the subscribers to do that so our tests can assert proper\n        // cleanup via _internalActiveDeferreds\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n\n  // Opt in to capturing and reporting scroll positions during navigations,\n  // used by the <ScrollRestoration> component\n  function enableScrollRestoration(\n    positions: Record<string, number>,\n    getPosition: GetScrollPositionFunction,\n    getKey?: GetScrollRestorationKeyFunction\n  ) {\n    savedScrollPositions = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || null;\n\n    // Perform initial hydration scroll restoration, since we miss the boat on\n    // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n    // and therefore have no savedScrollPositions available\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({ restoreScrollPosition: y });\n      }\n    }\n\n    return () => {\n      savedScrollPositions = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n\n  function getScrollKey(location: Location, matches: AgnosticDataRouteMatch[]) {\n    if (getScrollRestorationKey) {\n      let key = getScrollRestorationKey(\n        location,\n        matches.map((m) => createUseMatchesMatch(m, state.loaderData))\n      );\n      return key || location.key;\n    }\n    return location.key;\n  }\n\n  function saveScrollPosition(\n    location: Location,\n    matches: AgnosticDataRouteMatch[]\n  ): void {\n    if (savedScrollPositions && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions[key] = getScrollPosition();\n    }\n  }\n\n  function getSavedScrollPosition(\n    location: Location,\n    matches: AgnosticDataRouteMatch[]\n  ): number | null {\n    if (savedScrollPositions) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n\n  function _internalSetRoutes(newRoutes: AgnosticDataRouteObject[]) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(\n      newRoutes,\n      mapRouteProperties,\n      undefined,\n      manifest\n    );\n  }\n\n  router = {\n    get basename() {\n      return basename;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: (to: To) => init.history.createHref(to),\n    encodeLocation: (to: To) => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes,\n  };\n\n  return router;\n}\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\n\nexport const UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\n\nexport interface CreateStaticHandlerOptions {\n  basename?: string;\n  /**\n   * @deprecated Use `mapRouteProperties` instead\n   */\n  detectErrorBoundary?: DetectErrorBoundaryFunction;\n  mapRouteProperties?: MapRoutePropertiesFunction;\n}\n\nexport function createStaticHandler(\n  routes: AgnosticRouteObject[],\n  opts?: CreateStaticHandlerOptions\n): StaticHandler {\n  invariant(\n    routes.length > 0,\n    \"You must provide a non-empty routes array to createStaticHandler\"\n  );\n\n  let manifest: RouteManifest = {};\n  let basename = (opts ? opts.basename : null) || \"/\";\n  let mapRouteProperties: MapRoutePropertiesFunction;\n  if (opts?.mapRouteProperties) {\n    mapRouteProperties = opts.mapRouteProperties;\n  } else if (opts?.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = opts.detectErrorBoundary;\n    mapRouteProperties = (route) => ({\n      hasErrorBoundary: detectErrorBoundary(route),\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n\n  let dataRoutes = convertRoutesToDataRoutes(\n    routes,\n    mapRouteProperties,\n    undefined,\n    manifest\n  );\n\n  /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */\n  async function query(\n    request: Request,\n    { requestContext }: { requestContext?: unknown } = {}\n  ): Promise<StaticHandlerContext | Response> {\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\") {\n      let error = getInternalRouterError(405, { method });\n      let { matches: methodNotAllowedMatches, route } =\n        getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error,\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null,\n      };\n    } else if (!matches) {\n      let error = getInternalRouterError(404, { pathname: location.pathname });\n      let { matches: notFoundMatches, route } =\n        getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error,\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null,\n      };\n    }\n\n    let result = await queryImpl(request, location, matches, requestContext);\n    if (isResponse(result)) {\n      return result;\n    }\n\n    // When returning StaticHandlerContext, we patch back in the location here\n    // since we need it for React Context.  But this helps keep our submit and\n    // loadRouteData operating on a Request instead of a Location\n    return { location, basename, ...result };\n  }\n\n  /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */\n  async function queryRoute(\n    request: Request,\n    {\n      routeId,\n      requestContext,\n    }: { requestContext?: unknown; routeId?: string } = {}\n  ): Promise<any> {\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n      throw getInternalRouterError(405, { method });\n    } else if (!matches) {\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n\n    let match = routeId\n      ? matches.find((m) => m.route.id === routeId)\n      : getTargetMatch(matches, location);\n\n    if (routeId && !match) {\n      throw getInternalRouterError(403, {\n        pathname: location.pathname,\n        routeId,\n      });\n    } else if (!match) {\n      // This should never hit I don't think?\n      throw getInternalRouterError(404, { pathname: location.pathname });\n    }\n\n    let result = await queryImpl(\n      request,\n      location,\n      matches,\n      requestContext,\n      match\n    );\n    if (isResponse(result)) {\n      return result;\n    }\n\n    let error = result.errors ? Object.values(result.errors)[0] : undefined;\n    if (error !== undefined) {\n      // If we got back result.errors, that means the loader/action threw\n      // _something_ that wasn't a Response, but it's not guaranteed/required\n      // to be an `instanceof Error` either, so we have to use throw here to\n      // preserve the \"error\" state outside of queryImpl.\n      throw error;\n    }\n\n    // Pick off the right state value to return\n    if (result.actionData) {\n      return Object.values(result.actionData)[0];\n    }\n\n    if (result.loaderData) {\n      let data = Object.values(result.loaderData)[0];\n      if (result.activeDeferreds?.[match.route.id]) {\n        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n      }\n      return data;\n    }\n\n    return undefined;\n  }\n\n  async function queryImpl(\n    request: Request,\n    location: Location,\n    matches: AgnosticDataRouteMatch[],\n    requestContext: unknown,\n    routeMatch?: AgnosticDataRouteMatch\n  ): Promise<Omit<StaticHandlerContext, \"location\" | \"basename\"> | Response> {\n    invariant(\n      request.signal,\n      \"query()/queryRoute() requests must contain an AbortController signal\"\n    );\n\n    try {\n      if (isMutationMethod(request.method.toLowerCase())) {\n        let result = await submit(\n          request,\n          matches,\n          routeMatch || getTargetMatch(matches, location),\n          requestContext,\n          routeMatch != null\n        );\n        return result;\n      }\n\n      let result = await loadRouteData(\n        request,\n        matches,\n        requestContext,\n        routeMatch\n      );\n      return isResponse(result)\n        ? result\n        : {\n            ...result,\n            actionData: null,\n            actionHeaders: {},\n          };\n    } catch (e) {\n      // If the user threw/returned a Response in callLoaderOrAction, we throw\n      // it to bail out and then return or throw here based on whether the user\n      // returned or threw\n      if (isQueryRouteResponse(e)) {\n        if (e.type === ResultType.error && !isRedirectResponse(e.response)) {\n          throw e.response;\n        }\n        return e.response;\n      }\n      // Redirects are always returned since they don't propagate to catch\n      // boundaries\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n\n  async function submit(\n    request: Request,\n    matches: AgnosticDataRouteMatch[],\n    actionMatch: AgnosticDataRouteMatch,\n    requestContext: unknown,\n    isRouteRequest: boolean\n  ): Promise<Omit<StaticHandlerContext, \"location\" | \"basename\"> | Response> {\n    let result: DataResult;\n\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: actionMatch.route.id,\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error,\n      };\n    } else {\n      result = await callLoaderOrAction(\n        \"action\",\n        request,\n        actionMatch,\n        matches,\n        manifest,\n        mapRouteProperties,\n        basename,\n        { isStaticRequest: true, isRouteRequest, requestContext }\n      );\n\n      if (request.signal.aborted) {\n        let method = isRouteRequest ? \"queryRoute\" : \"query\";\n        throw new Error(`${method}() call aborted`);\n      }\n    }\n\n    if (isRedirectResult(result)) {\n      // Uhhhh - this should never happen, we should always throw these from\n      // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n      // can get back on the \"throw all redirect responses\" train here should\n      // this ever happen :/\n      throw new Response(null, {\n        status: result.status,\n        headers: {\n          Location: result.location,\n        },\n      });\n    }\n\n    if (isDeferredResult(result)) {\n      let error = getInternalRouterError(400, { type: \"defer-action\" });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error,\n      };\n    }\n\n    if (isRouteRequest) {\n      // Note: This should only be non-Response values if we get here, since\n      // isRouteRequest should throw any Response received in callLoaderOrAction\n      if (isErrorResult(result)) {\n        throw result.error;\n      }\n\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: { [actionMatch.route.id]: result.data },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null,\n      };\n    }\n\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      let context = await loadRouteData(\n        request,\n        matches,\n        requestContext,\n        undefined,\n        {\n          [boundaryMatch.route.id]: result.error,\n        }\n      );\n\n      // action status codes take precedence over loader status codes\n      return {\n        ...context,\n        statusCode: isRouteErrorResponse(result.error)\n          ? result.error.status\n          : 500,\n        actionData: null,\n        actionHeaders: {\n          ...(result.headers ? { [actionMatch.route.id]: result.headers } : {}),\n        },\n      };\n    }\n\n    // Create a GET request for the loaders\n    let loaderRequest = new Request(request.url, {\n      headers: request.headers,\n      redirect: request.redirect,\n      signal: request.signal,\n    });\n    let context = await loadRouteData(loaderRequest, matches, requestContext);\n\n    return {\n      ...context,\n      // action status codes take precedence over loader status codes\n      ...(result.statusCode ? { statusCode: result.statusCode } : {}),\n      actionData: {\n        [actionMatch.route.id]: result.data,\n      },\n      actionHeaders: {\n        ...(result.headers ? { [actionMatch.route.id]: result.headers } : {}),\n      },\n    };\n  }\n\n  async function loadRouteData(\n    request: Request,\n    matches: AgnosticDataRouteMatch[],\n    requestContext: unknown,\n    routeMatch?: AgnosticDataRouteMatch,\n    pendingActionError?: RouteData\n  ): Promise<\n    | Omit<\n        StaticHandlerContext,\n        \"location\" | \"basename\" | \"actionData\" | \"actionHeaders\"\n      >\n    | Response\n  > {\n    let isRouteRequest = routeMatch != null;\n\n    // Short circuit if we have no loaders to run (queryRoute())\n    if (\n      isRouteRequest &&\n      !routeMatch?.route.loader &&\n      !routeMatch?.route.lazy\n    ) {\n      throw getInternalRouterError(400, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: routeMatch?.route.id,\n      });\n    }\n\n    let requestMatches = routeMatch\n      ? [routeMatch]\n      : getLoaderMatchesUntilBoundary(\n          matches,\n          Object.keys(pendingActionError || {})[0]\n        );\n    let matchesToLoad = requestMatches.filter(\n      (m) => m.route.loader || m.route.lazy\n    );\n\n    // Short circuit if we have no loaders to run (query())\n    if (matchesToLoad.length === 0) {\n      return {\n        matches,\n        // Add a null for all matched routes for proper revalidation on the client\n        loaderData: matches.reduce(\n          (acc, m) => Object.assign(acc, { [m.route.id]: null }),\n          {}\n        ),\n        errors: pendingActionError || null,\n        statusCode: 200,\n        loaderHeaders: {},\n        activeDeferreds: null,\n      };\n    }\n\n    let results = await Promise.all([\n      ...matchesToLoad.map((match) =>\n        callLoaderOrAction(\n          \"loader\",\n          request,\n          match,\n          matches,\n          manifest,\n          mapRouteProperties,\n          basename,\n          { isStaticRequest: true, isRouteRequest, requestContext }\n        )\n      ),\n    ]);\n\n    if (request.signal.aborted) {\n      let method = isRouteRequest ? \"queryRoute\" : \"query\";\n      throw new Error(`${method}() call aborted`);\n    }\n\n    // Process and commit output from loaders\n    let activeDeferreds = new Map<string, DeferredData>();\n    let context = processRouteLoaderData(\n      matches,\n      matchesToLoad,\n      results,\n      pendingActionError,\n      activeDeferreds\n    );\n\n    // Add a null for any non-loader matches for proper revalidation on the client\n    let executedLoaders = new Set<string>(\n      matchesToLoad.map((match) => match.route.id)\n    );\n    matches.forEach((match) => {\n      if (!executedLoaders.has(match.route.id)) {\n        context.loaderData[match.route.id] = null;\n      }\n    });\n\n    return {\n      ...context,\n      matches,\n      activeDeferreds:\n        activeDeferreds.size > 0\n          ? Object.fromEntries(activeDeferreds.entries())\n          : null,\n    };\n  }\n\n  return {\n    dataRoutes,\n    query,\n    queryRoute,\n  };\n}\n\n//#endregion\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */\nexport function getStaticContextFromError(\n  routes: AgnosticDataRouteObject[],\n  context: StaticHandlerContext,\n  error: any\n) {\n  let newContext: StaticHandlerContext = {\n    ...context,\n    statusCode: 500,\n    errors: {\n      [context._deepestRenderedBoundaryId || routes[0].id]: error,\n    },\n  };\n  return newContext;\n}\n\nfunction isSubmissionNavigation(\n  opts: RouterNavigateOptions\n): opts is SubmissionNavigateOptions {\n  return (\n    opts != null &&\n    ((\"formData\" in opts && opts.formData != null) ||\n      (\"body\" in opts && opts.body !== undefined))\n  );\n}\n\nfunction normalizeTo(\n  location: Path,\n  matches: AgnosticDataRouteMatch[],\n  basename: string,\n  prependBasename: boolean,\n  to: To | null,\n  fromRouteId?: string,\n  relative?: RelativeRoutingType\n) {\n  let contextualMatches: AgnosticDataRouteMatch[];\n  let activeRouteMatch: AgnosticDataRouteMatch | undefined;\n  if (fromRouteId != null && relative !== \"path\") {\n    // Grab matches up to the calling route so our route-relative logic is\n    // relative to the correct source route.  When using relative:path,\n    // fromRouteId is ignored since that is always relative to the current\n    // location path\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n\n  // Resolve the relative path\n  let path = resolveTo(\n    to ? to : \".\",\n    getPathContributingMatches(contextualMatches).map((m) => m.pathnameBase),\n    stripBasename(location.pathname, basename) || location.pathname,\n    relative === \"path\"\n  );\n\n  // When `to` is not specified we inherit search/hash from the current\n  // location, unlike when to=\".\" and we just inherit the path.\n  // See https://github.com/remix-run/remix/issues/927\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n\n  // Add an ?index param for matched index routes if we don't already have one\n  if (\n    (to == null || to === \"\" || to === \".\") &&\n    activeRouteMatch &&\n    activeRouteMatch.route.index &&\n    !hasNakedIndexQuery(path.search)\n  ) {\n    path.search = path.search\n      ? path.search.replace(/^\\?/, \"?index&\")\n      : \"?index\";\n  }\n\n  // If we're operating within a basename, prepend it to the pathname.  If\n  // this is a root navigation, then just use the raw basename which allows\n  // the basename to have full control over the presence of a trailing slash\n  // on root actions\n  if (prependBasename && basename !== \"/\") {\n    path.pathname =\n      path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n\n  return createPath(path);\n}\n\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(\n  normalizeFormMethod: boolean,\n  isFetcher: boolean,\n  path: string,\n  opts?: RouterNavigateOptions\n): {\n  path: string;\n  submission?: Submission;\n  error?: ErrorResponse;\n} {\n  // Return location verbatim on non-submission navigations\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return { path };\n  }\n\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, { method: opts.formMethod }),\n    };\n  }\n\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, { type: \"invalid-body\" }),\n  });\n\n  // Create a Submission on non-GET navigations\n  let rawFormMethod = opts.formMethod || \"get\";\n  let formMethod = normalizeFormMethod\n    ? (rawFormMethod.toUpperCase() as V7_FormMethod)\n    : (rawFormMethod.toLowerCase() as FormMethod);\n  let formAction = stripHashFromPath(path);\n\n  if (opts.body !== undefined) {\n    if (opts.formEncType === \"text/plain\") {\n      // text only support POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n\n      let text =\n        typeof opts.body === \"string\"\n          ? opts.body\n          : opts.body instanceof FormData ||\n            opts.body instanceof URLSearchParams\n          ? // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n            Array.from(opts.body.entries()).reduce(\n              (acc, [name, value]) => `${acc}${name}=${value}\\n`,\n              \"\"\n            )\n          : String(opts.body);\n\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: undefined,\n          json: undefined,\n          text,\n        },\n      };\n    } else if (opts.formEncType === \"application/json\") {\n      // json only supports POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n\n      try {\n        let json =\n          typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: undefined,\n            json,\n            text: undefined,\n          },\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n\n  invariant(\n    typeof FormData === \"function\",\n    \"FormData is not available in this environment\"\n  );\n\n  let searchParams: URLSearchParams;\n  let formData: FormData;\n\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n\n  let submission: Submission = {\n    formMethod,\n    formAction,\n    formEncType:\n      (opts && opts.formEncType) || \"application/x-www-form-urlencoded\",\n    formData,\n    json: undefined,\n    text: undefined,\n  };\n\n  if (isMutationMethod(submission.formMethod)) {\n    return { path, submission };\n  }\n\n  // Flatten submission onto URLSearchParams for GET submissions\n  let parsedPath = parsePath(path);\n  // On GET navigation submissions we can drop the ?index param from the\n  // resulting location since all loaders will run.  But fetcher GET submissions\n  // only run a single loader so we need to preserve any incoming ?index params\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append(\"index\", \"\");\n  }\n  parsedPath.search = `?${searchParams}`;\n\n  return { path: createPath(parsedPath), submission };\n}\n\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(\n  matches: AgnosticDataRouteMatch[],\n  boundaryId?: string\n) {\n  let boundaryMatches = matches;\n  if (boundaryId) {\n    let index = matches.findIndex((m) => m.route.id === boundaryId);\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\n\nfunction getMatchesToLoad(\n  history: History,\n  state: RouterState,\n  matches: AgnosticDataRouteMatch[],\n  submission: Submission | undefined,\n  location: Location,\n  isRevalidationRequired: boolean,\n  cancelledDeferredRoutes: string[],\n  cancelledFetcherLoads: string[],\n  fetchLoadMatches: Map<string, FetchLoadMatch>,\n  fetchRedirectIds: Set<string>,\n  routesToUse: AgnosticDataRouteObject[],\n  basename: string | undefined,\n  pendingActionData?: RouteData,\n  pendingError?: RouteData\n): [AgnosticDataRouteMatch[], RevalidatingFetcher[]] {\n  let actionResult = pendingError\n    ? Object.values(pendingError)[0]\n    : pendingActionData\n    ? Object.values(pendingActionData)[0]\n    : undefined;\n\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n\n  // Pick navigation matches that are net-new or qualify for revalidation\n  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n\n  let navigationMatches = boundaryMatches.filter((match, index) => {\n    if (match.route.lazy) {\n      // We haven't loaded this route yet so we don't know if it's got a loader!\n      return true;\n    }\n    if (match.route.loader == null) {\n      return false;\n    }\n\n    // Always call the loader on new route instances and pending defer cancellations\n    if (\n      isNewLoader(state.loaderData, state.matches[index], match) ||\n      cancelledDeferredRoutes.some((id) => id === match.route.id)\n    ) {\n      return true;\n    }\n\n    // This is the default implementation for when we revalidate.  If the route\n    // provides it's own implementation, then we give them full control but\n    // provide this value so they can leverage it if needed after they check\n    // their own specific use cases\n    let currentRouteMatch = state.matches[index];\n    let nextRouteMatch = match;\n\n    return shouldRevalidateLoader(match, {\n      currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl,\n      nextParams: nextRouteMatch.params,\n      ...submission,\n      actionResult,\n      defaultShouldRevalidate:\n        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n        isRevalidationRequired ||\n        // Clicked the same link, resubmitted a GET form\n        currentUrl.pathname + currentUrl.search ===\n          nextUrl.pathname + nextUrl.search ||\n        // Search params affect all loaders\n        currentUrl.search !== nextUrl.search ||\n        isNewRouteInstance(currentRouteMatch, nextRouteMatch),\n    });\n  });\n\n  // Pick fetcher.loads that need to be revalidated\n  let revalidatingFetchers: RevalidatingFetcher[] = [];\n  fetchLoadMatches.forEach((f, key) => {\n    // Don't revalidate if fetcher won't be present in the subsequent render\n    if (!matches.some((m) => m.route.id === f.routeId)) {\n      return;\n    }\n\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n\n    // If the fetcher path no longer matches, push it in with null matches so\n    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n    // currently only a use-case for Remix HMR where the route tree can change\n    // at runtime and remove a route previously loaded via a fetcher\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null,\n      });\n      return;\n    }\n\n    // Revalidating fetchers are decoupled from the route matches since they\n    // load from a static href.  They revalidate based on explicit revalidation\n    // (submission, useRevalidator, or X-Remix-Revalidate)\n    let fetcher = state.fetchers.get(key);\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n\n    let shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      // Never trigger a revalidation of an actively redirecting fetcher\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.includes(key)) {\n      // Always revalidate if the fetcher was cancelled\n      shouldRevalidate = true;\n    } else if (\n      fetcher &&\n      fetcher.state !== \"idle\" &&\n      fetcher.data === undefined\n    ) {\n      // If the fetcher hasn't ever completed loading yet, then this isn't a\n      // revalidation, it would just be a brand new load if an explicit\n      // revalidation is required\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n      // to explicit revalidations only\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, {\n        currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl,\n        nextParams: matches[matches.length - 1].params,\n        ...submission,\n        actionResult,\n        defaultShouldRevalidate: isRevalidationRequired,\n      });\n    }\n\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController(),\n      });\n    }\n  });\n\n  return [navigationMatches, revalidatingFetchers];\n}\n\nfunction isNewLoader(\n  currentLoaderData: RouteData,\n  currentMatch: AgnosticDataRouteMatch,\n  match: AgnosticDataRouteMatch\n) {\n  let isNew =\n    // [a] -> [a, b]\n    !currentMatch ||\n    // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id;\n\n  // Handle the case that we don't have data for a re-used route, potentially\n  // from a prior error or from a cancelled pending deferred\n  let isMissingData = currentLoaderData[match.route.id] === undefined;\n\n  // Always load if this is a net-new route or we don't yet have data\n  return isNew || isMissingData;\n}\n\nfunction isNewRouteInstance(\n  currentMatch: AgnosticDataRouteMatch,\n  match: AgnosticDataRouteMatch\n) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname ||\n    // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    (currentPath != null &&\n      currentPath.endsWith(\"*\") &&\n      currentMatch.params[\"*\"] !== match.params[\"*\"])\n  );\n}\n\nfunction shouldRevalidateLoader(\n  loaderMatch: AgnosticDataRouteMatch,\n  arg: Parameters<ShouldRevalidateFunction>[0]\n) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n\n  return arg.defaultShouldRevalidate;\n}\n\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */\nasync function loadLazyRouteModule(\n  route: AgnosticDataRouteObject,\n  mapRouteProperties: MapRoutePropertiesFunction,\n  manifest: RouteManifest\n) {\n  if (!route.lazy) {\n    return;\n  }\n\n  let lazyRoute = await route.lazy();\n\n  // If the lazy route function was executed and removed by another parallel\n  // call then we can return - first lazy() to finish wins because the return\n  // value of lazy is expected to be static\n  if (!route.lazy) {\n    return;\n  }\n\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n\n  // Update the route in place.  This should be safe because there's no way\n  // we could yet be sitting on this route as we can't get there without\n  // resolving lazy() first.\n  //\n  // This is different than the HMR \"update\" use-case where we may actively be\n  // on the route being updated.  The main concern boils down to \"does this\n  // mutation affect any ongoing navigations or any current state.matches\n  // values?\".  If not, it should be safe to update in place.\n  let routeUpdates: Record<string, any> = {};\n  for (let lazyRouteProperty in lazyRoute) {\n    let staticRouteValue =\n      routeToUpdate[lazyRouteProperty as keyof typeof routeToUpdate];\n\n    let isPropertyStaticallyDefined =\n      staticRouteValue !== undefined &&\n      // This property isn't static since it should always be updated based\n      // on the route updates\n      lazyRouteProperty !== \"hasErrorBoundary\";\n\n    warning(\n      !isPropertyStaticallyDefined,\n      `Route \"${routeToUpdate.id}\" has a static property \"${lazyRouteProperty}\" ` +\n        `defined but its lazy function is also returning a value for this property. ` +\n        `The lazy route property \"${lazyRouteProperty}\" will be ignored.`\n    );\n\n    if (\n      !isPropertyStaticallyDefined &&\n      !immutableRouteKeys.has(lazyRouteProperty as ImmutableRouteKey)\n    ) {\n      routeUpdates[lazyRouteProperty] =\n        lazyRoute[lazyRouteProperty as keyof typeof lazyRoute];\n    }\n  }\n\n  // Mutate the route with the provided updates.  Do this first so we pass\n  // the updated version to mapRouteProperties\n  Object.assign(routeToUpdate, routeUpdates);\n\n  // Mutate the `hasErrorBoundary` property on the route based on the route\n  // updates and remove the `lazy` function so we don't resolve the lazy\n  // route again.\n  Object.assign(routeToUpdate, {\n    // To keep things framework agnostic, we use the provided\n    // `mapRouteProperties` (or wrapped `detectErrorBoundary`) function to\n    // set the framework-aware properties (`element`/`hasErrorBoundary`) since\n    // the logic will differ between frameworks.\n    ...mapRouteProperties(routeToUpdate),\n    lazy: undefined,\n  });\n}\n\nasync function callLoaderOrAction(\n  type: \"loader\" | \"action\",\n  request: Request,\n  match: AgnosticDataRouteMatch,\n  matches: AgnosticDataRouteMatch[],\n  manifest: RouteManifest,\n  mapRouteProperties: MapRoutePropertiesFunction,\n  basename: string,\n  opts: {\n    isStaticRequest?: boolean;\n    isRouteRequest?: boolean;\n    requestContext?: unknown;\n  } = {}\n): Promise<DataResult> {\n  let resultType;\n  let result;\n  let onReject: (() => void) | undefined;\n\n  let runHandler = (handler: ActionFunction | LoaderFunction) => {\n    // Setup a promise we can race against so that abort signals short circuit\n    let reject: () => void;\n    let abortPromise = new Promise((_, r) => (reject = r));\n    onReject = () => reject();\n    request.signal.addEventListener(\"abort\", onReject);\n    return Promise.race([\n      handler({\n        request,\n        params: match.params,\n        context: opts.requestContext,\n      }),\n      abortPromise,\n    ]);\n  };\n\n  try {\n    let handler = match.route[type];\n\n    if (match.route.lazy) {\n      if (handler) {\n        // Run statically defined handler in parallel with lazy()\n        let values = await Promise.all([\n          runHandler(handler),\n          loadLazyRouteModule(match.route, mapRouteProperties, manifest),\n        ]);\n        result = values[0];\n      } else {\n        // Load lazy route module, then run any returned handler\n        await loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n\n        handler = match.route[type];\n        if (handler) {\n          // Handler still run even if we got interrupted to maintain consistency\n          // with un-abortable behavior of handler execution on non-lazy or\n          // previously-lazy-loaded routes\n          result = await runHandler(handler);\n        } else if (type === \"action\") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id,\n          });\n        } else {\n          // lazy() route has no loader to run.  Short circuit here so we don't\n          // hit the invariant below that errors on returning undefined.\n          return { type: ResultType.data, data: undefined };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname,\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n\n    invariant(\n      result !== undefined,\n      `You defined ${type === \"action\" ? \"an action\" : \"a loader\"} for route ` +\n        `\"${match.route.id}\" but didn't return anything from your \\`${type}\\` ` +\n        `function. Please return a value or \\`null\\`.`\n    );\n  } catch (e) {\n    resultType = ResultType.error;\n    result = e;\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener(\"abort\", onReject);\n    }\n  }\n\n  if (isResponse(result)) {\n    let status = result.status;\n\n    // Process redirects\n    if (redirectStatusCodes.has(status)) {\n      let location = result.headers.get(\"Location\");\n      invariant(\n        location,\n        \"Redirects returned/thrown from loaders/actions must have a Location header\"\n      );\n\n      // Support relative routing in internal redirects\n      if (!ABSOLUTE_URL_REGEX.test(location)) {\n        location = normalizeTo(\n          new URL(request.url),\n          matches.slice(0, matches.indexOf(match) + 1),\n          basename,\n          true,\n          location\n        );\n      } else if (!opts.isStaticRequest) {\n        // Strip off the protocol+origin for same-origin + same-basename absolute\n        // redirects. If this is a static request, we can let it go back to the\n        // browser as-is\n        let currentUrl = new URL(request.url);\n        let url = location.startsWith(\"//\")\n          ? new URL(currentUrl.protocol + location)\n          : new URL(location);\n        let isSameBasename = stripBasename(url.pathname, basename) != null;\n        if (url.origin === currentUrl.origin && isSameBasename) {\n          location = url.pathname + url.search + url.hash;\n        }\n      }\n\n      // Don't process redirects in the router during static requests requests.\n      // Instead, throw the Response and let the server handle it with an HTTP\n      // redirect.  We also update the Location header in place in this flow so\n      // basename and relative routing is taken into account\n      if (opts.isStaticRequest) {\n        result.headers.set(\"Location\", location);\n        throw result;\n      }\n\n      return {\n        type: ResultType.redirect,\n        status,\n        location,\n        revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null,\n      };\n    }\n\n    // For SSR single-route requests, we want to hand Responses back directly\n    // without unwrapping.  We do this with the QueryRouteResponse wrapper\n    // interface so we can know whether it was returned or thrown\n    if (opts.isRouteRequest) {\n      // eslint-disable-next-line no-throw-literal\n      throw {\n        type: resultType || ResultType.data,\n        response: result,\n      };\n    }\n\n    let data: any;\n    let contentType = result.headers.get(\"Content-Type\");\n    // Check between word boundaries instead of startsWith() due to the last\n    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      data = await result.json();\n    } else {\n      data = await result.text();\n    }\n\n    if (resultType === ResultType.error) {\n      return {\n        type: resultType,\n        error: new ErrorResponse(status, result.statusText, data),\n        headers: result.headers,\n      };\n    }\n\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers,\n    };\n  }\n\n  if (resultType === ResultType.error) {\n    return { type: resultType, error: result };\n  }\n\n  if (isDeferredData(result)) {\n    return {\n      type: ResultType.deferred,\n      deferredData: result,\n      statusCode: result.init?.status,\n      headers: result.init?.headers && new Headers(result.init.headers),\n    };\n  }\n\n  return { type: ResultType.data, data: result };\n}\n\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(\n  history: History,\n  location: string | Location,\n  signal: AbortSignal,\n  submission?: Submission\n): Request {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init: RequestInit = { signal };\n\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let { formMethod, formEncType } = submission;\n    // Didn't think we needed this but it turns out unlike other methods, patch\n    // won't be properly normalized to uppercase and results in a 405 error.\n    // See: https://fetch.spec.whatwg.org/#concept-method\n    init.method = formMethod.toUpperCase();\n\n    if (formEncType === \"application/json\") {\n      init.headers = new Headers({ \"Content-Type\": formEncType });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === \"text/plain\") {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.text;\n    } else if (\n      formEncType === \"application/x-www-form-urlencoded\" &&\n      submission.formData\n    ) {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.formData;\n    }\n  }\n\n  return new Request(url, init);\n}\n\nfunction convertFormDataToSearchParams(formData: FormData): URLSearchParams {\n  let searchParams = new URLSearchParams();\n\n  for (let [key, value] of formData.entries()) {\n    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n  }\n\n  return searchParams;\n}\n\nfunction convertSearchParamsToFormData(\n  searchParams: URLSearchParams\n): FormData {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\n\nfunction processRouteLoaderData(\n  matches: AgnosticDataRouteMatch[],\n  matchesToLoad: AgnosticDataRouteMatch[],\n  results: DataResult[],\n  pendingError: RouteData | undefined,\n  activeDeferreds: Map<string, DeferredData>\n): {\n  loaderData: RouterState[\"loaderData\"];\n  errors: RouterState[\"errors\"] | null;\n  statusCode: number;\n  loaderHeaders: Record<string, Headers>;\n} {\n  // Fill in loaderData/errors from our loaders\n  let loaderData: RouterState[\"loaderData\"] = {};\n  let errors: RouterState[\"errors\"] | null = null;\n  let statusCode: number | undefined;\n  let foundError = false;\n  let loaderHeaders: Record<string, Headers> = {};\n\n  // Process loader results into state.loaderData/state.errors\n  results.forEach((result, index) => {\n    let id = matchesToLoad[index].route.id;\n    invariant(\n      !isRedirectResult(result),\n      \"Cannot handle redirect results in processLoaderData\"\n    );\n    if (isErrorResult(result)) {\n      // Look upwards from the matched route for the closest ancestor\n      // error boundary, defaulting to the root match\n      let boundaryMatch = findNearestBoundary(matches, id);\n      let error = result.error;\n      // If we have a pending action error, we report it at the highest-route\n      // that throws a loader error, and then clear it out to indicate that\n      // it was consumed\n      if (pendingError) {\n        error = Object.values(pendingError)[0];\n        pendingError = undefined;\n      }\n\n      errors = errors || {};\n\n      // Prefer higher error values if lower errors bubble to the same boundary\n      if (errors[boundaryMatch.route.id] == null) {\n        errors[boundaryMatch.route.id] = error;\n      }\n\n      // Clear our any prior loaderData for the throwing route\n      loaderData[id] = undefined;\n\n      // Once we find our first (highest) error, we set the status code and\n      // prevent deeper status codes from overriding\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error)\n          ? result.error.status\n          : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      if (isDeferredResult(result)) {\n        activeDeferreds.set(id, result.deferredData);\n        loaderData[id] = result.deferredData.data;\n      } else {\n        loaderData[id] = result.data;\n      }\n\n      // Error status codes always override success status codes, but if all\n      // loaders are successful we take the deepest status code.\n      if (\n        result.statusCode != null &&\n        result.statusCode !== 200 &&\n        !foundError\n      ) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n\n  // If we didn't consume the pending action error (i.e., all loaders\n  // resolved), then consume it here.  Also clear out any loaderData for the\n  // throwing route\n  if (pendingError) {\n    errors = pendingError;\n    loaderData[Object.keys(pendingError)[0]] = undefined;\n  }\n\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders,\n  };\n}\n\nfunction processLoaderData(\n  state: RouterState,\n  matches: AgnosticDataRouteMatch[],\n  matchesToLoad: AgnosticDataRouteMatch[],\n  results: DataResult[],\n  pendingError: RouteData | undefined,\n  revalidatingFetchers: RevalidatingFetcher[],\n  fetcherResults: DataResult[],\n  activeDeferreds: Map<string, DeferredData>\n): {\n  loaderData: RouterState[\"loaderData\"];\n  errors?: RouterState[\"errors\"];\n} {\n  let { loaderData, errors } = processRouteLoaderData(\n    matches,\n    matchesToLoad,\n    results,\n    pendingError,\n    activeDeferreds\n  );\n\n  // Process results from our revalidating fetchers\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let { key, match, controller } = revalidatingFetchers[index];\n    invariant(\n      fetcherResults !== undefined && fetcherResults[index] !== undefined,\n      \"Did not find corresponding fetcher result\"\n    );\n    let result = fetcherResults[index];\n\n    // Process fetcher non-redirect errors\n    if (controller && controller.signal.aborted) {\n      // Nothing to do for aborted fetchers\n      continue;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = {\n          ...errors,\n          [boundaryMatch.route.id]: result.error,\n        };\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      // Should never get here, redirects should get processed above, but we\n      // keep this to type narrow to a success result in the else\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\n    } else if (isDeferredResult(result)) {\n      // Should never get here, deferred data should be awaited for fetchers\n      // in resolveDeferredResults\n      invariant(false, \"Unhandled fetcher deferred data\");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n\n  return { loaderData, errors };\n}\n\nfunction mergeLoaderData(\n  loaderData: RouteData,\n  newLoaderData: RouteData,\n  matches: AgnosticDataRouteMatch[],\n  errors: RouteData | null | undefined\n): RouteData {\n  let mergedLoaderData = { ...newLoaderData };\n  for (let match of matches) {\n    let id = match.route.id;\n    if (newLoaderData.hasOwnProperty(id)) {\n      if (newLoaderData[id] !== undefined) {\n        mergedLoaderData[id] = newLoaderData[id];\n      } else {\n        // No-op - this is so we ignore existing data if we have a key in the\n        // incoming object with an undefined value, which is how we unset a prior\n        // loaderData if we encounter a loader error\n      }\n    } else if (loaderData[id] !== undefined && match.route.loader) {\n      // Preserve existing keys not included in newLoaderData and where a loader\n      // wasn't removed by HMR\n      mergedLoaderData[id] = loaderData[id];\n    }\n\n    if (errors && errors.hasOwnProperty(id)) {\n      // Don't keep any loader data below the boundary\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\n\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(\n  matches: AgnosticDataRouteMatch[],\n  routeId?: string\n): AgnosticDataRouteMatch {\n  let eligibleMatches = routeId\n    ? matches.slice(0, matches.findIndex((m) => m.route.id === routeId) + 1)\n    : [...matches];\n  return (\n    eligibleMatches.reverse().find((m) => m.route.hasErrorBoundary === true) ||\n    matches[0]\n  );\n}\n\nfunction getShortCircuitMatches(routes: AgnosticDataRouteObject[]): {\n  matches: AgnosticDataRouteMatch[];\n  route: AgnosticDataRouteObject;\n} {\n  // Prefer a root layout route if present, otherwise shim in a route object\n  let route = routes.find((r) => r.index || !r.path || r.path === \"/\") || {\n    id: `__shim-error-route__`,\n  };\n\n  return {\n    matches: [\n      {\n        params: {},\n        pathname: \"\",\n        pathnameBase: \"\",\n        route,\n      },\n    ],\n    route,\n  };\n}\n\nfunction getInternalRouterError(\n  status: number,\n  {\n    pathname,\n    routeId,\n    method,\n    type,\n  }: {\n    pathname?: string;\n    routeId?: string;\n    method?: string;\n    type?: \"defer-action\" | \"invalid-body\";\n  } = {}\n) {\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage =\n        `You made a ${method} request to \"${pathname}\" but ` +\n        `did not provide a \\`loader\\` for route \"${routeId}\", ` +\n        `so there is no way to handle the request.`;\n    } else if (type === \"defer-action\") {\n      errorMessage = \"defer() is not supported in actions\";\n    } else if (type === \"invalid-body\") {\n      errorMessage = \"Unable to encode submission body\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = `Route \"${routeId}\" does not match URL \"${pathname}\"`;\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = `No route matches URL \"${pathname}\"`;\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage =\n        `You made a ${method.toUpperCase()} request to \"${pathname}\" but ` +\n        `did not provide an \\`action\\` for route \"${routeId}\", ` +\n        `so there is no way to handle the request.`;\n    } else if (method) {\n      errorMessage = `Invalid request method \"${method.toUpperCase()}\"`;\n    }\n  }\n\n  return new ErrorResponse(\n    status || 500,\n    statusText,\n    new Error(errorMessage),\n    true\n  );\n}\n\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(\n  results: DataResult[]\n): { result: RedirectResult; idx: number } | undefined {\n  for (let i = results.length - 1; i >= 0; i--) {\n    let result = results[i];\n    if (isRedirectResult(result)) {\n      return { result, idx: i };\n    }\n  }\n}\n\nfunction stripHashFromPath(path: To) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath({ ...parsedPath, hash: \"\" });\n}\n\nfunction isHashChangeOnly(a: Location, b: Location): boolean {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n\n  if (a.hash === \"\") {\n    // /page -> /page#hash\n    return b.hash !== \"\";\n  } else if (a.hash === b.hash) {\n    // /page#hash -> /page#hash\n    return true;\n  } else if (b.hash !== \"\") {\n    // /page#hash -> /page#other\n    return true;\n  }\n\n  // If the hash is removed the browser will re-perform a request to the server\n  // /page#hash -> /page\n  return false;\n}\n\nfunction isDeferredResult(result: DataResult): result is DeferredResult {\n  return result.type === ResultType.deferred;\n}\n\nfunction isErrorResult(result: DataResult): result is ErrorResult {\n  return result.type === ResultType.error;\n}\n\nfunction isRedirectResult(result?: DataResult): result is RedirectResult {\n  return (result && result.type) === ResultType.redirect;\n}\n\nexport function isDeferredData(value: any): value is DeferredData {\n  let deferred: DeferredData = value;\n  return (\n    deferred &&\n    typeof deferred === \"object\" &&\n    typeof deferred.data === \"object\" &&\n    typeof deferred.subscribe === \"function\" &&\n    typeof deferred.cancel === \"function\" &&\n    typeof deferred.resolveData === \"function\"\n  );\n}\n\nfunction isResponse(value: any): value is Response {\n  return (\n    value != null &&\n    typeof value.status === \"number\" &&\n    typeof value.statusText === \"string\" &&\n    typeof value.headers === \"object\" &&\n    typeof value.body !== \"undefined\"\n  );\n}\n\nfunction isRedirectResponse(result: any): result is Response {\n  if (!isResponse(result)) {\n    return false;\n  }\n\n  let status = result.status;\n  let location = result.headers.get(\"Location\");\n  return status >= 300 && status <= 399 && location != null;\n}\n\nfunction isQueryRouteResponse(obj: any): obj is QueryRouteResponse {\n  return (\n    obj &&\n    isResponse(obj.response) &&\n    (obj.type === ResultType.data || ResultType.error)\n  );\n}\n\nfunction isValidMethod(method: string): method is FormMethod | V7_FormMethod {\n  return validRequestMethods.has(method.toLowerCase() as FormMethod);\n}\n\nfunction isMutationMethod(\n  method: string\n): method is MutationFormMethod | V7_MutationFormMethod {\n  return validMutationMethods.has(method.toLowerCase() as MutationFormMethod);\n}\n\nasync function resolveDeferredResults(\n  currentMatches: AgnosticDataRouteMatch[],\n  matchesToLoad: (AgnosticDataRouteMatch | null)[],\n  results: DataResult[],\n  signals: (AbortSignal | null)[],\n  isFetcher: boolean,\n  currentLoaderData?: RouteData\n) {\n  for (let index = 0; index < results.length; index++) {\n    let result = results[index];\n    let match = matchesToLoad[index];\n    // If we don't have a match, then we can have a deferred result to do\n    // anything with.  This is for revalidating fetchers where the route was\n    // removed during HMR\n    if (!match) {\n      continue;\n    }\n\n    let currentMatch = currentMatches.find(\n      (m) => m.route.id === match!.route.id\n    );\n    let isRevalidatingLoader =\n      currentMatch != null &&\n      !isNewRouteInstance(currentMatch, match) &&\n      (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n      // Note: we do not have to touch activeDeferreds here since we race them\n      // against the signal in resolveDeferredData and they'll get aborted\n      // there if needed\n      let signal = signals[index];\n      invariant(\n        signal,\n        \"Expected an AbortSignal for revalidating fetcher deferred result\"\n      );\n      await resolveDeferredData(result, signal, isFetcher).then((result) => {\n        if (result) {\n          results[index] = result || results[index];\n        }\n      });\n    }\n  }\n}\n\nasync function resolveDeferredData(\n  result: DeferredResult,\n  signal: AbortSignal,\n  unwrap = false\n): Promise<SuccessResult | ErrorResult | undefined> {\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData,\n      };\n    } catch (e) {\n      // Handle any TrackedPromise._error values encountered while unwrapping\n      return {\n        type: ResultType.error,\n        error: e,\n      };\n    }\n  }\n\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data,\n  };\n}\n\nfunction hasNakedIndexQuery(search: string): boolean {\n  return new URLSearchParams(search).getAll(\"index\").some((v) => v === \"\");\n}\n\n// Note: This should match the format exported by useMatches, so if you change\n// this please also change that :)  Eventually we'll DRY this up\nfunction createUseMatchesMatch(\n  match: AgnosticDataRouteMatch,\n  loaderData: RouteData\n): UseMatchesMatch {\n  let { route, pathname, params } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id] as unknown,\n    handle: route.handle as unknown,\n  };\n}\n\nfunction getTargetMatch(\n  matches: AgnosticDataRouteMatch[],\n  location: Location | string\n) {\n  let search =\n    typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (\n    matches[matches.length - 1].route.index &&\n    hasNakedIndexQuery(search || \"\")\n  ) {\n    // Return the leaf index route when index is present\n    return matches[matches.length - 1];\n  }\n  // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n  // pathless layout routes)\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\n\nfunction getSubmissionFromNavigation(\n  navigation: Navigation\n): Submission | undefined {\n  let { formMethod, formAction, formEncType, text, formData, json } =\n    navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json: undefined,\n      text,\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: undefined,\n      text: undefined,\n    };\n  } else if (json !== undefined) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json,\n      text: undefined,\n    };\n  }\n}\n\nfunction getLoadingNavigation(\n  location: Location,\n  submission?: Submission\n): NavigationStates[\"Loading\"] {\n  if (submission) {\n    let navigation: NavigationStates[\"Loading\"] = {\n      state: \"loading\",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n    };\n    return navigation;\n  } else {\n    let navigation: NavigationStates[\"Loading\"] = {\n      state: \"loading\",\n      location,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n    };\n    return navigation;\n  }\n}\n\nfunction getSubmittingNavigation(\n  location: Location,\n  submission: Submission\n): NavigationStates[\"Submitting\"] {\n  let navigation: NavigationStates[\"Submitting\"] = {\n    state: \"submitting\",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n  };\n  return navigation;\n}\n\nfunction getLoadingFetcher(\n  submission?: Submission,\n  data?: Fetcher[\"data\"]\n): FetcherStates[\"Loading\"] {\n  if (submission) {\n    let fetcher: FetcherStates[\"Loading\"] = {\n      state: \"loading\",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data,\n      \" _hasFetcherDoneAnything \": true,\n    };\n    return fetcher;\n  } else {\n    let fetcher: FetcherStates[\"Loading\"] = {\n      state: \"loading\",\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n      data,\n      \" _hasFetcherDoneAnything \": true,\n    };\n    return fetcher;\n  }\n}\n\nfunction getSubmittingFetcher(\n  submission: Submission,\n  existingFetcher?: Fetcher\n): FetcherStates[\"Submitting\"] {\n  let fetcher: FetcherStates[\"Submitting\"] = {\n    state: \"submitting\",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : undefined,\n    \" _hasFetcherDoneAnything \": true,\n  };\n  return fetcher;\n}\n\nfunction getDoneFetcher(data: Fetcher[\"data\"]): FetcherStates[\"Idle\"] {\n  let fetcher: FetcherStates[\"Idle\"] = {\n    state: \"idle\",\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined,\n    data,\n    \" _hasFetcherDoneAnything \": true,\n  };\n  return fetcher;\n}\n//#endregion\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$f7ba9b356b6d67df$export$a2e4e2dcc7b1f22f","$f7ba9b356b6d67df$export$1f3f55432a00e06d","$f7ba9b356b6d67df$export$1ba7ed8a3a7b3765","$f7ba9b356b6d67df$export$9ba4e89fdfa1fc54","$f7ba9b356b6d67df$export$7221d69dcfc8e36b","$f7ba9b356b6d67df$export$eefb0c834599897e","$f7ba9b356b6d67df$export$a6c7ac8248d6e38a","$f7ba9b356b6d67df$export$67621102c14d847","$f7ba9b356b6d67df$export$b0d92dbee9b5b60d","$f7ba9b356b6d67df$export$a7fed597f4b8afd8","$f7ba9b356b6d67df$export$47c85c6e3a081d3","$f7ba9b356b6d67df$export$89a6bd6db0d97c56","$f7ba9b356b6d67df$export$11aac1aab828f1fa","$f7ba9b356b6d67df$export$25057cfe5591e3e9","$f7ba9b356b6d67df$export$f1a78c17382fe22a","$f7ba9b356b6d67df$export$5b0d2d9a9921565a","$f7ba9b356b6d67df$export$fa996778a3a31087","$f7ba9b356b6d67df$export$c0a586b329cae57d","$f7ba9b356b6d67df$export$39f4eb3dbd812741","AbortedDeferredError","Await","MemoryRouter","Navigate","Action","Outlet","Route","Router","RouterProvider","Routes","UNSAFE_DataRouterContext","UNSAFE_DataRouterStateContext","UNSAFE_LocationContext","UNSAFE_NavigationContext","UNSAFE_RouteContext","UNSAFE_useRouteId","createMemoryRouter","createPath","createRoutesFromChildren","createRoutesFromElements","defer","generatePath","isRouteErrorResponse","json","matchPath","matchRoutes","parsePath","redirect","renderMatches","resolvePath","unstable_useBlocker","useActionData","useAsyncError","useAsyncValue","useHref","useInRouterContext","useLoaderData","useLocation","useMatch","useMatches","useNavigate","useNavigation","useNavigationType","useOutlet","useOutletContext","useParams","useResolvedPath","useRevalidator","useRouteError","useRouteLoaderData","useRoutes","DataRouterHook","DataRouterStateHook","$f7ba9b356b6d67df$var$DataRouterHook","$f7ba9b356b6d67df$var$DataRouterStateHook","$5kUFm","$8wGzW","$bZ2h6","$f7ba9b356b6d67df$var$_extends","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","apply","$f7ba9b356b6d67df$var$_objectWithoutPropertiesLoose","excluded","sourceKeys","keys","indexOf","$f7ba9b356b6d67df$var$defaultEncType","$f7ba9b356b6d67df$var$isHtmlElement","object","tagName","URLSearchParams","Array","isArray","reduce","memo","value","concat","map","$f7ba9b356b6d67df$var$_formDataSupportsSubmitter","$f7ba9b356b6d67df$var$supportedFormEncTypes","Set","$f7ba9b356b6d67df$var$getFormEncType","encType","has","$f7ba9b356b6d67df$var$getFormSubmissionInfo","basename","method","action","formData","body","toLowerCase","attr","getAttribute","stripBasename","FormData","$f7ba9b356b6d67df$var$isButtonElement","$f7ba9b356b6d67df$var$isInputElement","type","form","$f7ba9b356b6d67df$var$isFormDataSubmitterSupported","document","createElement","name","prefix","append","undefined","$f7ba9b356b6d67df$var$_excluded","$f7ba9b356b6d67df$var$_excluded2","$f7ba9b356b6d67df$var$_excluded3","routes","opts","createRouter","future","v7_prependBasename","history","createBrowserHistory","hydrationData","$f7ba9b356b6d67df$var$parseHydrationData","mapRouteProperties","UNSAFE_mapRouteProperties","initialize","createHashHistory","_window","state","__staticRouterHydrationData","errors","$f7ba9b356b6d67df$var$deserializeErrors","entries","serialized","val","__type","ErrorResponse","status","statusText","data","internal","__subType","ErrorConstructor","error","message","stack","$f7ba9b356b6d67df$var$startTransitionImpl","_ref","children","window1","historyRef","useRef","current","v5Compat","setStateImpl","useState","location","v7_startTransition","setState","useCallback","newState","useLayoutEffect","listen","navigationType","navigator","_ref2","_ref3","$f7ba9b356b6d67df$var$isBrowser","$f7ba9b356b6d67df$var$ABSOLUTE_URL_REGEX","forwardRef","_ref4","ref","absoluteHref","onClick","relative","reloadDocument","replace","to","preventScrollReset","rest","useContext","isExternal","test","currentUrl","URL","href","targetUrl","startsWith","protocol","path","pathname","origin","search","hash","internalOnClick","event","defaultPrevented","_ref5","className","ariaCurrentProp","caseSensitive","classNameProp","end","style","styleProp","routerState","toPathname","encodeLocation","locationPathname","nextLocationPathname","navigation","isActive","charAt","isPending","filter","Boolean","join","props","submit","$f7ba9b356b6d67df$var$FormImpl","_ref6","forwardedRef","onSubmit","formMethod","formAction","preventDefault","submitter","nativeEvent","submitMethod","currentTarget","_ref7","getKey","storageKey","$f7ba9b356b6d67df$var$useDataRouterContext","hookName","ctx","UNSAFE_invariant","$f7ba9b356b6d67df$var$useDataRouterState","_temp","replaceProp","navigate","button","metaKey","altKey","ctrlKey","shiftKey","defaultInit","defaultSearchParamsRef","hasSetSearchParamsRef","searchParams","useMemo","$f7ba9b356b6d67df$var$getSearchParamsForLocation","locationSearch","defaultSearchParams","getAll","forEach","setSearchParams","nextInit","navigateOptions","newSearchParams","$f7ba9b356b6d67df$var$validateClientSideSubmission","router","UseSubmit","currentRouteId","options","formEncType","fromRouteId","$f7ba9b356b6d67df$var$useSubmitFetcher","fetcherKey","fetcherRouteId","UseSubmitFetcher","fetch","_temp2","routeContext","match","matches","slice","route","index","params","delete","toString","joinPaths","$f7ba9b356b6d67df$var$fetcherId","_route$matches","UseFetcher","routeId","String","Form","load","fetcher","getFetcher","fetcherWithComponents","useEffect","console","warn","deleteFetcher","UseFetchers","fetchers","values","$f7ba9b356b6d67df$var$SCROLL_RESTORATION_STORAGE_KEY","$f7ba9b356b6d67df$var$savedScrollPositions","_temp3","UseScrollRestoration","restoreScrollPosition","scrollRestoration","$f7ba9b356b6d67df$var$usePageHide","callback","capture","addEventListener","removeEventListener","scrollY","sessionStorage","setItem","JSON","stringify","sessionPositions","getItem","parse","getKeyWithoutBasename","disableScrollRestoration","enableScrollRestoration","scrollTo","el","getElementById","decodeURIComponent","scrollIntoView","_ref8","when","blocker","reset","confirm","setTimeout","proceed","$6352571d8ae2d252$export$3add0d5dce533e2e","$6352571d8ae2d252$export$145dfa71566a64dc","$6352571d8ae2d252$export$26749e8557646306","$6352571d8ae2d252$export$c7914228fb69b0f5","$6352571d8ae2d252$export$9072aa6dd1f93057","$6352571d8ae2d252$export$b66bb29c5006f12f","$6352571d8ae2d252$export$9c954a9d03d32f4a","$6352571d8ae2d252$export$e75d2a2d1b3c245b","$6352571d8ae2d252$export$45d76561a5302f2b","$6352571d8ae2d252$export$1b3f31771c5d07c","$6352571d8ae2d252$export$6c330e8992e8a295","$6352571d8ae2d252$export$9770f232ac06a008","$6352571d8ae2d252$export$4138103a3ae699cc","$6352571d8ae2d252$export$a3be3530d8e40d0b","$6352571d8ae2d252$export$99eaa27ddbbb95ef","$6352571d8ae2d252$export$5d3fca4a98652595","$6352571d8ae2d252$export$ed527bf60f6e05f2","$6352571d8ae2d252$export$5fc8298006ad9e58","$6352571d8ae2d252$export$d0fd4b7106de2769","$6352571d8ae2d252$export$600dc272ed516c15","$6352571d8ae2d252$export$2378eb7f5ff86053","$6352571d8ae2d252$export$1448a5050d252c4d","$6352571d8ae2d252$export$fd5d37484eab868d","$6352571d8ae2d252$export$fdc00f3f26066d5e","$6352571d8ae2d252$export$78a72ddb39bdd145","$6352571d8ae2d252$export$17f53340677d5831","$6352571d8ae2d252$export$2af03a1de5c0910","$6352571d8ae2d252$export$323e4fc2fa4753fb","$6352571d8ae2d252$export$55185c17a0fcbe46","$6352571d8ae2d252$export$ae46f04cfaffe093","$6352571d8ae2d252$export$444b3ab0cb9aec40","$6352571d8ae2d252$export$910ae8079b2c2852","$6352571d8ae2d252$export$e7b0ac011bb776c6","$6352571d8ae2d252$export$3565eb3d00ca5a74","$6352571d8ae2d252$export$16da398f5434bdec","$6352571d8ae2d252$export$6ddabde395c8c576","$6352571d8ae2d252$export$daf73786167a7f72","$6352571d8ae2d252$export$52b333d321859367","$6352571d8ae2d252$export$f30f7e456d254e83","AwaitRenderStatus","$6352571d8ae2d252$var$DataRouterHook","$6352571d8ae2d252$var$DataRouterStateHook","$6352571d8ae2d252$var$AwaitRenderStatus","$6352571d8ae2d252$var$_extends","createContext","$6352571d8ae2d252$var$AwaitContext","outlet","isDataRoute","$6352571d8ae2d252$var$RouteErrorContext","joinedPathname","createHref","pattern","$6352571d8ae2d252$var$useIsomorphicLayoutEffect","cb","static","$6352571d8ae2d252$var$useNavigateStable","$6352571d8ae2d252$var$useDataRouterContext","UseNavigateStable","$6352571d8ae2d252$var$useCurrentRouteId","activeRef","$6352571d8ae2d252$var$useNavigateUnstable","dataRouterContext","routePathnamesJson","UNSAFE_getPathContributingMatches","pathnameBase","go","resolveTo","push","$6352571d8ae2d252$var$OutletContext","context","Provider","routeMatch","locationArg","$6352571d8ae2d252$export$5fcee62552a12fbf","dataRouterState","parentMatches","parentParams","parentPathnameBase","locationFromContext","_parsedLocationArg$pa","parsedLocationArg","remainingPathname","renderedMatches","$6352571d8ae2d252$var$_renderMatches","Pop","$6352571d8ae2d252$var$defaultErrorElement","Fragment","fontStyle","padding","backgroundColor","$6352571d8ae2d252$var$RenderErrorBoundary","Component","getDerivedStateFromError","getDerivedStateFromProps","revalidation","componentDidCatch","errorInfo","render","component","constructor","$6352571d8ae2d252$var$RenderedRoute","staticContext","errorElement","ErrorBoundary","_deepestRenderedBoundaryId","_dataRouterState2","_dataRouterState","errorIndex","findIndex","m","Math","min","reduceRight","getChildren","element","$6352571d8ae2d252$var$useDataRouterState","thisRoute","UseRouteId","UseNavigation","UseRevalidator","revalidate","loaderData","UseMatches","handle","UseLoaderData","UseRouteLoaderData","UseActionData","actionData","_state$errors","UseRouteError","_data","_error","$6352571d8ae2d252$var$blockerId","shouldBlock","UseBlocker","blockerKey","setBlockerKey","blockerFunction","arg","currentLocation","nextLocation","historyAction","deleteBlocker","getBlocker","blockers","IDLE_BLOCKER","$6352571d8ae2d252$var$startTransitionImpl","fallbackElement","subscribe","initialized","$6352571d8ae2d252$var$DataRoutes","initialEntries","initialIndex","createMemoryHistory","jsonPath","_props","basenameProp","locationProp","staticProp","navigationContext","locationContext","trailingPathname","resolve","$6352571d8ae2d252$var$AwaitErrorBoundary","$6352571d8ae2d252$var$ResolveAwait","$6352571d8ae2d252$var$neverSettledPromise","Promise","promise","pending","renderError","reject","catch","_tracked","success","then","toRender","parentPath","Children","isValidElement","treePath","loader","hasErrorBoundary","shouldRevalidate","lazy","updates","$8b9727f4386a7666$export$e19cd5f9376f8cee","$8b9727f4386a7666$var$ResultType","ResultType","$8b9727f4386a7666$var$_extends","$8b9727f4386a7666$export$2b76ad033c6e6d08","$8b9727f4386a7666$export$fe53371bee54353d","$8b9727f4386a7666$export$8ccf933b0513f8d0","$8b9727f4386a7666$export$719fc203c4e16dee","$8b9727f4386a7666$export$b71fdd3798280242","$8b9727f4386a7666$export$3e9cee6b33872309","$8b9727f4386a7666$export$2708184779ceb39d","$8b9727f4386a7666$export$b69e3301ce081aa3","$8b9727f4386a7666$export$86d9a7913e44197e","$8b9727f4386a7666$export$81336c211d5ff295","$8b9727f4386a7666$export$82476f982757e71e","$8b9727f4386a7666$export$b09f2ff0bbcb43c7","$8b9727f4386a7666$export$90ba53ce1c7fdff2","$8b9727f4386a7666$export$cae722b0cc860f13","$8b9727f4386a7666$export$7b419323e6ed4f31","$8b9727f4386a7666$export$42a99a7a4bc0e76a","$8b9727f4386a7666$export$260e5c0943f31606","$8b9727f4386a7666$export$89e12c5b50f7529d","$8b9727f4386a7666$export$acf1a680051f5031","$8b9727f4386a7666$export$972111febbeef05b","$8b9727f4386a7666$export$386d57f03f0b2883","$8b9727f4386a7666$export$baddd0131ee8c05b","$8b9727f4386a7666$var$PopStateEventType","entry","createMemoryLocation","clampIndex","listener","max","$8b9727f4386a7666$var$createLocation","getCurrentLocation","$8b9727f4386a7666$export$c0e02632e14916fd","createURL","Push","splice","delta","Replace","nextIndex","fn","$8b9727f4386a7666$var$getUrlBasedHistory","globalHistory","usr","substr","base","querySelector","url","hashIndex","cond","$8b9727f4386a7666$var$getHistoryState","idx","random","parsedPath","searchIndex","getLocation","validateLocation","defaultView","getIndex","handlePop","replaceState","historyState","pushState","DOMException","$8b9727f4386a7666$var$immutableRouteKeys","$8b9727f4386a7666$export$4a6d22b32134ea5d","manifest","indexRoute","pathOrLayoutRoute","branches","$8b9727f4386a7666$var$flattenRoutes","parentsMeta","flattenRoute","relativePath","segments","initialScore","meta","childrenIndex","routesMeta","score","split","some","$8b9727f4386a7666$var$isSplat","segment","$8b9727f4386a7666$var$paramRe","_route$path","includes","exploded","$8b9727f4386a7666$var$explodeOptionalSegments","first","isOptional","endsWith","required","restExploded","result","subpath","$8b9727f4386a7666$var$rankRouteBranches","sort","a","b","siblings","every","$8b9727f4386a7666$var$matchRouteBranch","branch","matchedParams","matchedPathname","$8b9727f4386a7666$export$a5c6d149b50c1d86","$8b9727f4386a7666$var$safelyDecodeURI","decodeURI","originalPath","p","array","isLastSegment","keyMatch","optional","param","paramNames","regexpSource","matcher","_","paramName","RegExp","captureGroups","splatValue","$8b9727f4386a7666$var$safelyDecodeURIComponent","startIndex","nextChar","fromPathname","relativeSegments","pop","$8b9727f4386a7666$var$normalizeSearch","$8b9727f4386a7666$var$normalizeHash","$8b9727f4386a7666$var$getInvalidPathError","char","field","dest","toArg","routePathnames","isPathRelative","from","isEmptyPath","routePathnameIndex","toSegments","shift","hasExplicitTrailingSlash","hasCurrentTrailingSlash","paths","responseInit","headers","Headers","Response","$8b9727f4386a7666$export$61d759255b4eec65","trackPromise","deferredKeys","pendingKeysSet","add","race","abortPromise","onSettle","controller","signal","aborted","unlistenAbortSignal","done","undefinedError","emit","settledKey","subscribers","subscriber","cancel","abort","k","resolveData","onAbort","size","unwrappedData","acc","$8b9727f4386a7666$var$unwrapTrackedPromise","pendingKeys","r","AbortController","$8b9727f4386a7666$var$validMutationMethodsArr","$8b9727f4386a7666$var$validMutationMethods","$8b9727f4386a7666$var$validRequestMethodsArr","$8b9727f4386a7666$var$validRequestMethods","$8b9727f4386a7666$var$redirectStatusCodes","$8b9727f4386a7666$var$redirectPreserveMethodStatusCodes","$8b9727f4386a7666$export$ed3e14b2f9e105d0","text","$8b9727f4386a7666$export$52eace9c284d3585","$8b9727f4386a7666$var$ABSOLUTE_URL_REGEX","$8b9727f4386a7666$var$defaultMapRouteProperties","inFlightDataRoutes","pendingNavigationController","routerWindow","isBrowser","isServer","detectErrorBoundary","dataRoutes","v7_normalizeFormMethod","unlistenHistory","savedScrollPositions","getScrollRestorationKey","getScrollPosition","initialScrollRestored","initialMatches","initialErrors","$8b9727f4386a7666$var$getInternalRouterError","$8b9727f4386a7666$var$getShortCircuitMatches","Map","pendingAction","pendingPreventScrollReset","isUninterruptedRevalidation","isRevalidationRequired","cancelledDeferredRoutes","cancelledFetcherLoads","fetchControllers","incrementingLoadId","pendingNavigationLoadId","fetchReloadIds","fetchRedirectIds","fetchLoadMatches","activeDeferreds","blockerFunctions","ignoreNextHistoryUpdate","updateState","completeNavigation","_location$state","_location$state2","isActionReload","$8b9727f4386a7666$var$isMutationMethod","_isRedirect","$8b9727f4386a7666$var$mergeLoaderData","getSavedScrollPosition","normalizedPath","$8b9727f4386a7666$var$normalizeTo","submission","$8b9727f4386a7666$var$normalizeNavigateOptions","userReplace","shouldBlockNavigation","updateBlocker","startNavigation","pendingError","pendingActionData","startUninterruptedRevalidation","getScrollKey","routesToUse","loadingNavigation","overrideNavigation","notFoundMatches","cancelActiveDeferreds","request","$8b9727f4386a7666$var$createClientSideRequest","$8b9727f4386a7666$var$findNearestBoundary","actionOutput","handleAction","shortCircuited","pendingActionError","$8b9727f4386a7666$var$getLoadingNavigation","Request","handleLoaders","fetcherSubmission","interruptActiveLoads","actionMatch","$8b9727f4386a7666$var$getTargetMatch","$8b9727f4386a7666$var$callLoaderOrAction","$8b9727f4386a7666$var$isRedirectResult","startRedirectNavigation","$8b9727f4386a7666$var$isErrorResult","boundaryMatch","$8b9727f4386a7666$var$isDeferredResult","activeSubmission","$8b9727f4386a7666$var$getSubmissionFromNavigation","matchesToLoad","revalidatingFetchers","$8b9727f4386a7666$var$getMatchesToLoad","updatedFetchers","markFetchRedirectsDone","rf","revalidatingFetcher","$8b9727f4386a7666$var$getLoadingFetcher","abortFetcher","abortPendingFetchRevalidations","f","results","loaderResults","fetcherResults","callLoadersAndMaybeResolveData","$8b9727f4386a7666$var$findRedirect","$8b9727f4386a7666$var$processLoaderData","deferredData","didAbortFetchLoads","abortStaleFetchLoads","shouldUpdateFetchers","handleFetcherAction","requestMatches","existingFetcher","setFetcherError","abortController","fetchRequest","originatingLoadId","actionResult","doneFetcher","$8b9727f4386a7666$var$getDoneFetcher","loadingFetcher","isFetchActionRedirect","revalidationRequest","loadId","loadFetcher","staleKey","handleFetcherLoader","$8b9727f4386a7666$var$resolveDeferredData","redirectLocation","_isFetchActionRedirect","isDifferentBasename","redirectHistoryAction","currentMatches","fetchersToLoad","all","$8b9727f4386a7666$var$resolveDeferredResults","markFetchersDone","doneKeys","landedId","yeetedKeys","newBlocker","predicate","cancelledRouteIds","dfd","$8b9727f4386a7666$var$createUseMatchesMatch","y","positions","getPosition","dispose","clear","_internalFetchControllers","_internalActiveDeferreds","_internalSetRoutes","newRoutes","prependBasename","contextualMatches","activeRouteMatch","$8b9727f4386a7666$var$hasNakedIndexQuery","normalizeFormMethod","isFetcher","getInvalidBodyError","rawFormMethod","toUpperCase","$8b9727f4386a7666$var$stripHashFromPath","$8b9727f4386a7666$var$convertFormDataToSearchParams","$8b9727f4386a7666$var$convertSearchParamsToFormData","nextUrl","navigationMatches","boundaryMatches","$8b9727f4386a7666$var$getLoaderMatchesUntilBoundary","boundaryId","currentLoaderData","currentMatch","isNew","isMissingData","$8b9727f4386a7666$var$isNewLoader","currentRouteMatch","$8b9727f4386a7666$var$shouldRevalidateLoader","currentParams","nextParams","nextRouteMatch","defaultShouldRevalidate","$8b9727f4386a7666$var$isNewRouteInstance","fetcherMatches","fetcherMatch","currentPath","loaderMatch","routeChoice","$8b9727f4386a7666$var$loadLazyRouteModule","lazyRoute","routeToUpdate","routeUpdates","lazyRouteProperty","isPropertyStaticallyDefined","staticRouteValue","_result$init","_result$init2","resultType","onReject","runHandler","handler","requestContext","isStaticRequest","isSameBasename","isRouteRequest","response","contentType","statusCode","deferred","foundError","loaderHeaders","newLoaderData","mergedLoaderData","eligibleMatches","reverse","find","_temp4","errorMessage","signals","isRevalidatingLoader","unwrap","pathMatches","Symbol","defaultMethod","defaultEncType","isHtmlElement","isButtonElement","isFormElement","isInputElement","isModifiedEvent","shouldProcessLinkClick","createSearchParams","getSearchParamsForLocation","_formDataSupportsSubmitter","isFormDataSubmitterSupported","supportedFormEncTypes","getFormEncType","process","env","NODE_ENV","warning","getFormSubmissionInfo","createBrowserRouter","_extends","parseHydrationData","createHashRouter","deserializeErrors","START_TRANSITION","startTransitionImpl","React","BrowserRouter","HashRouter","HistoryRouter","displayName","ABSOLUTE_URL_REGEX","Link","LinkWithRef","_objectWithoutPropertiesLoose","_excluded","NavigationContext","useLinkClickHandler","handleClick","NavLink","NavLinkWithRef","_excluded2","DataRouterStateContext","ariaCurrent","useSubmit","FormImpl","_excluded3","useFormAction","submitHandler","ScrollRestoration","useScrollRestoration","getDataRouterConsoleError","useDataRouterContext","DataRouterContext","invariant","useDataRouterState","useSearchParams","validateClientSideSubmission","useRouteId","useSubmitFetcher","RouteContext","createFetcherForm","FetcherForm","fetcherId","useFetcher","useFetchers","SCROLL_RESTORATION_STORAGE_KEY","usePageHide","useBeforeUnload","usePrompt","useBlocker","AwaitContext","LocationContext","RouteErrorContext","navigateEffectWarning","useIsomorphicLayoutEffect","isStatic","useNavigateStable","useNavigateUnstable","getPathContributingMatches","OutletContext","useRoutesImpl","parentPathname","parentRoute","warningOnce","_renderMatches","NavigationType","DefaultErrorComponent","lightgrey","preStyles","codeStyles","devInfo","defaultErrorElement","RenderErrorBoundary","RenderedRoute","useRouteContext","useCurrentRouteId","blockerId","alreadyWarned","DataRoutes","AwaitErrorBoundary","ResolveAwait","neverSettledPromise","PopStateEventType","createLocation","createBrowserLocation","createBrowserHref","getUrlBasedHistory","createHashLocation","createHashHref","validateHashLocation","createKey","getHistoryState","immutableRouteKeys","isIndexRoute","convertRoutesToDataRoutes","flattenRoutes","rankRouteBranches","matchRouteBranch","safelyDecodeURI","computeScore","explodeOptionalSegments","compareIndexes","paramRe","dynamicSegmentValue","indexRouteValue","emptySegmentValue","staticSegmentValue","splatPenalty","isSplat","normalizePathname","star","compilePath","safelyDecodeURIComponent","resolvePathname","normalizeSearch","normalizeHash","getInvalidPathError","getToPathname","DeferredData","unwrapTrackedPromise","isTrackedPromise","validMutationMethodsArr","validMutationMethods","validRequestMethodsArr","validRequestMethods","redirectStatusCodes","redirectPreserveMethodStatusCodes","IDLE_NAVIGATION","IDLE_FETCHER","defaultMapRouteProperties","getInternalRouterError","getShortCircuitMatches","HistoryAction","isMutationMethod","mergeLoaderData","normalizeTo","normalizeNavigateOptions","saveScrollPosition","isHashChangeOnly","createClientSideRequest","findNearestBoundary","getLoadingNavigation","getSubmittingNavigation","getTargetMatch","callLoaderOrAction","isRedirectResult","isErrorResult","isDeferredResult","getSubmissionFromNavigation","getMatchesToLoad","getLoadingFetcher","findRedirect","processLoaderData","getSubmittingFetcher","getDoneFetcher","resolveDeferredData","resolveDeferredResults","createUseMatchesMatch","UNSAFE_DEFERRED_SYMBOL","createStaticHandler","query","isValidMethod","methodNotAllowedMatches","actionHeaders","queryImpl","isResponse","queryRoute","_result$activeDeferre","loadRouteData","isQueryRouteResponse","isRedirectResponse","Location","loaderRequest","getLoaderMatchesUntilBoundary","processRouteLoaderData","executedLoaders","fromEntries","getStaticContextFromError","newContext","isSubmissionNavigation","hasNakedIndexQuery","stripHashFromPath","convertFormDataToSearchParams","convertSearchParamsToFormData","isNewLoader","shouldRevalidateLoader","isNewRouteInstance","loadLazyRouteModule","isDeferredData","obj"],"version":3,"file":"dist.62604c19.js.map"}